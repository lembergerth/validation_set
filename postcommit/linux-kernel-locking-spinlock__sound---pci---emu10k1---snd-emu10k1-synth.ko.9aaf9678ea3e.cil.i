/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 7 ".tmp_emu10k1_synth.c"
struct device;
#line 19 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 43 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 48 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 52 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/types.h"
typedef unsigned short umode_t;
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_mode_t;
#line 14 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_pid_t;
#line 16 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_uid_t;
#line 17 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_gid_t;
#line 18 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
#line 19 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
#line 21 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_time_t;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_clock_t;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_timer_t;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef long long __kernel_loff_t;
#line 41 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_uid_t __kernel_uid32_t;
#line 42 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_gid_t __kernel_gid32_t;
#line 21 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 26 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 37 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 39 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 40 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 62 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 67 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 77 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 110 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 141 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 142 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 154 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 201 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 202 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 205 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 210 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 214 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 214 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 219 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 219 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 220 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 225
struct hlist_node;
#line 225 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 229 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 240 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head * ) ;
};
#line 14 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 28 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/rwlock.h"
struct __anonstruct____missing_field_name_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/alternative.h"
struct module;
#line 145 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dynamic_debug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 71 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/bug.h"
struct completion;
#line 72
struct pt_regs;
#line 345 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kernel.h"
struct pid;
#line 766
struct mm_struct;
#line 59 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_11 {
   struct __anonstruct____missing_field_name_12 __annonCompField6 ;
   struct __anonstruct____missing_field_name_13 __annonCompField7 ;
};
#line 125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_11 __annonCompField8 ;
};
#line 13 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 192 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 194 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 194 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 282
struct page;
#line 282 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 290
struct file;
#line 305
struct seq_file;
#line 337
struct thread_struct;
#line 339
struct cpumask;
#line 310 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/ptrace.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 203 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 203 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_18 __annonCompField9 ;
};
#line 306 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 13 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 636 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 233 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/paravirt.h"
struct jump_label_key;
#line 277 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 295 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_23 {
   u64 rip ;
   u64 rdp ;
};
#line 295 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 295 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_22 {
   struct __anonstruct____missing_field_name_23 __annonCompField13 ;
   struct __anonstruct____missing_field_name_24 __annonCompField14 ;
};
#line 295 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 295 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_22 __annonCompField15 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_25 __annonCompField16 ;
};
#line 329 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 350 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 355 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 361 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 367 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 375 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   union thread_xstate *state ;
};
#line 421
struct kmem_cache;
#line 422
struct perf_event;
#line 423 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   unsigned long has_fpu ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 187 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 11 ;
};
#line 552 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_29 __annonCompField18 ;
};
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_28 __annonCompField19 ;
};
#line 76 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 12 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 215 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void *data ;
};
#line 546 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mod_devicetable.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/ioport.h"
struct pci_dev;
#line 230
struct sock;
#line 231
struct kobject;
#line 232
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 238 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/ioport.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   mode_t mode ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 62
struct vm_area_struct;
#line 63 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 98 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 117
struct sysfs_dirent;
#line 182
struct timespec;
#line 397 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 107 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 217
struct klist_node;
#line 37 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/klist.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 110 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 233 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 300 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 99 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/debugobjects.h"
struct tvec_base;
#line 100 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/debugobjects.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 289 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
struct hrtimer;
#line 290
enum hrtimer_restart;
#line 302
struct work_struct;
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 86 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 433 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/workqueue.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 311
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 318
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 326
struct wakeup_source;
#line 471 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 476
struct pm_qos_constraints;
#line 476 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool ignore_children : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int run_wake : 1 ;
   unsigned int runtime_auto : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct pm_qos_constraints *constraints ;
};
#line 532 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 639
struct dma_map_ops;
#line 639 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 17 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/device.h"
struct device_private;
#line 18
struct device_driver;
#line 19
struct driver_private;
#line 20
struct class;
#line 21
struct subsys_private;
#line 22
struct bus_type;
#line 23
struct device_node;
#line 24
struct iommu_ops;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct device_attribute;
#line 51
struct driver_attribute;
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 129
struct notifier_block;
#line 160 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 225 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 255
struct class_attribute;
#line 255 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , mode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 312
struct device_type;
#line 351 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 404 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , mode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 431 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 492 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 501
struct dma_coherent_mem;
#line 501 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
};
#line 613 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
struct wakeup_source {
   char *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long hit_count ;
   unsigned int active : 1 ;
};
#line 69 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/io.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 17
struct pci_bus;
#line 17
struct hotplug_slot;
#line 17 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/irqreturn.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 117 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
typedef int pci_power_t;
#line 143 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 144
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 169 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 186 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 229
struct pcie_link_state;
#line 230
struct pci_vpd;
#line 231
struct pci_sriov;
#line 232
struct pci_ats;
#line 233
struct proc_dir_entry;
#line 233
struct pci_driver;
#line 233 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
union __anonunion____missing_field_name_59 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 233 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 pcie_type : 4 ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int d3_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[18U] ;
   resource_size_t fw_addr[18U] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[18U] ;
   struct bin_attribute *res_attr_wc[18U] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_59 __annonCompField31 ;
   struct pci_ats *ats ;
};
#line 410
struct pci_ops;
#line 410 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 462 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 510 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 519 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 547 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 981 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 98 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_60 {
   unsigned long bits[16U] ;
};
#line 98 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_60 nodemask_t;
#line 661 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mmzone.h"
struct rw_semaphore;
#line 662 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 170 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/srcu.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 60 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_125 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_125 mm_context_t;
#line 374 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/gfp.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 108 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 176
struct prio_tree_node;
#line 176 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rbtree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 19 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 115
struct address_space;
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
union __anonunion____missing_field_name_131 {
   unsigned long index ;
   void *freelist ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct __anonstruct____missing_field_name_135 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
union __anonunion____missing_field_name_134 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_135 __annonCompField33 ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct __anonstruct____missing_field_name_133 {
   union __anonunion____missing_field_name_134 __annonCompField34 ;
   atomic_t _count ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
union __anonunion____missing_field_name_132 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_133 __annonCompField35 ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct __anonstruct____missing_field_name_130 {
   union __anonunion____missing_field_name_131 __annonCompField32 ;
   union __anonunion____missing_field_name_132 __annonCompField36 ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct __anonstruct____missing_field_name_137 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
union __anonunion____missing_field_name_136 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_137 __annonCompField38 ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
union __anonunion____missing_field_name_138 {
   unsigned long private ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/prio_tree.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct____missing_field_name_130 __annonCompField37 ;
   union __anonunion____missing_field_name_136 __annonCompField39 ;
   union __anonunion____missing_field_name_138 __annonCompField40 ;
};
#line 193 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
struct __anonstruct_vm_set_140 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 193 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
union __anonunion_shared_139 {
   struct __anonstruct_vm_set_140 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 193
struct anon_vma;
#line 193
struct vm_operations_struct;
#line 193
struct mempolicy;
#line 193 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_139 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 256 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 262 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 275 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 288
struct linux_binfmt;
#line 288
struct mmu_notifier_mm;
#line 288 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
};
#line 92 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
struct file_ra_state;
#line 44
struct user_struct;
#line 45
struct writeback_control;
#line 177 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 194 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
};
#line 243
struct inode;
#line 123 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   int node ;
   unsigned int stat[24U] ;
};
#line 52 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 63 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 73 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int objsize ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/bug.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 65 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 266 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc_coherent)(struct device * , size_t  , dma_addr_t * , gfp_t  ) ;
   void (*free_coherent)(struct device * , size_t  , void * , dma_addr_t  ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 337 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/irq.h"
struct irqaction;
#line 41 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/sections.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 210 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/hardirq.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 815 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rcupdate.h"
struct jump_entry;
#line 815
struct jump_label_mod;
#line 815 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rcupdate.h"
struct jump_label_key {
   atomic_t enabled ;
   struct jump_entry *entries ;
   struct jump_label_mod *next ;
};
#line 31 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 56 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/jump_label.h"
struct tracepoint;
#line 57 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct jump_label_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 94 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/interrupt.h"
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   void *dev_id ;
   void *percpu_dev_id ;
   struct irqaction *next ;
   int irq ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
   unsigned long thread_mask ;
   char const   *name ;
   struct proc_dir_entry *dir ;
};
#line 493 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 93 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 96 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 104
struct dentry;
#line 105
struct user_namespace;
#line 7 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 98 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 98 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 107
struct siginfo;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_143 {
   unsigned long sig[1U] ;
};
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_143 sigset_t;
#line 17 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 126 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 175 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 187 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct __anonstruct__kill_145 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct __anonstruct__timer_146 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct __anonstruct__rt_147 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_148 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_149 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_150 {
   long _band ;
   int _fd ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
union __anonunion__sifields_144 {
   int _pad[28U] ;
   struct __anonstruct__kill_145 _kill ;
   struct __anonstruct__timer_146 _timer ;
   struct __anonstruct__rt_147 _rt ;
   struct __anonstruct__sigchld_148 _sigchld ;
   struct __anonstruct__sigfault_149 _sigfault ;
   struct __anonstruct__sigpoll_150 _sigpoll ;
};
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_144 _sifields ;
};
#line 94 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 387
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 394
struct pid_namespace;
#line 394 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct rcu_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 10 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/seccomp.h"
struct __anonstruct_seccomp_t_153 {
   int mode ;
};
#line 10 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_153 seccomp_t;
#line 445 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rculist.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 85 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysctl.h"
struct nsproxy;
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 33
struct key;
#line 34
struct signal_struct;
#line 35
struct cred;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 115
struct key_user;
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_156 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/key.h"
union __anonunion_type_data_157 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/key.h"
union __anonunion_payload_158 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_156 __annonCompField43 ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_157 type_data ;
   union __anonunion_payload_158 payload ;
};
#line 310
struct audit_context;
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32U] ;
   gid_t *blocks[0U] ;
};
#line 77 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 91 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 264
struct llist_node;
#line 65 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 186
struct futex_pi_state;
#line 187
struct robust_list_head;
#line 188
struct bio_list;
#line 189
struct fs_struct;
#line 190
struct perf_event_context;
#line 191
struct blk_plug;
#line 151 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct cfs_rq;
#line 152
struct task_group;
#line 44 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 106 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/aio_abi.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/uio.h"
struct kioctx;
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/uio.h"
union __anonunion_ki_obj_159 {
   void *user ;
   struct task_struct *tsk ;
};
#line 55
struct eventfd_ctx;
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/uio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_159 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 163 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 179 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 405 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 452 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 460 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 467 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 484 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 520
struct autogroup;
#line 521
struct tty_struct;
#line 521
struct taskstats;
#line 521
struct tty_audit_buf;
#line 521 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore threadgroup_fork_lock ;
   int oom_adj ;
   int oom_score_adj ;
   int oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 688 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
   atomic_long_t locked_vm ;
};
#line 733
struct backing_dev_info;
#line 734
struct reclaim_state;
#line 735 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 749 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1042
struct io_context;
#line 1064
struct pipe_inode_info;
#line 1066
struct rq;
#line 1067 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1132 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1137 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1172 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1198
struct rt_rq;
#line 1198 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1223
struct mem_cgroup;
#line 1223 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1580
struct files_struct;
#line 1580
struct css_set;
#line 1580
struct compat_robust_list_head;
#line 1580
struct ftrace_ret_stack;
#line 1580 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned int brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct cred *replacement_session_keyring ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   atomic_t ptrace_bp_refcnt ;
};
#line 84 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
struct snd_card;
#line 93
struct snd_info_entry;
#line 93
struct snd_shutdown_f_ops;
#line 93
struct snd_mixer_oss;
#line 93 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
struct snd_card {
   int number ;
   char id[16U] ;
   char driver[16U] ;
   char shortname[32U] ;
   char longname[80U] ;
   char mixername[80U] ;
   char components[128U] ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_card * ) ;
   struct list_head devices ;
   unsigned int last_numid ;
   struct rw_semaphore controls_rwsem ;
   rwlock_t ctl_files_rwlock ;
   int controls_count ;
   int user_ctl_count ;
   struct list_head controls ;
   struct list_head ctl_files ;
   struct mutex user_ctl_lock ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_id ;
   struct proc_dir_entry *proc_root_link ;
   struct list_head files_list ;
   struct snd_shutdown_f_ops *s_f_ops ;
   spinlock_t files_lock ;
   int shutdown ;
   int free_on_last_close ;
   wait_queue_head_t shutdown_sleep ;
   atomic_t refcount ;
   struct device *dev ;
   struct device *card_dev ;
   unsigned int power_state ;
   struct mutex power_lock ;
   wait_queue_head_t power_sleep ;
   struct snd_mixer_oss *mixer_oss ;
   int mixer_oss_change_count ;
};
#line 177
struct file_operations;
#line 462 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
struct snd_aes_iec958 {
   unsigned char status[24U] ;
   unsigned char subcode[147U] ;
   unsigned char pad ;
   unsigned char dig_subframe[4U] ;
};
#line 111 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_hwdep_dsp_status {
   unsigned int version ;
   unsigned char id[32U] ;
   unsigned int num_dsps ;
   unsigned int dsp_loaded ;
   unsigned int chip_ready ;
   unsigned char reserved[16U] ;
};
#line 121 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_hwdep_dsp_image {
   unsigned int index ;
   unsigned char name[64U] ;
   unsigned char *image ;
   size_t length ;
   unsigned long driver_data ;
};
#line 143 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef unsigned long snd_pcm_uframes_t;
#line 144 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef long snd_pcm_sframes_t;
#line 168 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_pcm_access_t;
#line 176 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_pcm_format_t;
#line 244 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_pcm_subformat_t;
#line 265 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_pcm_state_t;
#line 272 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union snd_pcm_sync_id {
   unsigned char id[16U] ;
   unsigned short id16[8U] ;
   unsigned int id32[4U] ;
};
#line 306 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_interval {
   unsigned int min ;
   unsigned int max ;
   unsigned int openmin : 1 ;
   unsigned int openmax : 1 ;
   unsigned int integer : 1 ;
   unsigned int empty : 1 ;
};
#line 348 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_mask {
   __u32 bits[8U] ;
};
#line 354 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_pcm_hw_params {
   unsigned int flags ;
   struct snd_mask masks[3U] ;
   struct snd_mask mres[5U] ;
   struct snd_interval intervals[12U] ;
   struct snd_interval ires[9U] ;
   unsigned int rmask ;
   unsigned int cmask ;
   unsigned int info ;
   unsigned int msbits ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   snd_pcm_uframes_t fifo_size ;
   unsigned char reserved[64U] ;
};
#line 413 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_pcm_mmap_status {
   snd_pcm_state_t state ;
   int pad1 ;
   snd_pcm_uframes_t hw_ptr ;
   struct timespec tstamp ;
   snd_pcm_state_t suspended_state ;
};
#line 421 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_pcm_mmap_control {
   snd_pcm_uframes_t appl_ptr ;
   snd_pcm_uframes_t avail_min ;
};
#line 723 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_ctl_elem_type_t;
#line 733 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_ctl_elem_iface_t;
#line 734 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_ctl_elem_id {
   unsigned int numid ;
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char name[44U] ;
   unsigned int index ;
};
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct __anonstruct_integer_164 {
   long min ;
   long max ;
   long step ;
};
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct __anonstruct_integer64_165 {
   long long min ;
   long long max ;
   long long step ;
};
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct __anonstruct_enumerated_166 {
   unsigned int items ;
   unsigned int item ;
   char name[64U] ;
   __u64 names_ptr ;
   unsigned int names_length ;
};
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_value_163 {
   struct __anonstruct_integer_164 integer ;
   struct __anonstruct_integer64_165 integer64 ;
   struct __anonstruct_enumerated_166 enumerated ;
   unsigned char reserved[128U] ;
};
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_dimen_167 {
   unsigned short d[4U] ;
   unsigned short *d_ptr ;
};
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_ctl_elem_info {
   struct snd_ctl_elem_id id ;
   snd_ctl_elem_type_t type ;
   unsigned int access ;
   unsigned int count ;
   __kernel_pid_t owner ;
   union __anonunion_value_163 value ;
   union __anonunion_dimen_167 dimen ;
   unsigned char reserved[56U] ;
};
#line 817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_integer_169 {
   long value[128U] ;
   long *value_ptr ;
};
#line 817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_integer64_170 {
   long long value[64U] ;
   long long *value_ptr ;
};
#line 817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_enumerated_171 {
   unsigned int item[128U] ;
   unsigned int *item_ptr ;
};
#line 817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_bytes_172 {
   unsigned char data[512U] ;
   unsigned char *data_ptr ;
};
#line 817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
union __anonunion_value_168 {
   union __anonunion_integer_169 integer ;
   union __anonunion_integer64_170 integer64 ;
   union __anonunion_enumerated_171 enumerated ;
   union __anonunion_bytes_172 bytes ;
   struct snd_aes_iec958 iec958 ;
};
#line 817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_ctl_elem_value {
   struct snd_ctl_elem_id id ;
   unsigned int indirect : 1 ;
   union __anonunion_value_168 value ;
   struct timespec tstamp ;
   unsigned char reserved[112U] ;
};
#line 901 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_dma_device {
   int type ;
   struct device *dev ;
};
#line 36 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
struct snd_dma_buffer {
   struct snd_dma_device dev ;
   unsigned char *area ;
   dma_addr_t addr ;
   size_t bytes ;
   void *private_data ;
};
#line 41 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/poll.h"
struct block_device;
#line 89 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kdev_t.h"
struct hlist_bl_node;
#line 89 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rculist_bl.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 100 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 100
struct super_block;
#line 100 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dcache.h"
union __anonunion_d_u_175 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 100 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_175 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
};
#line 151 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 430 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 112 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 59 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/radix-tree.h"
struct radix_tree_node;
#line 59 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fiemap.h"
struct export_operations;
#line 40
struct poll_table_struct;
#line 41
struct kstatfs;
#line 432 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 119 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 185 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 186 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 189 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 211
struct quota_format_type;
#line 212 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 271 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 324 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 340 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 386 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 417
enum migrate_mode;
#line 417
enum migrate_mode;
#line 583 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
union __anonunion_arg_177 {
   char *buf ;
   void *data ;
};
#line 583 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_176 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_177 arg ;
   int error ;
};
#line 583 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_176 read_descriptor_t;
#line 586 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
};
#line 640 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
};
#line 662
struct hd_struct;
#line 662
struct gendisk;
#line 662 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 733
struct posix_acl;
#line 734
struct inode_operations;
#line 734 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_178 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 734 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_179 {
   struct list_head i_dentry ;
   struct rcu_head i_rcu ;
};
#line 734
struct file_lock;
#line 734
struct cdev;
#line 734 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_180 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 734 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   uid_t i_uid ;
   gid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_178 __annonCompField45 ;
   dev_t i_rdev ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   blkcnt_t i_blocks ;
   loff_t i_size ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_179 __annonCompField46 ;
   atomic_t i_count ;
   unsigned int i_blkbits ;
   u64 i_version ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_180 __annonCompField47 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 939 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 947 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 970 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
union __anonunion_f_u_181 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 970 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_181 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 1109 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1110 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_release_private)(struct file_lock * ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 164 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs.h"
struct nlm_lockowner;
#line 165 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 18 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 19 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 23
struct fasync_struct;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_183 {
   struct list_head link ;
   int state ;
};
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_182 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_183 afs ;
};
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_182 fl_u ;
};
#line 1219 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct rcu_head fa_rcu ;
};
#line 1415
struct file_system_type;
#line 1415
struct super_operations;
#line 1415
struct xattr_handler;
#line 1415
struct mtd_info;
#line 1415 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_dirt ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
};
#line 1553 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1592 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
};
#line 1627 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   void (*truncate)(struct inode * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
};
#line 1672 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_devname)(struct seq_file * , struct vfsmount * ) ;
   int (*show_path)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1874 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/poll.h"
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long key ;
};
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 62 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
};
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm_qos.h"
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 40 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 94 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pm_qos.h"
struct snd_pcm_oss_setup {
   char *task_name ;
   unsigned int disable : 1 ;
   unsigned int direct : 1 ;
   unsigned int block : 1 ;
   unsigned int nonblock : 1 ;
   unsigned int partialfrag : 1 ;
   unsigned int nosilence : 1 ;
   unsigned int buggyptr : 1 ;
   unsigned int periods ;
   unsigned int period_size ;
   struct snd_pcm_oss_setup *next ;
};
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm_oss.h"
struct snd_pcm_plugin;
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm_oss.h"
struct snd_pcm_oss_runtime {
   unsigned int params : 1 ;
   unsigned int prepare : 1 ;
   unsigned int trigger : 1 ;
   unsigned int sync_trigger : 1 ;
   int rate ;
   int format ;
   unsigned int channels ;
   unsigned int fragshift ;
   unsigned int maxfrags ;
   unsigned int subdivision ;
   size_t period_bytes ;
   size_t period_frames ;
   size_t period_ptr ;
   unsigned int periods ;
   size_t buffer_bytes ;
   size_t bytes ;
   size_t mmap_bytes ;
   char *buffer ;
   size_t buffer_used ;
   struct mutex params_lock ;
   struct snd_pcm_plugin *plugin_first ;
   struct snd_pcm_plugin *plugin_last ;
   unsigned int prev_hw_ptr_period ;
};
#line 66
struct snd_pcm_substream;
#line 70 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm_oss.h"
struct snd_pcm_oss_substream {
   unsigned int oss : 1 ;
   struct snd_pcm_oss_setup setup ;
};
#line 75 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm_oss.h"
struct snd_pcm_oss_stream {
   struct snd_pcm_oss_setup *setup_list ;
   struct mutex setup_mutex ;
   struct snd_info_entry *proc_entry ;
};
#line 82 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm_oss.h"
struct snd_pcm_oss {
   int reg ;
   unsigned int reg_mask ;
};
#line 88 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm_oss.h"
struct snd_pcm_hardware {
   unsigned int info ;
   u64 formats ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int channels_min ;
   unsigned int channels_max ;
   size_t buffer_bytes_max ;
   size_t period_bytes_min ;
   size_t period_bytes_max ;
   unsigned int periods_min ;
   unsigned int periods_max ;
   size_t fifo_size ;
};
#line 60 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_ops {
   int (*open)(struct snd_pcm_substream * ) ;
   int (*close)(struct snd_pcm_substream * ) ;
   int (*ioctl)(struct snd_pcm_substream * , unsigned int  , void * ) ;
   int (*hw_params)(struct snd_pcm_substream * , struct snd_pcm_hw_params * ) ;
   int (*hw_free)(struct snd_pcm_substream * ) ;
   int (*prepare)(struct snd_pcm_substream * ) ;
   int (*trigger)(struct snd_pcm_substream * , int  ) ;
   snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream * ) ;
   int (*copy)(struct snd_pcm_substream * , int  , snd_pcm_uframes_t  , void * , snd_pcm_uframes_t  ) ;
   int (*silence)(struct snd_pcm_substream * , int  , snd_pcm_uframes_t  , snd_pcm_uframes_t  ) ;
   struct page *(*page)(struct snd_pcm_substream * , unsigned long  ) ;
   int (*mmap)(struct snd_pcm_substream * , struct vm_area_struct * ) ;
   int (*ack)(struct snd_pcm_substream * ) ;
};
#line 210
struct snd_pcm_hw_rule;
#line 213 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_hw_rule {
   unsigned int cond ;
   int (*func)(struct snd_pcm_hw_params * , struct snd_pcm_hw_rule * ) ;
   int var ;
   int deps[4U] ;
   void *private ;
};
#line 222 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_hw_constraints {
   struct snd_mask masks[3U] ;
   struct snd_interval intervals[12U] ;
   unsigned int rules_num ;
   unsigned int rules_all ;
   struct snd_pcm_hw_rule *rules ;
};
#line 270
struct snd_pcm_hwptr_log;
#line 271 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_runtime {
   struct snd_pcm_substream *trigger_master ;
   struct timespec trigger_tstamp ;
   int overrange ;
   snd_pcm_uframes_t avail_max ;
   snd_pcm_uframes_t hw_ptr_base ;
   snd_pcm_uframes_t hw_ptr_interrupt ;
   unsigned long hw_ptr_jiffies ;
   unsigned long hw_ptr_buffer_jiffies ;
   snd_pcm_sframes_t delay ;
   snd_pcm_access_t access ;
   snd_pcm_format_t format ;
   snd_pcm_subformat_t subformat ;
   unsigned int rate ;
   unsigned int channels ;
   snd_pcm_uframes_t period_size ;
   unsigned int periods ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t min_align ;
   size_t byte_align ;
   unsigned int frame_bits ;
   unsigned int sample_bits ;
   unsigned int info ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   unsigned int no_period_wakeup : 1 ;
   int tstamp_mode ;
   unsigned int period_step ;
   snd_pcm_uframes_t start_threshold ;
   snd_pcm_uframes_t stop_threshold ;
   snd_pcm_uframes_t silence_threshold ;
   snd_pcm_uframes_t silence_size ;
   snd_pcm_uframes_t boundary ;
   snd_pcm_uframes_t silence_start ;
   snd_pcm_uframes_t silence_filled ;
   union snd_pcm_sync_id sync ;
   struct snd_pcm_mmap_status *status ;
   struct snd_pcm_mmap_control *control ;
   snd_pcm_uframes_t twake ;
   wait_queue_head_t sleep ;
   wait_queue_head_t tsleep ;
   struct fasync_struct *fasync ;
   void *private_data ;
   void (*private_free)(struct snd_pcm_runtime * ) ;
   struct snd_pcm_hardware hw ;
   struct snd_pcm_hw_constraints hw_constraints ;
   void (*transfer_ack_begin)(struct snd_pcm_substream * ) ;
   void (*transfer_ack_end)(struct snd_pcm_substream * ) ;
   unsigned int timer_resolution ;
   int tstamp_type ;
   unsigned char *dma_area ;
   dma_addr_t dma_addr ;
   size_t dma_bytes ;
   struct snd_dma_buffer *dma_buffer_p ;
   struct snd_pcm_oss_runtime oss ;
   struct snd_pcm_hwptr_log *hwptr_log ;
};
#line 359 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_group {
   spinlock_t lock ;
   struct list_head substreams ;
   int count ;
};
#line 366
struct snd_pcm;
#line 366
struct snd_pcm_str;
#line 366
struct snd_timer;
#line 366 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_substream {
   struct snd_pcm *pcm ;
   struct snd_pcm_str *pstr ;
   void *private_data ;
   int number ;
   char name[32U] ;
   int stream ;
   struct pm_qos_request latency_pm_qos_req ;
   size_t buffer_bytes_max ;
   struct snd_dma_buffer dma_buffer ;
   unsigned int dma_buf_id ;
   size_t dma_max ;
   struct snd_pcm_ops *ops ;
   struct snd_pcm_runtime *runtime ;
   struct snd_timer *timer ;
   unsigned int timer_running : 1 ;
   struct snd_pcm_substream *next ;
   struct list_head link_list ;
   struct snd_pcm_group self_group ;
   struct snd_pcm_group *group ;
   void *file ;
   int ref_count ;
   atomic_t mmap_count ;
   unsigned int f_flags ;
   void (*pcm_release)(struct snd_pcm_substream * ) ;
   struct pid *pid ;
   struct snd_pcm_oss_substream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   struct snd_info_entry *proc_hw_params_entry ;
   struct snd_info_entry *proc_sw_params_entry ;
   struct snd_info_entry *proc_status_entry ;
   struct snd_info_entry *proc_prealloc_entry ;
   struct snd_info_entry *proc_prealloc_max_entry ;
   unsigned int hw_opened : 1 ;
};
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_str {
   int stream ;
   struct snd_pcm *pcm ;
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct snd_pcm_substream *substream ;
   struct snd_pcm_oss_stream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   unsigned int xrun_debug ;
   struct snd_info_entry *proc_xrun_debug_entry ;
};
#line 439 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   unsigned int info_flags ;
   unsigned short dev_class ;
   unsigned short dev_subclass ;
   char id[64U] ;
   char name[80U] ;
   struct snd_pcm_str streams[2U] ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_pcm * ) ;
   struct device *dev ;
   struct snd_pcm_oss oss ;
};
#line 1070 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_seq_device {
   struct snd_card *card ;
   int device ;
   char id[32U] ;
   char name[80U] ;
   int argsize ;
   void *driver_data ;
   int status ;
   void *private_data ;
   void (*private_free)(struct snd_seq_device * ) ;
   struct list_head list ;
};
#line 47 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_device.h"
struct snd_seq_dev_ops {
   int (*init_device)(struct snd_seq_device * ) ;
   int (*free_device)(struct snd_seq_device * ) ;
};
#line 74
struct snd_rawmidi;
#line 75
struct snd_rawmidi_substream;
#line 76
struct snd_seq_port_info;
#line 77 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_device.h"
struct snd_rawmidi_ops {
   int (*open)(struct snd_rawmidi_substream * ) ;
   int (*close)(struct snd_rawmidi_substream * ) ;
   void (*trigger)(struct snd_rawmidi_substream * , int  ) ;
   void (*drain)(struct snd_rawmidi_substream * ) ;
};
#line 58 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
struct snd_rawmidi_global_ops {
   int (*dev_register)(struct snd_rawmidi * ) ;
   int (*dev_unregister)(struct snd_rawmidi * ) ;
   void (*get_port_info)(struct snd_rawmidi * , int  , struct snd_seq_port_info * ) ;
};
#line 64 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
struct snd_rawmidi_runtime {
   struct snd_rawmidi_substream *substream ;
   unsigned int drain : 1 ;
   unsigned int oss : 1 ;
   unsigned char *buffer ;
   size_t buffer_size ;
   size_t appl_ptr ;
   size_t hw_ptr ;
   size_t avail_min ;
   size_t avail ;
   size_t xruns ;
   spinlock_t lock ;
   wait_queue_head_t sleep ;
   void (*event)(struct snd_rawmidi_substream * ) ;
   struct work_struct event_work ;
   void *private_data ;
   void (*private_free)(struct snd_rawmidi_substream * ) ;
};
#line 89
struct snd_rawmidi_str;
#line 89 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
struct snd_rawmidi_substream {
   struct list_head list ;
   int stream ;
   int number ;
   unsigned int opened : 1 ;
   unsigned int append : 1 ;
   unsigned int active_sensing : 1 ;
   int use_count ;
   size_t bytes ;
   struct snd_rawmidi *rmidi ;
   struct snd_rawmidi_str *pstr ;
   char name[32U] ;
   struct snd_rawmidi_runtime *runtime ;
   struct pid *pid ;
   struct snd_rawmidi_ops *ops ;
};
#line 113 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
struct snd_rawmidi_str {
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct list_head substreams ;
};
#line 119 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
struct snd_rawmidi {
   struct snd_card *card ;
   struct list_head list ;
   unsigned int device ;
   unsigned int info_flags ;
   char id[64U] ;
   char name[80U] ;
   int ossreg ;
   struct snd_rawmidi_global_ops *ops ;
   struct snd_rawmidi_str streams[2U] ;
   void *private_data ;
   void (*private_free)(struct snd_rawmidi * ) ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   struct snd_info_entry *dev ;
   struct snd_info_entry *proc_entry ;
   struct snd_seq_device *seq_dev ;
};
#line 187
struct snd_hwdep;
#line 188 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
struct snd_hwdep_ops {
   long long (*llseek)(struct snd_hwdep * , struct file * , long long  , int  ) ;
   long (*read)(struct snd_hwdep * , char * , long  , loff_t * ) ;
   long (*write)(struct snd_hwdep * , char const   * , long  , loff_t * ) ;
   int (*open)(struct snd_hwdep * , struct file * ) ;
   int (*release)(struct snd_hwdep * , struct file * ) ;
   unsigned int (*poll)(struct snd_hwdep * , struct file * , poll_table * ) ;
   int (*ioctl)(struct snd_hwdep * , struct file * , unsigned int  , unsigned long  ) ;
   int (*ioctl_compat)(struct snd_hwdep * , struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct snd_hwdep * , struct file * , struct vm_area_struct * ) ;
   int (*dsp_status)(struct snd_hwdep * , struct snd_hwdep_dsp_status * ) ;
   int (*dsp_load)(struct snd_hwdep * , struct snd_hwdep_dsp_image * ) ;
};
#line 52 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/hwdep.h"
struct snd_hwdep {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   char id[32U] ;
   char name[80U] ;
   int iface ;
   char oss_dev[32U] ;
   int oss_type ;
   int ossreg ;
   struct snd_hwdep_ops ops ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_hwdep * ) ;
   struct mutex open_mutex ;
   int used ;
   unsigned int dsp_loaded ;
   unsigned int exclusive : 1 ;
};
#line 80
struct snd_kcontrol;
#line 30 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
typedef int snd_kcontrol_info_t(struct snd_kcontrol * , struct snd_ctl_elem_info * );
#line 31 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
typedef int snd_kcontrol_get_t(struct snd_kcontrol * , struct snd_ctl_elem_value * );
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
typedef int snd_kcontrol_put_t(struct snd_kcontrol * , struct snd_ctl_elem_value * );
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol * , int  , unsigned int  , unsigned int * );
#line 56
struct snd_ctl_file;
#line 56 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
struct snd_kcontrol_volatile {
   struct snd_ctl_file *owner ;
   unsigned int access ;
};
#line 61 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
union __anonunion_tlv_186 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
#line 61 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
struct snd_kcontrol {
   struct list_head list ;
   struct snd_ctl_elem_id id ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_186 tlv ;
   unsigned long private_value ;
   void *private_data ;
   void (*private_free)(struct snd_kcontrol * ) ;
   struct snd_kcontrol_volatile vd[0U] ;
};
#line 86 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
struct snd_ctl_file {
   struct list_head list ;
   struct snd_card *card ;
   struct pid *pid ;
   int prefer_pcm_subdevice ;
   int prefer_rawmidi_subdevice ;
   wait_queue_head_t change_sleep ;
   spinlock_t read_lock ;
   struct fasync_struct *fasync ;
   int subscribed ;
   struct list_head events ;
};
#line 229 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
struct snd_info_buffer {
   char *buffer ;
   unsigned int curr ;
   unsigned int size ;
   unsigned int len ;
   int stop ;
   int error ;
};
#line 36 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
struct snd_info_entry_text {
   void (*read)(struct snd_info_entry * , struct snd_info_buffer * ) ;
   void (*write)(struct snd_info_entry * , struct snd_info_buffer * ) ;
};
#line 47 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
struct snd_info_entry_ops {
   int (*open)(struct snd_info_entry * , unsigned short  , void ** ) ;
   int (*release)(struct snd_info_entry * , unsigned short  , void * ) ;
   ssize_t (*read)(struct snd_info_entry * , void * , struct file * , char * , size_t  ,
                   loff_t  ) ;
   ssize_t (*write)(struct snd_info_entry * , void * , struct file * , char const   * ,
                    size_t  , loff_t  ) ;
   loff_t (*llseek)(struct snd_info_entry * , void * , struct file * , loff_t  , int  ) ;
   unsigned int (*poll)(struct snd_info_entry * , void * , struct file * , poll_table * ) ;
   int (*ioctl)(struct snd_info_entry * , void * , struct file * , unsigned int  ,
                unsigned long  ) ;
   int (*mmap)(struct snd_info_entry * , void * , struct inode * , struct file * ,
               struct vm_area_struct * ) ;
};
#line 70 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
union __anonunion_c_187 {
   struct snd_info_entry_text text ;
   struct snd_info_entry_ops *ops ;
};
#line 70 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
struct snd_info_entry {
   char const   *name ;
   mode_t mode ;
   long size ;
   unsigned short content ;
   union __anonunion_c_187 c ;
   struct snd_info_entry *parent ;
   struct snd_card *card ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_info_entry * ) ;
   struct proc_dir_entry *p ;
   struct mutex access ;
   struct list_head children ;
   struct list_head list ;
};
#line 198
struct snd_ac97;
#line 199 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
struct snd_ac97_build_ops {
   int (*build_3d)(struct snd_ac97 * ) ;
   int (*build_specific)(struct snd_ac97 * ) ;
   int (*build_spdif)(struct snd_ac97 * ) ;
   int (*build_post_spdif)(struct snd_ac97 * ) ;
   void (*suspend)(struct snd_ac97 * ) ;
   void (*resume)(struct snd_ac97 * ) ;
   void (*update_jacks)(struct snd_ac97 * ) ;
};
#line 437 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct snd_ac97_bus_ops {
   void (*reset)(struct snd_ac97 * ) ;
   void (*warm_reset)(struct snd_ac97 * ) ;
   void (*write)(struct snd_ac97 * , unsigned short  , unsigned short  ) ;
   unsigned short (*read)(struct snd_ac97 * , unsigned short  ) ;
   void (*wait)(struct snd_ac97 * ) ;
   void (*init)(struct snd_ac97 * ) ;
};
#line 446
struct ac97_pcm;
#line 446 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct snd_ac97_bus {
   struct snd_ac97_bus_ops *ops ;
   void *private_data ;
   void (*private_free)(struct snd_ac97_bus * ) ;
   struct snd_card *card ;
   unsigned short num ;
   unsigned short no_vra : 1 ;
   unsigned short dra : 1 ;
   unsigned short isdin : 1 ;
   unsigned int clock ;
   spinlock_t bus_lock ;
   unsigned short used_slots[2U][4U] ;
   unsigned short pcms_count ;
   struct ac97_pcm *pcms ;
   struct snd_ac97 *codec[4U] ;
   struct snd_info_entry *proc ;
};
#line 466 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct snd_ac97_res_table {
   unsigned short reg ;
   unsigned short bits ;
};
#line 482 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct __anonstruct_ad18xx_189 {
   unsigned short unchained[3U] ;
   unsigned short chained[3U] ;
   unsigned short id[3U] ;
   unsigned short pcmreg[3U] ;
   unsigned short codec_cfg[3U] ;
   unsigned char swap_mic_linein ;
   unsigned char lo_as_master ;
};
#line 482 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
union __anonunion_spec_188 {
   struct __anonstruct_ad18xx_189 ad18xx ;
   unsigned int dev_flags ;
};
#line 482 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct snd_ac97 {
   struct snd_ac97_build_ops  const  *build_ops ;
   void *private_data ;
   void (*private_free)(struct snd_ac97 * ) ;
   struct snd_ac97_bus *bus ;
   struct pci_dev *pci ;
   struct snd_info_entry *proc ;
   struct snd_info_entry *proc_regs ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   struct mutex reg_mutex ;
   struct mutex page_mutex ;
   unsigned short num ;
   unsigned short addr ;
   unsigned int id ;
   unsigned short caps ;
   unsigned short ext_id ;
   unsigned short ext_mid ;
   struct snd_ac97_res_table  const  *res_table ;
   unsigned int scaps ;
   unsigned int flags ;
   unsigned int rates[6U] ;
   unsigned int spdif_status ;
   unsigned short regs[128U] ;
   unsigned long reg_accessed[2U] ;
   union __anonunion_spec_188 spec ;
   unsigned char indep_surround ;
   unsigned char channel_mode ;
   unsigned int power_up ;
   struct delayed_work power_work ;
   struct device dev ;
};
#line 619 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct __anonstruct_r_190 {
   unsigned short slots ;
   unsigned short rslots[4U] ;
   unsigned char rate_table[4U] ;
   struct snd_ac97 *codec[4U] ;
};
#line 619 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct ac97_pcm {
   struct snd_ac97_bus *bus ;
   unsigned int stream : 1 ;
   unsigned int exclusive : 1 ;
   unsigned int copy_flag : 1 ;
   unsigned int spdif : 1 ;
   unsigned short aslots ;
   unsigned short cur_dbl ;
   unsigned int rates ;
   struct __anonstruct_r_190 r[2U] ;
   unsigned long private_value ;
};
#line 658 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct snd_util_memblk {
   unsigned int size ;
   unsigned int offset ;
   struct list_head list ;
};
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/util_mem.h"
struct snd_util_memhdr {
   unsigned int size ;
   struct list_head block ;
   int nblocks ;
   unsigned int used ;
   int block_extra_size ;
   struct mutex block_mutex ;
};
#line 61 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/util_mem.h"
struct snd_pcm_indirect {
   unsigned int hw_buffer_size ;
   unsigned int hw_queue_size ;
   unsigned int hw_data ;
   unsigned int hw_io ;
   int hw_ready ;
   unsigned int sw_buffer_size ;
   unsigned int sw_data ;
   unsigned int sw_io ;
   int sw_ready ;
   snd_pcm_uframes_t appl_ptr ;
};
#line 176 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm-indirect.h"
struct snd_timer_hardware {
   unsigned int flags ;
   unsigned long resolution ;
   unsigned long resolution_min ;
   unsigned long resolution_max ;
   unsigned long ticks ;
   int (*open)(struct snd_timer * ) ;
   int (*close)(struct snd_timer * ) ;
   unsigned long (*c_resolution)(struct snd_timer * ) ;
   int (*start)(struct snd_timer * ) ;
   int (*stop)(struct snd_timer * ) ;
   int (*set_period)(struct snd_timer * , unsigned long  , unsigned long  ) ;
   int (*precise_resolution)(struct snd_timer * , unsigned long * , unsigned long * ) ;
};
#line 71 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/timer.h"
struct snd_timer {
   int tmr_class ;
   struct snd_card *card ;
   struct module *module ;
   int tmr_device ;
   int tmr_subdevice ;
   char id[64U] ;
   char name[80U] ;
   unsigned int flags ;
   int running ;
   unsigned long sticks ;
   void *private_data ;
   void (*private_free)(struct snd_timer * ) ;
   struct snd_timer_hardware hw ;
   spinlock_t lock ;
   struct list_head device_list ;
   struct list_head open_list_head ;
   struct list_head active_list_head ;
   struct list_head ack_list_head ;
   struct list_head sack_list_head ;
   struct tasklet_struct task_queue ;
};
#line 149
struct snd_emu10k1;
#line 150
struct snd_emu10k1_pcm;
#line 150 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/timer.h"
struct snd_emu10k1_voice {
   struct snd_emu10k1 *emu ;
   int number ;
   unsigned int use : 1 ;
   unsigned int pcm : 1 ;
   unsigned int efx : 1 ;
   unsigned int synth : 1 ;
   unsigned int midi : 1 ;
   void (*interrupt)(struct snd_emu10k1 * , struct snd_emu10k1_voice * ) ;
   struct snd_emu10k1_pcm *epcm ;
};
#line 1523 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_pcm {
   struct snd_emu10k1 *emu ;
   int type ;
   struct snd_pcm_substream *substream ;
   struct snd_emu10k1_voice *voices[16U] ;
   struct snd_emu10k1_voice *extra ;
   unsigned short running ;
   unsigned short first_ptr ;
   struct snd_util_memblk *memblk ;
   unsigned int start_addr ;
   unsigned int ccca_start_addr ;
   unsigned int capture_ipr ;
   unsigned int capture_inte ;
   unsigned int capture_ba_reg ;
   unsigned int capture_bs_reg ;
   unsigned int capture_idx_reg ;
   unsigned int capture_cr_val ;
   unsigned int capture_cr_val2 ;
   unsigned int capture_bs_val ;
   unsigned int capture_bufsize ;
};
#line 1545 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_pcm_mixer {
   unsigned char send_routing[3U][8U] ;
   unsigned char send_volume[3U][8U] ;
   unsigned short attn[3U] ;
   struct snd_emu10k1_pcm *epcm ;
};
#line 1553 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_memblk {
   struct snd_util_memblk mem ;
   int first_page ;
   int last_page ;
   int pages ;
   int mapped_page ;
   unsigned int map_locked ;
   struct list_head mapped_link ;
   struct list_head mapped_order_link ;
};
#line 1588 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
typedef void snd_fx8010_irq_handler_t(struct snd_emu10k1 * , void * );
#line 1589 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_irq {
   struct snd_emu10k1_fx8010_irq *next ;
   snd_fx8010_irq_handler_t *handler ;
   unsigned short gpr_running ;
   void *private_data ;
};
#line 1596 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_pcm {
   unsigned int valid : 1 ;
   unsigned int opened : 1 ;
   unsigned int active : 1 ;
   unsigned int channels ;
   unsigned int tram_start ;
   unsigned int buffer_size ;
   unsigned short gpr_size ;
   unsigned short gpr_ptr ;
   unsigned short gpr_count ;
   unsigned short gpr_tmpcount ;
   unsigned short gpr_trigger ;
   unsigned short gpr_running ;
   unsigned char etram[32U] ;
   struct snd_pcm_indirect pcm_rec ;
   unsigned int tram_pos ;
   unsigned int tram_shift ;
   struct snd_emu10k1_fx8010_irq *irq ;
};
#line 1616 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010 {
   unsigned short fxbus_mask ;
   unsigned short extin_mask ;
   unsigned short extout_mask ;
   unsigned short pad1 ;
   unsigned int itram_size ;
   struct snd_dma_buffer etram_pages ;
   unsigned int dbg ;
   unsigned char name[128U] ;
   int gpr_size ;
   int gpr_count ;
   struct list_head gpr_ctl ;
   struct mutex lock ;
   struct snd_emu10k1_fx8010_pcm pcm[8U] ;
   spinlock_t irq_lock ;
   struct snd_emu10k1_fx8010_irq *irq_handlers ;
};
#line 1634 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_midi {
   struct snd_emu10k1 *emu ;
   struct snd_rawmidi *rmidi ;
   struct snd_rawmidi_substream *substream_input ;
   struct snd_rawmidi_substream *substream_output ;
   unsigned int midi_mode ;
   spinlock_t input_lock ;
   spinlock_t output_lock ;
   spinlock_t open_lock ;
   int tx_enable ;
   int rx_enable ;
   int port ;
   int ipr_tx ;
   int ipr_rx ;
   void (*interrupt)(struct snd_emu10k1 * , unsigned int  ) ;
};
#line 1657 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu_chip_details {
   u32 vendor ;
   u32 device ;
   u32 subsystem ;
   unsigned char revision ;
   unsigned char emu10k1_chip ;
   unsigned char emu10k2_chip ;
   unsigned char ca0102_chip ;
   unsigned char ca0108_chip ;
   unsigned char ca_cardbus_chip ;
   unsigned char ca0151_chip ;
   unsigned char spk71 ;
   unsigned char sblive51 ;
   unsigned char spdif_bug ;
   unsigned char ac97_chip ;
   unsigned char ecard ;
   unsigned char emu_model ;
   unsigned char spi_dac ;
   unsigned char i2c_adc ;
   unsigned char adc_1361t ;
   unsigned char invert_shared_spdif ;
   char const   *driver ;
   char const   *name ;
   char const   *id ;
};
#line 1683 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu1010 {
   unsigned int output_source[64U] ;
   unsigned int input_source[64U] ;
   unsigned int adc_pads ;
   unsigned int dac_pads ;
   unsigned int internal_clock ;
   unsigned int optical_in ;
   unsigned int optical_out ;
   struct task_struct *firmware_thread ;
};
#line 1694 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1 {
   int irq ;
   unsigned long port ;
   unsigned int tos_link : 1 ;
   unsigned int rear_ac97 : 1 ;
   unsigned int enable_ir : 1 ;
   unsigned int support_tlv : 1 ;
   struct snd_emu_chip_details  const  *card_capabilities ;
   unsigned int audigy ;
   unsigned int revision ;
   unsigned int serial ;
   unsigned short model ;
   unsigned int card_type ;
   unsigned int ecard_ctrl ;
   unsigned long dma_mask ;
   unsigned int delay_pcm_irq ;
   int max_cache_pages ;
   struct snd_dma_buffer silent_page ;
   struct snd_dma_buffer ptb_pages ;
   struct snd_dma_device p16v_dma_dev ;
   struct snd_dma_buffer p16v_buffer ;
   struct snd_util_memhdr *memhdr ;
   struct snd_emu10k1_memblk *reserved_page ;
   struct list_head mapped_link_head ;
   struct list_head mapped_order_link_head ;
   void **page_ptr_table ;
   unsigned long *page_addr_table ;
   spinlock_t memblk_lock ;
   unsigned int spdif_bits[3U] ;
   unsigned int i2c_capture_source ;
   u8 i2c_capture_volume[4U][2U] ;
   struct snd_emu10k1_fx8010 fx8010 ;
   int gpr_base ;
   struct snd_ac97 *ac97 ;
   struct pci_dev *pci ;
   struct snd_card *card ;
   struct snd_pcm *pcm ;
   struct snd_pcm *pcm_mic ;
   struct snd_pcm *pcm_efx ;
   struct snd_pcm *pcm_multi ;
   struct snd_pcm *pcm_p16v ;
   spinlock_t synth_lock ;
   void *synth ;
   int (*get_synth_voice)(struct snd_emu10k1 * ) ;
   spinlock_t reg_lock ;
   spinlock_t emu_lock ;
   spinlock_t voice_lock ;
   spinlock_t spi_lock ;
   spinlock_t i2c_lock ;
   struct snd_emu10k1_voice voices[64U] ;
   struct snd_emu10k1_voice p16v_voices[4U] ;
   struct snd_emu10k1_voice p16v_capture_voice ;
   int p16v_device_offset ;
   u32 p16v_capture_source ;
   u32 p16v_capture_channel ;
   struct snd_emu1010 emu1010 ;
   struct snd_emu10k1_pcm_mixer pcm_mixer[32U] ;
   struct snd_emu10k1_pcm_mixer efx_pcm_mixer[16U] ;
   struct snd_kcontrol *ctl_send_routing ;
   struct snd_kcontrol *ctl_send_volume ;
   struct snd_kcontrol *ctl_attn ;
   struct snd_kcontrol *ctl_efx_send_routing ;
   struct snd_kcontrol *ctl_efx_send_volume ;
   struct snd_kcontrol *ctl_efx_attn ;
   void (*hwvol_interrupt)(struct snd_emu10k1 * , unsigned int  ) ;
   void (*capture_interrupt)(struct snd_emu10k1 * , unsigned int  ) ;
   void (*capture_mic_interrupt)(struct snd_emu10k1 * , unsigned int  ) ;
   void (*capture_efx_interrupt)(struct snd_emu10k1 * , unsigned int  ) ;
   void (*spdif_interrupt)(struct snd_emu10k1 * , unsigned int  ) ;
   void (*dsp_interrupt)(struct snd_emu10k1 * ) ;
   struct snd_pcm_substream *pcm_capture_substream ;
   struct snd_pcm_substream *pcm_capture_mic_substream ;
   struct snd_pcm_substream *pcm_capture_efx_substream ;
   struct snd_pcm_substream *pcm_playback_efx_substream ;
   struct snd_timer *timer ;
   struct snd_emu10k1_midi midi ;
   struct snd_emu10k1_midi midi2 ;
   unsigned int efx_voices_mask[2U] ;
   unsigned int next_free_voice ;
   unsigned int *saved_ptr ;
   unsigned int *saved_gpr ;
   unsigned int *tram_val_saved ;
   unsigned int *tram_addr_saved ;
   unsigned int *saved_icode ;
   unsigned int *p16v_saved ;
   unsigned int saved_a_iocfg ;
   unsigned int saved_hcfg ;
};
#line 158 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asequencer.h"
struct snd_seq_addr {
   unsigned char client ;
   unsigned char port ;
};
#line 466 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asequencer.h"
struct snd_seq_port_info {
   struct snd_seq_addr addr ;
   char name[64U] ;
   unsigned int capability ;
   unsigned int type ;
   int midi_channels ;
   int midi_voices ;
   int synth_voices ;
   int read_use ;
   int write_use ;
   void *kernel ;
   unsigned int flags ;
   unsigned char time_queue ;
   char reserved[59U] ;
};
#line 82 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/sfnt_info.h"
struct soundfont_voice_parm {
   unsigned short moddelay ;
   unsigned short modatkhld ;
   unsigned short moddcysus ;
   unsigned short modrelease ;
   short modkeyhold ;
   short modkeydecay ;
   unsigned short voldelay ;
   unsigned short volatkhld ;
   unsigned short voldcysus ;
   unsigned short volrelease ;
   short volkeyhold ;
   short volkeydecay ;
   unsigned short lfo1delay ;
   unsigned short lfo2delay ;
   unsigned short pefe ;
   unsigned short fmmod ;
   unsigned short tremfrq ;
   unsigned short fm2frq2 ;
   unsigned char cutoff ;
   unsigned char filterQ ;
   unsigned char chorus ;
   unsigned char reverb ;
   unsigned short reserved[4U] ;
};
#line 112 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/sfnt_info.h"
struct soundfont_voice_info {
   unsigned short sf_id ;
   unsigned short sample ;
   int start ;
   int end ;
   int loopstart ;
   int loopend ;
   short rate_offset ;
   unsigned short mode ;
   short root ;
   short tune ;
   unsigned char low ;
   unsigned char high ;
   unsigned char vellow ;
   unsigned char velhigh ;
   signed char fixkey ;
   signed char fixvel ;
   signed char pan ;
   signed char fixpan ;
   short exclusiveClass ;
   unsigned char amplitude ;
   unsigned char attenuation ;
   short scaleTuning ;
   struct soundfont_voice_parm parm ;
   unsigned short sample_mode ;
};
#line 150 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/sfnt_info.h"
struct soundfont_sample_info {
   unsigned short sf_id ;
   unsigned short sample ;
   int start ;
   int end ;
   int loopstart ;
   int loopend ;
   int size ;
   short dummy ;
   unsigned short mode_flags ;
   unsigned int truesize ;
};
#line 204
struct snd_sf_sample;
#line 204 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/sfnt_info.h"
struct snd_sf_zone {
   struct snd_sf_zone *next ;
   unsigned char bank ;
   unsigned char instr ;
   unsigned char mapped ;
   struct soundfont_voice_info v ;
   int counter ;
   struct snd_sf_sample *sample ;
   struct snd_sf_zone *next_instr ;
   struct snd_sf_zone *next_zone ;
};
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/soundfont.h"
struct snd_sf_sample {
   struct soundfont_sample_info v ;
   int counter ;
   struct snd_util_memblk *block ;
   struct snd_sf_sample *next ;
};
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/soundfont.h"
struct snd_soundfont {
   struct snd_soundfont *next ;
   short id ;
   short type ;
   unsigned char name[32U] ;
   struct snd_sf_zone *zones ;
   struct snd_sf_sample *samples ;
};
#line 66 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/soundfont.h"
struct snd_sf_callback {
   void *private_data ;
   int (*sample_new)(void * , struct snd_sf_sample * , struct snd_util_memhdr * ,
                     void const   * , long  ) ;
   int (*sample_free)(void * , struct snd_sf_sample * , struct snd_util_memhdr * ) ;
   void (*sample_reset)(void * ) ;
};
#line 79 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/soundfont.h"
struct snd_sf_list {
   struct snd_soundfont *currsf ;
   int open_client ;
   int mem_used ;
   struct snd_sf_zone *presets[256U] ;
   struct snd_soundfont *fonts ;
   int fonts_size ;
   int zone_counter ;
   int sample_counter ;
   int zone_locked ;
   int sample_locked ;
   struct snd_sf_callback callback ;
   int presets_locked ;
   struct mutex presets_mutex ;
   spinlock_t lock ;
   struct snd_util_memhdr *memhdr ;
};
#line 127 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/soundfont.h"
struct snd_midi_channel {
   void *private ;
   int number ;
   int client ;
   int port ;
   unsigned char midi_mode ;
   unsigned int drum_channel : 1 ;
   unsigned int param_type : 1 ;
   unsigned char midi_aftertouch ;
   unsigned char midi_pressure ;
   unsigned char midi_program ;
   short midi_pitchbend ;
   unsigned char control[128U] ;
   unsigned char note[128U] ;
   short gm_rpn_pitch_bend_range ;
   short gm_rpn_fine_tuning ;
   short gm_rpn_coarse_tuning ;
};
#line 56 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_midi_emul.h"
struct snd_midi_channel_set {
   void *private_data ;
   int client ;
   int port ;
   int max_channels ;
   struct snd_midi_channel *channels ;
   unsigned char midi_mode ;
   unsigned char gs_master_volume ;
   unsigned char gs_chorus_mode ;
   unsigned char gs_reverb_mode ;
};
#line 196 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_midi_emul.h"
struct snd_seq_oss_arg {
   int app_index ;
   int file_mode ;
   int seq_mode ;
   struct snd_seq_addr addr ;
   void *private_data ;
   int event_passing ;
};
#line 80 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_virmidi.h"
struct snd_emux;
#line 81
struct snd_emux_port;
#line 82
struct snd_emux_voice;
#line 83
struct snd_emux_effect_table;
#line 84 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_virmidi.h"
struct snd_emux_operators {
   struct module *owner ;
   struct snd_emux_voice *(*get_voice)(struct snd_emux * , struct snd_emux_port * ) ;
   int (*prepare)(struct snd_emux_voice * ) ;
   void (*trigger)(struct snd_emux_voice * ) ;
   void (*release)(struct snd_emux_voice * ) ;
   void (*update)(struct snd_emux_voice * , int  ) ;
   void (*terminate)(struct snd_emux_voice * ) ;
   void (*free_voice)(struct snd_emux_voice * ) ;
   void (*reset)(struct snd_emux * , int  ) ;
   int (*sample_new)(struct snd_emux * , struct snd_sf_sample * , struct snd_util_memhdr * ,
                     void const   * , long  ) ;
   int (*sample_free)(struct snd_emux * , struct snd_sf_sample * , struct snd_util_memhdr * ) ;
   void (*sample_reset)(struct snd_emux * ) ;
   int (*load_fx)(struct snd_emux * , int  , int  , void const   * , long  ) ;
   void (*sysex)(struct snd_emux * , char * , int  , int  , struct snd_midi_channel_set * ) ;
   int (*oss_ioctl)(struct snd_emux * , int  , int  , int  ) ;
};
#line 72 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emux_synth.h"
struct snd_emux {
   struct snd_card *card ;
   int max_voices ;
   int mem_size ;
   int num_ports ;
   int pitch_shift ;
   struct snd_emux_operators ops ;
   void *hw ;
   unsigned long flags ;
   int midi_ports ;
   int midi_devidx ;
   unsigned int linear_panning : 1 ;
   int hwdep_idx ;
   struct snd_hwdep *hwdep ;
   int num_voices ;
   struct snd_sf_list *sflist ;
   struct snd_emux_voice *voices ;
   int use_time ;
   spinlock_t voice_lock ;
   struct mutex register_mutex ;
   int client ;
   int ports[32U] ;
   struct snd_emux_port *portptrs[32U] ;
   int used ;
   char *name ;
   struct snd_rawmidi **vmidi ;
   struct timer_list tlist ;
   int timer_active ;
   struct snd_util_memhdr *memhdr ;
   struct snd_info_entry *proc ;
   struct snd_seq_device *oss_synth ;
};
#line 135 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emux_synth.h"
struct snd_emux_port {
   struct snd_midi_channel_set chset ;
   struct snd_emux *emu ;
   char port_mode ;
   int volume_atten ;
   unsigned long drum_flags ;
   int ctrls[21U] ;
   struct snd_emux_effect_table *effect ;
   struct snd_seq_oss_arg *oss_arg ;
};
#line 156 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emux_synth.h"
struct snd_emux_voice {
   int ch ;
   int state ;
   unsigned int time ;
   unsigned char note ;
   unsigned char key ;
   unsigned char velocity ;
   struct snd_sf_zone *zone ;
   void *block ;
   struct snd_midi_channel *chan ;
   struct snd_emux_port *port ;
   struct snd_emux *emu ;
   void *hw ;
   unsigned long ontime ;
   struct soundfont_voice_info reg ;
   int avol ;
   int acutoff ;
   int apitch ;
   int apan ;
   int aaux ;
   int ptarget ;
   int vtarget ;
   int ftarget ;
};
#line 204 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emux_synth.h"
struct snd_emux_effect_table {
   short val[34U] ;
   unsigned char flag[34U] ;
};
#line 243 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emux_synth.h"
struct snd_emu10k1_synth_arg {
   struct snd_emu10k1 *hwptr ;
   int index ;
   int seq_ports ;
   int max_voices ;
};
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 28 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 33 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 202 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 210 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 445
struct kernel_param;
#line 446 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 49
struct kparam_array;
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_200 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   u16 flags ;
   union __anonunion____missing_field_name_200 __annonCompField48 ;
};
#line 64 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 70 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 424 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/moduleparam.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/export.h"
struct mod_arch_specific {

};
#line 36 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 200
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 206 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/module.h"
struct module_ref {
   unsigned int incs ;
   unsigned int decs ;
};
#line 354
struct module_sect_attrs;
#line 354
struct module_notes_attrs;
#line 354
struct ftrace_event_call;
#line 354 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 48 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth_local.h"
struct best_voice {
   unsigned int time ;
   int voice ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 99 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef unsigned int uint;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 305 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
typedef int snd_pcm_hw_param_t;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 187 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
struct ldv_struct_main_9 {
   int signal_pending ;
};
#line 191 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
struct ldv_struct_pci_scenario_3 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
typedef int snd_device_type_t;
#line 67 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
typedef int snd_device_state_t;
#line 73
struct snd_device;
#line 74 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
struct snd_device_ops {
   int (*dev_free)(struct snd_device * ) ;
   int (*dev_register)(struct snd_device * ) ;
   int (*dev_disconnect)(struct snd_device * ) ;
};
#line 84 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
struct snd_device {
   struct list_head list ;
   struct snd_card *card ;
   snd_device_state_t state ;
   snd_device_type_t type ;
   void *device_data ;
   struct snd_device_ops *ops ;
};
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 2247 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
};
#line 2102 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
struct ldv_struct_free_irq_5 {
   int arg0 ;
   int signal_pending ;
};
#line 179 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
struct ldv_struct_interrupt_scenario_2 {
   int arg0 ;
   irqreturn_t (*arg1)(int  , void * ) ;
   irqreturn_t (*arg2)(int  , void * ) ;
   void *arg3 ;
   int signal_pending ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 75 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
struct snd_sg_page {
   void *buf ;
   dma_addr_t addr ;
};
#line 80 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
struct snd_sg_buf {
   int size ;
   int pages ;
   int tblsize ;
   struct snd_sg_page *table ;
   struct page **page_table ;
   struct device *dev ;
};
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 264 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
struct snd_pcm_hw_constraint_list {
   unsigned int count ;
   unsigned int *list ;
   unsigned int mask ;
};
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
union __anonunion_tlv_185 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
struct snd_kcontrol_new {
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char *name ;
   unsigned int index ;
   unsigned int access ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_185 tlv ;
   unsigned long private_value ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 472 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
struct snd_ac97_template {
   void *private_data ;
   void (*private_free)(struct snd_ac97 * ) ;
   struct pci_dev *pci ;
   unsigned short num ;
   unsigned short addr ;
   unsigned int scaps ;
   struct snd_ac97_res_table  const  *res_table ;
};
#line 109 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/types.h"
typedef __u32 u_int32_t;
#line 278 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/msr.h"
struct exec_domain;
#line 91 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/personality.h"
struct map_segment;
#line 91 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 623 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
#line 623 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
#line 183 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct compat_timespec;
#line 184 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct __anonstruct_futex_33 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 184 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct __anonstruct_nanosleep_34 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 184
struct pollfd;
#line 184 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct __anonstruct_poll_35 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 184 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
union __anonunion____missing_field_name_32 {
   struct __anonstruct_futex_33 futex ;
   struct __anonstruct_nanosleep_34 nanosleep ;
   struct __anonstruct_poll_35 poll ;
};
#line 184 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sysfs.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_32 __annonCompField20 ;
};
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/ftrace.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   int uaccess_err ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 144 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 1571 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_ctl {
   struct list_head list ;
   unsigned int vcount ;
   unsigned int count ;
   unsigned short gpr[32U] ;
   unsigned int value[32U] ;
   unsigned int min ;
   unsigned int max ;
   unsigned int translation ;
   struct snd_kcontrol *kcontrol ;
};
#line 1900 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_info {
   unsigned int internal_tram_size ;
   unsigned int external_tram_size ;
   char fxbus_names[16U][32U] ;
   char extin_names[16U][32U] ;
   char extout_names[32U][32U] ;
   unsigned int gpr_controls ;
};
#line 2145 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_control_gpr {
   struct snd_ctl_elem_id id ;
   unsigned int vcount ;
   unsigned int count ;
   unsigned short gpr[32U] ;
   unsigned int value[32U] ;
   unsigned int min ;
   unsigned int max ;
   unsigned int translation ;
   unsigned int const   *tlv ;
};
#line 2163 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_control_old_gpr {
   struct snd_ctl_elem_id id ;
   unsigned int vcount ;
   unsigned int count ;
   unsigned short gpr[32U] ;
   unsigned int value[32U] ;
   unsigned int min ;
   unsigned int max ;
   unsigned int translation ;
};
#line 2175 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_code {
   char name[128U] ;
   unsigned long gpr_valid[8U] ;
   __u32 *gpr_map ;
   unsigned int gpr_add_control_count ;
   struct snd_emu10k1_fx8010_control_gpr *gpr_add_controls ;
   unsigned int gpr_del_control_count ;
   struct snd_ctl_elem_id *gpr_del_controls ;
   unsigned int gpr_list_control_count ;
   unsigned int gpr_list_control_total ;
   struct snd_emu10k1_fx8010_control_gpr *gpr_list_controls ;
   unsigned long tram_valid[4U] ;
   __u32 *tram_data_map ;
   __u32 *tram_addr_map ;
   unsigned long code_valid[16U] ;
   __u32 *code ;
};
#line 2205 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_emu10k1_fx8010_pcm_rec {
   unsigned int substream ;
   unsigned int res1 ;
   unsigned int channels ;
   unsigned int tram_start ;
   unsigned int buffer_size ;
   unsigned short gpr_size ;
   unsigned short gpr_ptr ;
   unsigned short gpr_count ;
   unsigned short gpr_tmpcount ;
   unsigned short gpr_trigger ;
   unsigned short gpr_running ;
   unsigned char pad ;
   unsigned char etram[32U] ;
   unsigned int res2 ;
};
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 559 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/asound.h"
struct snd_timer_id {
   int dev_class ;
   int dev_sclass ;
   int card ;
   int device ;
   int subdevice ;
};
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/quota.h"
enum migrate_mode;
#line 417
enum migrate_mode;
#line 40 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 31 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 31 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 mode ;
   u8 bits_per_word ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
};
#line 143
struct spi_message;
#line 202 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
};
#line 450 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 14 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
extern void __ldv_spin_lock(spinlock_t * ) ;
#line 25
static void ldv___ldv_spin_lock_33(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35(spinlock_t *ldv_func_arg1 ) ;
#line 165
void ldv_spin_lock_voice_lock_of_snd_emu10k1(void) ;
#line 166
void ldv_spin_unlock_voice_lock_of_snd_emu10k1(void) ;
#line 43 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 370 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField19.rlock, flags);
  }
#line 373
  return;
}
}
#line 390
__inline static void ldv_spin_unlock_irqrestore_34(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34(spinlock_t *lock , unsigned long flags ) ;
#line 72 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_device.h"
extern int snd_seq_device_register_driver(char * , struct snd_seq_dev_ops * , int  ) ;
#line 73
extern int snd_seq_device_unregister_driver(char * ) ;
#line 233 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emux_synth.h"
extern int snd_emux_new(struct snd_emux ** ) ;
#line 234
extern int snd_emux_register(struct snd_emux * , struct snd_card * , int  , char * ) ;
#line 235
extern int snd_emux_free(struct snd_emux * ) ;
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth_local.h"
void snd_emu10k1_ops_setup(struct snd_emux *emux ) ;
#line 39
int snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw ) ;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth.c"
static int snd_emu10k1_synth_new_device(struct snd_seq_device *dev ) 
{ 
  struct snd_emux *emux ;
  struct snd_emu10k1 *hw ;
  struct snd_emu10k1_synth_arg *arg ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;

  {
#line 39
  arg = (struct snd_emu10k1_synth_arg *)((char *)dev + 176UL);
#line 40
  if ((unsigned long )arg == (unsigned long )((struct snd_emu10k1_synth_arg *)0)) {
#line 41
    return (-22);
  } else {

  }
#line 43
  if (arg->seq_ports <= 0) {
#line 44
    return (0);
  } else {

  }
#line 45
  if (arg->max_voices <= 0) {
#line 46
    arg->max_voices = 1;
  } else
#line 47
  if (arg->max_voices > 64) {
#line 48
    arg->max_voices = 64;
  } else {

  }
  {
#line 50
  tmp = snd_emux_new(& emux);
  }
#line 50
  if (tmp < 0) {
#line 51
    return (-12);
  } else {

  }
  {
#line 53
  snd_emu10k1_ops_setup(emux);
#line 54
  hw = arg->hwptr;
#line 55
  emux->hw = (void *)hw;
#line 56
  emux->max_voices = arg->max_voices;
#line 57
  emux->num_ports = arg->seq_ports;
#line 58
  emux->pitch_shift = -501;
#line 59
  emux->memhdr = hw->memhdr;
#line 61
  emux->midi_ports = 2 < arg->seq_ports ? 2 : arg->seq_ports;
#line 63
  emux->midi_devidx = hw->audigy != 0U ? 2 : 1;
#line 64
  emux->linear_panning = 0U;
#line 65
  emux->hwdep_idx = 2;
#line 67
  tmp___0 = snd_emux_register(emux, dev->card, arg->index, (char *)"Emu10k1");
  }
#line 67
  if (tmp___0 < 0) {
    {
#line 68
    snd_emux_free(emux);
    }
#line 69
    return (-12);
  } else {

  }
  {
#line 72
  ldv___ldv_spin_lock_33(& hw->voice_lock);
#line 73
  hw->synth = (void *)emux;
#line 74
  hw->get_synth_voice = & snd_emu10k1_synth_get_voice;
#line 75
  ldv_spin_unlock_irqrestore_34(& hw->voice_lock, flags);
#line 77
  dev->driver_data = (void *)emux;
  }
#line 79
  return (0);
}
}
#line 82 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth.c"
static int snd_emu10k1_synth_delete_device(struct snd_seq_device *dev ) 
{ 
  struct snd_emux *emux ;
  struct snd_emu10k1 *hw ;
  unsigned long flags ;

  {
#line 88
  if ((unsigned long )dev->driver_data == (unsigned long )((void *)0)) {
#line 89
    return (0);
  } else {

  }
  {
#line 91
  emux = (struct snd_emux *)dev->driver_data;
#line 93
  hw = (struct snd_emu10k1 *)emux->hw;
#line 94
  ldv___ldv_spin_lock_35(& hw->voice_lock);
#line 95
  hw->synth = (void *)0;
#line 96
  hw->get_synth_voice = (int (*)(struct snd_emu10k1 * ))0;
#line 97
  ldv_spin_unlock_irqrestore_34(& hw->voice_lock, flags);
#line 99
  snd_emux_free(emux);
  }
#line 100
  return (0);
}
}
#line 107 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth.c"
static int alsa_emu10k1_synth_init(void) 
{ 
  struct snd_seq_dev_ops ops ;
  int tmp ;

  {
  {
#line 110
  ops.init_device = & snd_emu10k1_synth_new_device;
#line 110
  ops.free_device = & snd_emu10k1_synth_delete_device;
#line 114
  tmp = snd_seq_device_register_driver((char *)"emu10k1-synth", & ops, 24);
  }
#line 114
  return (tmp);
}
}
#line 118 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth.c"
static void alsa_emu10k1_synth_exit(void) 
{ 


  {
  {
#line 120
  snd_seq_device_unregister_driver((char *)"emu10k1-synth");
  }
#line 121
  return;
}
}
#line 200 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
void ldv_insmod_alsa_emu10k1_synth_exit_4_3(void (*arg0)(void) ) ;
#line 201
int ldv_insmod_alsa_emu10k1_synth_init_4_8(int (*arg0)(void) ) ;
#line 209 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
void ldv_insmod_alsa_emu10k1_synth_exit_4_3(void (*arg0)(void) ) 
{ 


  {
  {
#line 210
  alsa_emu10k1_synth_exit();
  }
#line 211
  return;
}
}
#line 214 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
int ldv_insmod_alsa_emu10k1_synth_init_4_8(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 215
  tmp = alsa_emu10k1_synth_init();
  }
#line 215
  return (tmp);
}
}
#line 491 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
static void ldv___ldv_spin_lock_33(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 494
  ldv_spin_lock_voice_lock_of_snd_emu10k1();
#line 496
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 497
  return;
}
}
#line 500 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
__inline static void ldv_spin_unlock_irqrestore_34(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 503
  ldv_spin_unlock_voice_lock_of_snd_emu10k1();
#line 505
  spin_unlock_irqrestore(lock, flags);
  }
#line 506
  return;
}
}
#line 509 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_synth.c.aux"
static void ldv___ldv_spin_lock_35(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 512
  ldv_spin_lock_voice_lock_of_snd_emu10k1();
#line 514
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 515
  return;
}
}
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 65 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 26 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 1833 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
unsigned int snd_emu10k1_ptr_read(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ) ;
#line 1834
void snd_emu10k1_ptr_write(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ,
                           unsigned int data ) ;
#line 1880
int snd_emu10k1_memblk_map(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) ;
#line 1883
int snd_emu10k1_voice_alloc(struct snd_emu10k1 *emu , int type , int number , struct snd_emu10k1_voice **rvoice ) ;
#line 1884
int snd_emu10k1_voice_free(struct snd_emu10k1 *emu , struct snd_emu10k1_voice *pvoice ) ;
#line 28 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_synth_local.h"
int snd_emu10k1_sample_new(struct snd_emux *rec , struct snd_sf_sample *sp , struct snd_util_memhdr *hdr ,
                           void const   *data , long count ) ;
#line 32
int snd_emu10k1_sample_free(struct snd_emux *rec , struct snd_sf_sample *sp , struct snd_util_memhdr *hdr ) ;
#line 39 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void lookup_voices(struct snd_emux *emu , struct snd_emu10k1 *hw , struct best_voice *best ,
                          int active_only ) ;
#line 41
static struct snd_emux_voice *get_voice(struct snd_emux *emu , struct snd_emux_port *port ) ;
#line 43
static int start_voice(struct snd_emux_voice *vp ) ;
#line 44
static void trigger_voice(struct snd_emux_voice *vp ) ;
#line 45
static void release_voice(struct snd_emux_voice *vp ) ;
#line 46
static void update_voice(struct snd_emux_voice *vp , int update ) ;
#line 47
static void terminate_voice(struct snd_emux_voice *vp ) ;
#line 48
static void free_voice(struct snd_emux_voice *vp ) ;
#line 49
static void set_fmmod(struct snd_emu10k1 *hw , struct snd_emux_voice *vp ) ;
#line 50
static void set_fm2frq2(struct snd_emu10k1 *hw , struct snd_emux_voice *vp ) ;
#line 51
static void set_filterQ(struct snd_emu10k1 *hw , struct snd_emux_voice *vp ) ;
#line 64 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static struct snd_emux_operators emu10k1_ops  = 
#line 64
     {& __this_module, & get_voice, & start_voice, & trigger_voice, & release_voice,
    & update_voice, & terminate_voice, & free_voice, 0, & snd_emu10k1_sample_new,
    & snd_emu10k1_sample_free, 0, 0, 0, 0};
#line 78 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
void snd_emu10k1_ops_setup(struct snd_emux *emux ) 
{ 


  {
#line 80
  emux->ops = emu10k1_ops;
#line 81
  return;
}
}
#line 92 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
int snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw ) 
{ 
  struct snd_emux *emu ;
  struct snd_emux_voice *vp ;
  struct best_voice best[4U] ;
  int i ;
  int ch ;

  {
  {
#line 99
  emu = (struct snd_emux *)hw->synth;
#line 101
  lookup_voices(emu, hw, (struct best_voice *)(& best), 1);
#line 102
  i = 0;
  }
#line 102
  goto ldv_31224;
  ldv_31223: ;
#line 103
  if (best[i].voice >= 0) {
#line 105
    vp = emu->voices + (unsigned long )best[i].voice;
#line 106
    ch = vp->ch;
#line 106
    if (ch < 0) {
#line 111
      goto ldv_31222;
    } else {

    }
#line 113
    (vp->emu)->num_voices = (vp->emu)->num_voices - 1;
#line 114
    vp->ch = -1;
#line 115
    vp->state = 0;
#line 116
    return (ch);
  } else {

  }
  ldv_31222: 
#line 102
  i = i + 1;
  ldv_31224: ;
#line 102
  if (i <= 3) {
#line 104
    goto ldv_31223;
  } else {

  }

#line 121
  return (-12);
}
}
#line 129 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void release_voice(struct snd_emux_voice *vp ) 
{ 
  int dcysusv ;
  struct snd_emu10k1 *hw ;

  {
  {
#line 134
  hw = (struct snd_emu10k1 *)vp->hw;
#line 135
  dcysusv = (int )((unsigned char )vp->reg.parm.modrelease) | 32768;
#line 136
  snd_emu10k1_ptr_write(hw, 22U, (unsigned int )vp->ch, (unsigned int )dcysusv);
#line 137
  dcysusv = (int )((unsigned char )vp->reg.parm.volrelease) | 32896;
#line 138
  snd_emu10k1_ptr_write(hw, 18U, (unsigned int )vp->ch, (unsigned int )dcysusv);
  }
#line 139
  return;
}
}
#line 146 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void terminate_voice(struct snd_emux_voice *vp ) 
{ 
  struct snd_emu10k1 *hw ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  struct snd_emu10k1_memblk *emem ;

  {
  {
#line 150
  __ret_warn_on = (unsigned long )vp == (unsigned long )((struct snd_emux_voice *)0);
#line 150
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 150
  if (tmp != 0L) {
    {
#line 150
    warn_slowpath_fmt("sound/pci/emu10k1/emu10k1_callback.c", 150, "BUG? (%s)\n",
                      (char *)"!vp");
    }
  } else {

  }
  {
#line 150
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 150
  if (tmp___0 != 0L) {
#line 151
    return;
  } else {

  }
  {
#line 152
  hw = (struct snd_emu10k1 *)vp->hw;
#line 153
  snd_emu10k1_ptr_write(hw, 18U, (unsigned int )vp->ch, 33023U);
  }
#line 154
  if ((unsigned long )vp->block != (unsigned long )((void *)0)) {
#line 156
    emem = (struct snd_emu10k1_memblk *)vp->block;
#line 157
    if (emem->map_locked != 0U) {
#line 158
      emem->map_locked = emem->map_locked - 1U;
    } else {

    }
  } else {

  }
#line 160
  return;
}
}
#line 166 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void free_voice(struct snd_emux_voice *vp ) 
{ 
  struct snd_emu10k1 *hw ;

  {
#line 170
  hw = (struct snd_emu10k1 *)vp->hw;
#line 175
  if ((unsigned long )hw != (unsigned long )((struct snd_emu10k1 *)0) && vp->ch >= 0) {
    {
#line 176
    snd_emu10k1_ptr_write(hw, 25U, (unsigned int )vp->ch, 65280U);
#line 177
    snd_emu10k1_ptr_write(hw, 18U, (unsigned int )vp->ch, 33023U);
#line 179
    snd_emu10k1_ptr_write(hw, 3U, (unsigned int )vp->ch, 65535U);
#line 180
    snd_emu10k1_ptr_write(hw, 2U, (unsigned int )vp->ch, 65535U);
#line 181
    snd_emu10k1_voice_free(hw, (struct snd_emu10k1_voice *)(& hw->voices) + (unsigned long )vp->ch);
#line 182
    (vp->emu)->num_voices = (vp->emu)->num_voices - 1;
#line 183
    vp->ch = -1;
    }
  } else {

  }
#line 185
  return;
}
}
#line 192 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void update_voice(struct snd_emux_voice *vp , int update ) 
{ 
  struct snd_emu10k1 *hw ;

  {
#line 196
  hw = (struct snd_emu10k1 *)vp->hw;
#line 197
  if (update & 1) {
    {
#line 198
    snd_emu10k1_ptr_write(hw, 134217753U, (unsigned int )vp->ch, (unsigned int )vp->avol);
    }
  } else {

  }
#line 199
  if ((update & 2) != 0) {
    {
#line 200
    snd_emu10k1_ptr_write(hw, 24U, (unsigned int )vp->ch, (unsigned int )vp->apitch);
    }
  } else {

  }
#line 201
  if ((update & 4) != 0) {
    {
#line 202
    snd_emu10k1_ptr_write(hw, 134742017U, (unsigned int )vp->ch, (unsigned int )vp->apan);
#line 203
    snd_emu10k1_ptr_write(hw, 134217729U, (unsigned int )vp->ch, (unsigned int )vp->aaux);
    }
  } else {

  }
#line 205
  if ((update & 8) != 0) {
    {
#line 206
    set_fmmod(hw, vp);
    }
  } else {

  }
#line 207
  if ((update & 16) != 0) {
    {
#line 208
    snd_emu10k1_ptr_write(hw, 28U, (unsigned int )vp->ch, (unsigned int )vp->reg.parm.tremfrq);
    }
  } else {

  }
#line 209
  if ((update & 32) != 0) {
    {
#line 210
    set_fm2frq2(hw, vp);
    }
  } else {

  }
#line 211
  if ((update & 64) != 0) {
    {
#line 212
    set_filterQ(hw, vp);
    }
  } else {

  }
#line 213
  return;
}
}
#line 221 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void lookup_voices(struct snd_emux *emu , struct snd_emu10k1 *hw , struct best_voice *best ,
                          int active_only ) 
{ 
  struct snd_emux_voice *vp ;
  struct best_voice *bp ;
  int i ;
  int state ;
  int val ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 228
  i = 0;
#line 228
  goto ldv_31257;
  ldv_31256: 
#line 229
  (best + (unsigned long )i)->time = 4294967295U;
#line 230
  (best + (unsigned long )i)->voice = -1;
#line 228
  i = i + 1;
  ldv_31257: ;
#line 228
  if (i <= 3) {
#line 230
    goto ldv_31256;
  } else {

  }
#line 237
  i = 0;
#line 237
  goto ldv_31263;
  ldv_31262: 
#line 240
  vp = emu->voices + (unsigned long )i;
#line 241
  state = vp->state;
#line 242
  if (state == 0) {
#line 243
    if (vp->ch < 0) {
#line 244
      if (active_only != 0) {
#line 245
        goto ldv_31261;
      } else {

      }
#line 246
      bp = best;
    } else {
#line 248
      bp = best + 1UL;
    }
  } else
#line 250
  if (state == 3 || state == 17) {
    {
#line 252
    bp = best + 2UL;
#line 254
    tmp = snd_emu10k1_ptr_read(hw, 269484034U, (unsigned int )vp->ch);
#line 254
    val = (int )tmp;
    }
#line 255
    if (val == 0) {
#line 256
      bp = best + 1UL;
    } else {

    }
  } else
#line 259
  if (state == 9) {
#line 260
    goto ldv_31261;
  } else
#line 261
  if (state & 1) {
#line 262
    bp = best + 3UL;
  } else {
#line 264
    goto ldv_31261;
  }
#line 267
  if (((unsigned long )bp != (unsigned long )(best + 1UL) && (unsigned long )bp != (unsigned long )best) && ((int )vp->reg.sample_mode & 8) != 0) {
    {
#line 269
    tmp___0 = snd_emu10k1_ptr_read(hw, 402653192U, (unsigned int )vp->ch);
#line 269
    val = (int )tmp___0;
    }
#line 270
    if (val >= vp->reg.loopstart) {
#line 271
      bp = best + 1UL;
    } else {

    }
  } else {

  }
#line 274
  if (vp->time < bp->time) {
#line 275
    bp->time = vp->time;
#line 276
    bp->voice = i;
  } else {

  }
  ldv_31261: 
#line 237
  i = i + 1;
  ldv_31263: ;
#line 237
  if (i < emu->max_voices) {
#line 239
    goto ldv_31262;
  } else {

  }

#line 244
  return;
}
}
#line 287 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static struct snd_emux_voice *get_voice(struct snd_emux *emu , struct snd_emux_port *port ) 
{ 
  struct snd_emu10k1 *hw ;
  struct snd_emux_voice *vp ;
  struct best_voice best[4U] ;
  int i ;
  struct snd_emu10k1_voice *hwvoice ;
  int tmp ;

  {
  {
#line 294
  hw = (struct snd_emu10k1 *)emu->hw;
#line 296
  lookup_voices(emu, hw, (struct best_voice *)(& best), 0);
#line 297
  i = 0;
  }
#line 297
  goto ldv_31276;
  ldv_31275: ;
#line 298
  if (best[i].voice >= 0) {
#line 299
    vp = emu->voices + (unsigned long )best[i].voice;
#line 300
    if (vp->ch < 0) {
      {
#line 303
      tmp = snd_emu10k1_voice_alloc(hw, 2, 1, & hwvoice);
      }
#line 303
      if (tmp < 0 || (unsigned long )hwvoice == (unsigned long )((struct snd_emu10k1_voice *)0)) {
#line 304
        goto ldv_31274;
      } else {

      }
#line 305
      vp->ch = hwvoice->number;
#line 306
      emu->num_voices = emu->num_voices + 1;
    } else {

    }
#line 308
    return (vp);
  } else {

  }
  ldv_31274: 
#line 297
  i = i + 1;
  ldv_31276: ;
#line 297
  if (i <= 3) {
#line 299
    goto ldv_31275;
  } else {

  }

#line 313
  return ((struct snd_emux_voice *)0);
}
}
#line 320 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static int start_voice(struct snd_emux_voice *vp ) 
{ 
  unsigned int temp ;
  int ch ;
  unsigned int addr ;
  unsigned int mapped_offset ;
  struct snd_midi_channel *chan ;
  struct snd_emu10k1 *hw ;
  struct snd_emu10k1_memblk *emem ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned int shift ;

  {
  {
#line 329
  hw = (struct snd_emu10k1 *)vp->hw;
#line 330
  ch = vp->ch;
#line 331
  __ret_warn_on = ch < 0;
#line 331
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 331
  if (tmp != 0L) {
    {
#line 331
    warn_slowpath_fmt("sound/pci/emu10k1/emu10k1_callback.c", 331, "BUG? (%s)\n",
                      (char *)"ch < 0");
    }
  } else {

  }
  {
#line 331
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 331
  if (tmp___0 != 0L) {
#line 332
    return (-22);
  } else {

  }
#line 333
  chan = vp->chan;
#line 335
  emem = (struct snd_emu10k1_memblk *)vp->block;
#line 336
  if ((unsigned long )emem == (unsigned long )((struct snd_emu10k1_memblk *)0)) {
#line 337
    return (-22);
  } else {

  }
  {
#line 338
  emem->map_locked = emem->map_locked + 1U;
#line 339
  tmp___1 = snd_emu10k1_memblk_map(hw, emem);
  }
#line 339
  if (tmp___1 < 0) {
#line 341
    return (-12);
  } else {

  }
#line 343
  mapped_offset = (unsigned int )(((unsigned long )(emem->mapped_page << 12) | ((unsigned long )emem->mem.offset & 4095UL)) >> 1);
#line 344
  vp->reg.start = (int )((unsigned int )vp->reg.start + mapped_offset);
#line 345
  vp->reg.end = (int )((unsigned int )vp->reg.end + mapped_offset);
#line 346
  vp->reg.loopstart = (int )((unsigned int )vp->reg.loopstart + mapped_offset);
#line 347
  vp->reg.loopend = (int )((unsigned int )vp->reg.loopend + mapped_offset);
#line 351
  if (hw->audigy != 0U) {
    {
#line 352
    temp = 218891524U;
#line 354
    snd_emu10k1_ptr_write(hw, 126U, (unsigned int )ch, temp);
    }
  } else {
    {
#line 356
    temp = 3696492544U;
#line 358
    snd_emu10k1_ptr_write(hw, 11U, (unsigned int )ch, temp);
    }
  }
  {
#line 362
  snd_emu10k1_ptr_write(hw, 18U, (unsigned int )ch, 0U);
#line 363
  snd_emu10k1_ptr_write(hw, 3U, (unsigned int )ch, 65535U);
#line 364
  snd_emu10k1_ptr_write(hw, 2U, (unsigned int )ch, 65535U);
#line 365
  snd_emu10k1_ptr_write(hw, 1U, (unsigned int )ch, 0U);
#line 366
  snd_emu10k1_ptr_write(hw, 0U, (unsigned int )ch, 0U);
#line 369
  snd_emu10k1_ptr_write(hw, 24U, (unsigned int )vp->ch, (unsigned int )vp->apitch);
#line 372
  snd_emu10k1_ptr_write(hw, 20U, (unsigned int )ch, (unsigned int )vp->reg.parm.moddelay);
#line 373
  snd_emu10k1_ptr_write(hw, 21U, (unsigned int )ch, (unsigned int )vp->reg.parm.modatkhld);
#line 374
  snd_emu10k1_ptr_write(hw, 22U, (unsigned int )ch, (unsigned int )vp->reg.parm.moddcysus);
#line 375
  snd_emu10k1_ptr_write(hw, 16U, (unsigned int )ch, (unsigned int )vp->reg.parm.voldelay);
#line 376
  snd_emu10k1_ptr_write(hw, 17U, (unsigned int )ch, (unsigned int )vp->reg.parm.volatkhld);
#line 381
  temp = ((unsigned int )vp->acutoff << 8) | (unsigned int )((unsigned char )vp->avol);
#line 382
  snd_emu10k1_ptr_write(hw, 25U, (unsigned int )vp->ch, temp);
#line 385
  snd_emu10k1_ptr_write(hw, 26U, (unsigned int )ch, (unsigned int )vp->reg.parm.pefe);
#line 388
  snd_emu10k1_ptr_write(hw, 19U, (unsigned int )ch, (unsigned int )vp->reg.parm.lfo1delay);
#line 389
  snd_emu10k1_ptr_write(hw, 23U, (unsigned int )ch, (unsigned int )vp->reg.parm.lfo2delay);
#line 392
  set_fmmod(hw, vp);
#line 394
  snd_emu10k1_ptr_write(hw, 28U, (unsigned int )vp->ch, (unsigned int )vp->reg.parm.tremfrq);
#line 396
  set_fm2frq2(hw, vp);
#line 399
  temp = (unsigned int )vp->reg.parm.reverb;
#line 400
  temp = temp + (unsigned int )(((int )(vp->chan)->control[91] * 9) / 10);
  }
#line 401
  if (temp > 255U) {
#line 401
    temp = 255U;
  } else {

  }
  {
#line 402
  addr = (unsigned int )vp->reg.loopstart;
#line 403
  snd_emu10k1_ptr_write(hw, 6U, (unsigned int )vp->ch, (temp << 24) | addr);
#line 406
  addr = (unsigned int )vp->reg.loopend;
#line 407
  temp = (unsigned int )vp->reg.parm.chorus;
#line 408
  temp = temp + (unsigned int )(((int )chan->control[93] * 9) / 10);
  }
#line 409
  if (temp > 255U) {
#line 409
    temp = 255U;
  } else {

  }
  {
#line 410
  temp = (temp << 24) | addr;
#line 411
  snd_emu10k1_ptr_write(hw, 7U, (unsigned int )ch, temp);
#line 414
  snd_emu10k1_ptr_write(hw, 5U, (unsigned int )ch, 0U);
#line 415
  snd_emu10k1_ptr_write(hw, 4U, (unsigned int )ch, 0U);
#line 418
  temp = ((unsigned int )hw->silent_page.addr << 1U) | 8191U;
#line 419
  snd_emu10k1_ptr_write(hw, 12U, (unsigned int )ch, temp);
#line 420
  snd_emu10k1_ptr_write(hw, 13U, (unsigned int )ch, temp);
#line 452
  addr = (unsigned int )vp->reg.start;
#line 453
  temp = (unsigned int )vp->reg.parm.filterQ;
#line 454
  temp = (temp << 28) | addr;
  }
#line 455
  if (vp->apitch <= 58367) {
#line 456
    temp = temp;
  } else {
#line 458
    shift = (unsigned int )((vp->apitch + -57344) >> 10);
#line 459
    temp = temp | (shift << 25);
  }
#line 461
  if ((int )vp->reg.sample_mode & 1) {
#line 462
    temp = temp | 16777216U;
  } else {

  }
  {
#line 463
  snd_emu10k1_ptr_write(hw, 8U, (unsigned int )ch, temp);
#line 466
  temp = (unsigned int )vp->vtarget << 16;
#line 467
  snd_emu10k1_ptr_write(hw, 3U, (unsigned int )ch, temp | (unsigned int )vp->ftarget);
#line 468
  snd_emu10k1_ptr_write(hw, 2U, (unsigned int )ch, temp | 65280U);
  }
#line 469
  return (0);
}
}
#line 476 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void trigger_voice(struct snd_emux_voice *vp ) 
{ 
  unsigned int temp ;
  unsigned int ptarget ;
  struct snd_emu10k1 *hw ;
  struct snd_emu10k1_memblk *emem ;

  {
#line 482
  hw = (struct snd_emu10k1 *)vp->hw;
#line 484
  emem = (struct snd_emu10k1_memblk *)vp->block;
#line 485
  if ((unsigned long )emem == (unsigned long )((struct snd_emu10k1_memblk *)0) || emem->mapped_page < 0) {
#line 486
    return;
  } else {

  }
  {
#line 491
  ptarget = vp->apitch != 0 ? (unsigned int )((((unsigned long )vp->apitch & 4095UL) | 4096UL) << (int )(((unsigned int )(vp->apitch >> 12) & 15U) + 4U)) & 4294901760U : 0U;
#line 494
  temp = (ptarget | (unsigned int )(vp->apan << 8)) | (unsigned int )vp->aaux;
#line 495
  snd_emu10k1_ptr_write(hw, 1U, (unsigned int )vp->ch, temp);
#line 498
  snd_emu10k1_ptr_write(hw, 0U, (unsigned int )vp->ch, ptarget);
#line 501
  snd_emu10k1_ptr_write(hw, 18U, (unsigned int )vp->ch, (unsigned int )vp->reg.parm.voldcysus | 128U);
  }
#line 502
  return;
}
}
#line 508 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void set_fmmod(struct snd_emu10k1 *hw , struct snd_emux_voice *vp ) 
{ 
  unsigned short fmmod ;
  short pitch ;
  unsigned char cutoff ;
  int modulation ;

  {
#line 515
  pitch = (short )((char )((int )vp->reg.parm.fmmod >> 8));
#line 516
  cutoff = (unsigned char )vp->reg.parm.fmmod;
#line 517
  modulation = (int )(vp->chan)->control[1] + (int )(vp->chan)->midi_pressure;
#line 518
  pitch = (short )((int )((unsigned short )pitch) + (int )((unsigned short )((modulation * 18) / 1200)));
#line 519
  if ((int )pitch < -128) {
#line 519
    pitch = -128;
  } else
#line 519
  if ((int )pitch > 127) {
#line 519
    pitch = 127;
  } else {

  }
  {
#line 520
  fmmod = (unsigned short )((int )((short )((int )((unsigned char )pitch) << 8)) | (int )((short )cutoff));
#line 521
  snd_emu10k1_ptr_write(hw, 27U, (unsigned int )vp->ch, (unsigned int )fmmod);
  }
#line 522
  return;
}
}
#line 526 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void set_fm2frq2(struct snd_emu10k1 *hw , struct snd_emux_voice *vp ) 
{ 
  unsigned short fm2frq2 ;
  short pitch ;
  unsigned char freq ;
  int modulation ;

  {
#line 533
  pitch = (short )((char )((int )vp->reg.parm.fm2frq2 >> 8));
#line 534
  freq = (unsigned char )vp->reg.parm.fm2frq2;
#line 535
  modulation = (int )(vp->chan)->control[1] + (int )(vp->chan)->midi_pressure;
#line 536
  pitch = (short )((int )((unsigned short )pitch) + (int )((unsigned short )((modulation * 18) / 1200)));
#line 537
  if ((int )pitch < -128) {
#line 537
    pitch = -128;
  } else
#line 537
  if ((int )pitch > 127) {
#line 537
    pitch = 127;
  } else {

  }
  {
#line 538
  fm2frq2 = (unsigned short )((int )((short )((int )((unsigned char )pitch) << 8)) | (int )((short )freq));
#line 539
  snd_emu10k1_ptr_write(hw, 29U, (unsigned int )vp->ch, (unsigned int )fm2frq2);
  }
#line 540
  return;
}
}
#line 544 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_callback.c"
static void set_filterQ(struct snd_emu10k1 *hw , struct snd_emux_voice *vp ) 
{ 
  unsigned int val ;
  unsigned int tmp ;

  {
  {
#line 547
  tmp = snd_emu10k1_ptr_read(hw, 8U, (unsigned int )vp->ch);
#line 547
  val = tmp & 268435455U;
#line 548
  val = val | (unsigned int )((int )vp->reg.parm.filterQ << 28);
#line 549
  snd_emu10k1_ptr_write(hw, 8U, (unsigned int )vp->ch, val);
  }
#line 550
  return;
}
}
#line 335 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
extern void __snd_printk(unsigned int  , char const   * , int  , char const   *  , ...) ;
#line 1876 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_util_memblk *snd_emu10k1_synth_alloc(struct snd_emu10k1 *hw , unsigned int size ) ;
#line 1877
int snd_emu10k1_synth_free(struct snd_emu10k1 *emu , struct snd_util_memblk *memblk ) ;
#line 1878
int snd_emu10k1_synth_bzero(struct snd_emu10k1 *emu , struct snd_util_memblk *blk ,
                            int offset , int size ) ;
#line 1879
int snd_emu10k1_synth_copy_from_user(struct snd_emu10k1 *emu , struct snd_util_memblk *blk ,
                                     int offset , char const   *data , int size ) ;
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_patch.c"
int snd_emu10k1_sample_new(struct snd_emux *rec , struct snd_sf_sample *sp , struct snd_util_memhdr *hdr ,
                           void const   *data , long count ) 
{ 
  int offset ;
  int truesize ;
  int size ;
  int loopsize ;
  int blocksize ;
  int loopend ;
  int sampleend ;
  unsigned int start_addr ;
  struct snd_emu10k1 *emu ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 48
  emu = (struct snd_emu10k1 *)rec->hw;
#line 49
  __ret_warn_on = (unsigned long )sp == (unsigned long )((struct snd_sf_sample *)0) || (unsigned long )hdr == (unsigned long )((struct snd_util_memhdr *)0);
#line 49
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 49
  if (tmp != 0L) {
    {
#line 49
    warn_slowpath_fmt("sound/pci/emu10k1/emu10k1_patch.c", 49, "BUG? (%s)\n", (char *)"!sp || !hdr");
    }
  } else {

  }
  {
#line 49
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 49
  if (tmp___0 != 0L) {
#line 50
    return (-22);
  } else {

  }
#line 52
  if (sp->v.size == 0) {
    {
#line 53
    __snd_printk(1U, "sound/pci/emu10k1/emu10k1_patch.c", 53, "emu: rom font for sample %d\n",
                 (int )sp->v.sample);
    }
#line 54
    return (0);
  } else {

  }
#line 58
  sp->v.end = sp->v.end - sp->v.start;
#line 59
  sp->v.loopstart = sp->v.loopstart - sp->v.start;
#line 60
  sp->v.loopend = sp->v.loopend - sp->v.start;
#line 61
  sp->v.start = 0;
#line 64
  sampleend = sp->v.end;
#line 65
  if (sampleend > sp->v.size) {
#line 66
    sampleend = sp->v.size;
  } else {

  }
#line 67
  loopend = sp->v.loopend;
#line 68
  if (loopend > sampleend) {
#line 69
    loopend = sampleend;
  } else {

  }
#line 72
  if (sp->v.loopstart >= sp->v.loopend) {
#line 73
    tmp___1 = sp->v.loopstart;
#line 74
    sp->v.loopstart = sp->v.loopend;
#line 75
    sp->v.loopend = tmp___1;
  } else {

  }
#line 79
  truesize = sp->v.size + 32;
#line 80
  loopsize = 0;
#line 86
  if (((int )sp->v.mode_flags & 4) != 0) {
#line 87
    truesize = truesize + 12;
  } else {

  }
#line 90
  blocksize = truesize;
#line 91
  if (((int )sp->v.mode_flags & 1) == 0) {
#line 92
    blocksize = blocksize * 2;
  } else {

  }
  {
#line 93
  sp->block = snd_emu10k1_synth_alloc(emu, (unsigned int )blocksize);
  }
#line 94
  if ((unsigned long )sp->block == (unsigned long )((struct snd_util_memblk *)0)) {
    {
#line 95
    __snd_printk(1U, "sound/pci/emu10k1/emu10k1_patch.c", 95, "emu10k1: synth malloc failed (size=%d)\n",
                 blocksize);
    }
#line 97
    return (-28);
  } else {

  }
#line 100
  sp->v.truesize = (unsigned int )blocksize;
#line 103
  offset = 0;
#line 104
  size = 32;
#line 105
  if (((int )sp->v.mode_flags & 1) == 0) {
#line 106
    size = size * 2;
  } else {

  }
#line 107
  if (offset + size > blocksize) {
#line 108
    return (-22);
  } else {

  }
  {
#line 109
  snd_emu10k1_synth_bzero(emu, sp->block, offset, size);
#line 110
  offset = offset + size;
#line 113
  size = loopend;
  }
#line 114
  if (((int )sp->v.mode_flags & 1) == 0) {
#line 115
    size = size * 2;
  } else {

  }
#line 116
  if (offset + size > blocksize) {
#line 117
    return (-22);
  } else {

  }
  {
#line 118
  tmp___2 = snd_emu10k1_synth_copy_from_user(emu, sp->block, offset, (char const   *)data,
                                             size);
  }
#line 118
  if (tmp___2 != 0) {
    {
#line 119
    snd_emu10k1_synth_free(emu, sp->block);
#line 120
    sp->block = (struct snd_util_memblk *)0;
    }
#line 121
    return (-14);
  } else {

  }
#line 123
  offset = offset + size;
#line 124
  data = data + (unsigned long )size;
#line 160
  size = sp->v.size - loopend;
#line 161
  if (size < 0) {
#line 162
    return (-22);
  } else {

  }
#line 163
  if (((int )sp->v.mode_flags & 1) == 0) {
#line 164
    size = size * 2;
  } else {

  }
  {
#line 165
  tmp___3 = snd_emu10k1_synth_copy_from_user(emu, sp->block, offset, (char const   *)data,
                                             size);
  }
#line 165
  if (tmp___3 != 0) {
    {
#line 166
    snd_emu10k1_synth_free(emu, sp->block);
#line 167
    sp->block = (struct snd_util_memblk *)0;
    }
#line 168
    return (-14);
  } else {

  }
#line 170
  offset = offset + size;
#line 173
  if (offset < blocksize) {
    {
#line 174
    snd_emu10k1_synth_bzero(emu, sp->block, offset, blocksize - offset);
    }
  } else {

  }
#line 176
  if (((int )sp->v.mode_flags & 4) != 0) {
#line 178
    if (((int )sp->v.mode_flags & 8) != 0) {
#line 179
      sp->v.loopstart = sp->v.end + 4;
#line 180
      sp->v.loopend = sp->v.end + 8;
    } else {

    }
  } else {

  }
#line 199
  start_addr = 64U;
#line 200
  if (((int )sp->v.mode_flags & 1) == 0) {
#line 201
    start_addr = start_addr >> 1;
  } else {

  }
#line 202
  sp->v.start = (int )((unsigned int )sp->v.start + start_addr);
#line 203
  sp->v.end = (int )((unsigned int )sp->v.end + start_addr);
#line 204
  sp->v.loopstart = (int )((unsigned int )sp->v.loopstart + start_addr);
#line 205
  sp->v.loopend = (int )((unsigned int )sp->v.loopend + start_addr);
#line 207
  return (0);
}
}
#line 214 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_patch.c"
int snd_emu10k1_sample_free(struct snd_emux *rec , struct snd_sf_sample *sp , struct snd_util_memhdr *hdr ) 
{ 
  struct snd_emu10k1 *emu ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 219
  emu = (struct snd_emu10k1 *)rec->hw;
#line 220
  __ret_warn_on = (unsigned long )sp == (unsigned long )((struct snd_sf_sample *)0) || (unsigned long )hdr == (unsigned long )((struct snd_util_memhdr *)0);
#line 220
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 220
  if (tmp != 0L) {
    {
#line 220
    warn_slowpath_fmt("sound/pci/emu10k1/emu10k1_patch.c", 220, "BUG? (%s)\n", (char *)"!sp || !hdr");
    }
  } else {

  }
  {
#line 220
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 220
  if (tmp___0 != 0L) {
#line 221
    return (-22);
  } else {

  }
#line 223
  if ((unsigned long )sp->block != (unsigned long )((struct snd_util_memblk *)0)) {
    {
#line 224
    snd_emu10k1_synth_free(emu, sp->block);
#line 225
    sp->block = (struct snd_util_memblk *)0;
    }
  } else {

  }
#line 227
  return (0);
}
}
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/device.h"
void *ldv_dev_get_drvdata(struct device  const  *dev ) ;
#line 24
int ldv_dev_set_drvdata(struct device *dev , void *data ) ;
#line 101 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 320 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 62 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 62 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.h"
extern void ldv_initialize(void) ;
#line 76
void ldv_check_final_state(void) ;
#line 113
int ldv_post_init(int init_ret_val ) ;
#line 124
extern void ldv_pre_probe(void) ;
#line 133
int ldv_post_probe(int probe_ret_val ) ;
#line 141
int ldv_filter_err_code(int ret_val ) ;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/common.h"
extern void __VERIFIER_assume(int  ) ;
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 33
int ldv_undef_int_negative(void) ;
#line 26 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.h"
void ldv_free(void *s ) ;
#line 28
void *ldv_xmalloc(size_t size ) ;
#line 41
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 156 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 727 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/device.h"
static void *ldv_dev_get_drvdata_14(struct device  const  *dev ) ;
#line 732
static int ldv_dev_set_drvdata_15(struct device *dev , void *data ) ;
#line 793 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
extern int pci_enable_device(struct pci_dev * ) ;
#line 810
extern void pci_disable_device(struct pci_dev * ) ;
#line 811
extern void pci_set_master(struct pci_dev * ) ;
#line 845
extern int pci_save_state(struct pci_dev * ) ;
#line 846
extern void pci_restore_state(struct pci_dev * ) ;
#line 852
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 853
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
#line 952
static int ldv___pci_register_driver_33(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                        char const   *ldv_func_arg3 ) ;
#line 964
static void ldv_pci_unregister_driver_34(struct pci_driver *ldv_func_arg1 ) ;
#line 1349 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 1351
  tmp = ldv_dev_get_drvdata_14((struct device  const  *)(& pdev->dev));
  }
#line 1351
  return (tmp);
}
}
#line 1354 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  {
#line 1356
  ldv_dev_set_drvdata_15(& pdev->dev, data);
  }
#line 1357
  return;
}
}
#line 169 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
__inline static void snd_power_change_state(struct snd_card *card , unsigned int state ) 
{ 


  {
  {
#line 171
  card->power_state = state;
#line 172
  __wake_up(& card->power_sleep, 3U, 1, (void *)0);
  }
#line 173
  return;
}
}
#line 288
extern int snd_card_create(int  , char const   * , struct module * , int  , struct snd_card ** ) ;
#line 292
extern int snd_card_disconnect(struct snd_card * ) ;
#line 293
extern int snd_card_free(struct snd_card * ) ;
#line 296
extern int snd_card_register(struct snd_card * ) ;
#line 118 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
extern int snd_dma_alloc_pages(int  , struct device * , size_t  , struct snd_dma_buffer * ) ;
#line 498 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
extern int snd_pcm_suspend_all(struct snd_pcm * ) ;
#line 71 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/seq_device.h"
extern int snd_seq_device_new(struct snd_card * , int  , char * , int  , struct snd_seq_device ** ) ;
#line 581 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
extern void snd_ac97_suspend(struct snd_ac97 * ) ;
#line 582
extern void snd_ac97_resume(struct snd_ac97 * ) ;
#line 1803 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
int snd_emu10k1_create(struct snd_card *card , struct pci_dev *pci , unsigned short extin_mask ,
                       unsigned short extout_mask , long max_cache_bytes , int enable_ir___0 ,
                       uint subsystem___0 , struct snd_emu10k1 **remu ) ;
#line 1812
int snd_emu10k1_pcm(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) ;
#line 1813
int snd_emu10k1_pcm_mic(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) ;
#line 1814
int snd_emu10k1_pcm_efx(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) ;
#line 1815
int snd_p16v_pcm(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) ;
#line 1818
int snd_emu10k1_pcm_multi(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) ;
#line 1820
int snd_emu10k1_mixer(struct snd_emu10k1 *emu , int pcm_device , int multi_device ) ;
#line 1821
int snd_emu10k1_timer(struct snd_emu10k1 *emu , int device ) ;
#line 1822
int snd_emu10k1_fx8010_new(struct snd_emu10k1 *emu , int device , struct snd_hwdep **rhwdep ) ;
#line 1830
int snd_emu10k1_done(struct snd_emu10k1 *emu ) ;
#line 1860
void snd_emu10k1_suspend_regs(struct snd_emu10k1 *emu ) ;
#line 1861
void snd_emu10k1_resume_init(struct snd_emu10k1 *emu ) ;
#line 1862
void snd_emu10k1_resume_regs(struct snd_emu10k1 *emu ) ;
#line 1865
void snd_emu10k1_efx_suspend(struct snd_emu10k1 *emu ) ;
#line 1866
void snd_emu10k1_efx_resume(struct snd_emu10k1 *emu ) ;
#line 1869
void snd_p16v_suspend(struct snd_emu10k1 *emu ) ;
#line 1870
void snd_p16v_resume(struct snd_emu10k1 *emu ) ;
#line 1887
int snd_emu10k1_midi(struct snd_emu10k1 *emu ) ;
#line 1888
int snd_emu10k1_audigy_midi(struct snd_emu10k1 *emu ) ;
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int index[32U]  = 
#line 45 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static char *id[32U]  = 
#line 46
  {      (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0};
#line 47 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int enable[32U]  = 
#line 47
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
#line 48 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int extin[32U]  ;
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int extout[32U]  ;
#line 50 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int seq_ports[32U]  = 
#line 50
  {      4,      4,      4,      4, 
        4,      4,      4,      4, 
        4,      4,      4,      4, 
        4,      4,      4,      4, 
        4,      4,      4,      4, 
        4,      4,      4,      4, 
        4,      4,      4,      4, 
        4,      4,      4,      4};
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int max_synth_voices[32U]  = 
#line 51
  {      64,      64,      64,      64, 
        64,      64,      64,      64, 
        64,      64,      64,      64, 
        64,      64,      64,      64, 
        64,      64,      64,      64, 
        64,      64,      64,      64, 
        64,      64,      64,      64, 
        64,      64,      64,      64};
#line 52 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int max_buffer_size[32U]  = 
#line 52
  {      128,      128,      128,      128, 
        128,      128,      128,      128, 
        128,      128,      128,      128, 
        128,      128,      128,      128, 
        128,      128,      128,      128, 
        128,      128,      128,      128, 
        128,      128,      128,      128, 
        128,      128,      128,      128};
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int enable_ir[32U]  ;
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static uint subsystem[32U]  ;
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static uint delay_pcm_irq[32U]  = 
#line 55
  {      2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U, 
        2U,      2U,      2U,      2U};
#line 82 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static struct pci_device_id  const  snd_emu10k1_ids[4U]  = {      {4354U, 2U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4354U, 4U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {4354U, 8U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 100 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 102 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int snd_card_emu10k1_probe(struct pci_dev *pci , struct pci_device_id  const  *pci_id ) 
{ 
  int dev ;
  struct snd_card *card ;
  struct snd_emu10k1 *emu ;
  struct snd_seq_device *wave ;
  int err ;
  struct snd_emu10k1_synth_arg *arg ;
  int tmp ;

  {
#line 109
  wave = (struct snd_seq_device *)0;
#line 113
  if (dev > 31) {
#line 114
    return (-19);
  } else {

  }
#line 115
  if (enable[dev] == 0) {
#line 116
    dev = dev + 1;
#line 117
    return (-2);
  } else {

  }
  {
#line 120
  err = snd_card_create(index[dev], (char const   *)id[dev], & __this_module, 0, & card);
  }
#line 121
  if (err < 0) {
#line 122
    return (err);
  } else {

  }
#line 123
  if (max_buffer_size[dev] <= 31) {
#line 124
    max_buffer_size[dev] = 32;
  } else
#line 125
  if (max_buffer_size[dev] > 1024) {
#line 126
    max_buffer_size[dev] = 1024;
  } else {

  }
  {
#line 127
  err = snd_emu10k1_create(card, pci, (int )((unsigned short )extin[dev]), (int )((unsigned short )extout[dev]),
                           (long )max_buffer_size[dev] * 1048576L, enable_ir[dev],
                           subsystem[dev], & emu);
  }
#line 127
  if (err < 0) {
#line 131
    goto error;
  } else {

  }
  {
#line 132
  card->private_data = (void *)emu;
#line 133
  emu->delay_pcm_irq = delay_pcm_irq[dev] & 31U;
#line 134
  err = snd_emu10k1_pcm(emu, 0, (struct snd_pcm **)0);
  }
#line 134
  if (err < 0) {
#line 135
    goto error;
  } else {

  }
  {
#line 136
  err = snd_emu10k1_pcm_mic(emu, 1, (struct snd_pcm **)0);
  }
#line 136
  if (err < 0) {
#line 137
    goto error;
  } else {

  }
  {
#line 138
  err = snd_emu10k1_pcm_efx(emu, 2, (struct snd_pcm **)0);
  }
#line 138
  if (err < 0) {
#line 139
    goto error;
  } else {

  }
#line 141
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 142
    err = snd_dma_alloc_pages(2, & pci->dev, 1024UL, & emu->p16v_buffer);
    }
#line 142
    if (err < 0) {
#line 144
      goto error;
    } else {

    }
  } else {

  }
  {
#line 147
  err = snd_emu10k1_mixer(emu, 0, 3);
  }
#line 147
  if (err < 0) {
#line 148
    goto error;
  } else {

  }
  {
#line 150
  err = snd_emu10k1_timer(emu, 0);
  }
#line 150
  if (err < 0) {
#line 151
    goto error;
  } else {

  }
  {
#line 153
  err = snd_emu10k1_pcm_multi(emu, 3, (struct snd_pcm **)0);
  }
#line 153
  if (err < 0) {
#line 154
    goto error;
  } else {

  }
#line 155
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 156
    err = snd_p16v_pcm(emu, 4, (struct snd_pcm **)0);
    }
#line 156
    if (err < 0) {
#line 157
      goto error;
    } else {

    }
  } else {

  }
#line 159
  if (emu->audigy != 0U) {
    {
#line 160
    err = snd_emu10k1_audigy_midi(emu);
    }
#line 160
    if (err < 0) {
#line 161
      goto error;
    } else {

    }
  } else {
    {
#line 163
    err = snd_emu10k1_midi(emu);
    }
#line 163
    if (err < 0) {
#line 164
      goto error;
    } else {

    }
  }
  {
#line 166
  err = snd_emu10k1_fx8010_new(emu, 0, (struct snd_hwdep **)0);
  }
#line 166
  if (err < 0) {
#line 167
    goto error;
  } else {

  }
  {
#line 169
  tmp = snd_seq_device_new(card, 1, (char *)"emu10k1-synth", 24, & wave);
  }
#line 169
  if (tmp < 0 || (unsigned long )wave == (unsigned long )((struct snd_seq_device *)0)) {
    {
#line 172
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1.c", 172, "<4>can\'t initialize Emu10k1 wavetable synth\n");
    }
  } else {
    {
#line 175
    arg = (struct snd_emu10k1_synth_arg *)((char *)wave + 176UL);
#line 176
    strcpy((char *)(& wave->name), "Emu-10k1 Synth");
#line 177
    arg->hwptr = emu;
#line 178
    arg->index = 1;
#line 179
    arg->seq_ports = seq_ports[dev];
#line 180
    arg->max_voices = max_synth_voices[dev];
    }
  }
  {
#line 184
  strcpy((char *)(& card->driver), (emu->card_capabilities)->driver);
#line 185
  strcpy((char *)(& card->shortname), (emu->card_capabilities)->name);
#line 186
  snprintf((char *)(& card->longname), 80UL, "%s (rev.%d, serial:0x%x) at 0x%lx, irq %i",
           (char *)(& card->shortname), emu->revision, emu->serial, emu->port, emu->irq);
#line 190
  err = snd_card_register(card);
  }
#line 190
  if (err < 0) {
#line 191
    goto error;
  } else {

  }
  {
#line 193
  pci_set_drvdata(pci, (void *)card);
#line 194
  dev = dev + 1;
  }
#line 195
  return (0);
  error: 
  {
#line 198
  snd_card_free(card);
  }
#line 199
  return (err);
}
}
#line 202 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static void snd_card_emu10k1_remove(struct pci_dev *pci ) 
{ 
  void *tmp ;

  {
  {
#line 204
  tmp = pci_get_drvdata(pci);
#line 204
  snd_card_free((struct snd_card *)tmp);
#line 205
  pci_set_drvdata(pci, (void *)0);
  }
#line 206
  return;
}
}
#line 210 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int snd_emu10k1_suspend(struct pci_dev *pci , pm_message_t state ) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct snd_emu10k1 *emu ;
  pci_power_t tmp___0 ;

  {
  {
#line 212
  tmp = pci_get_drvdata(pci);
#line 212
  card = (struct snd_card *)tmp;
#line 213
  emu = (struct snd_emu10k1 *)card->private_data;
#line 215
  snd_power_change_state(card, 768U);
#line 217
  snd_pcm_suspend_all(emu->pcm);
#line 218
  snd_pcm_suspend_all(emu->pcm_mic);
#line 219
  snd_pcm_suspend_all(emu->pcm_efx);
#line 220
  snd_pcm_suspend_all(emu->pcm_multi);
#line 221
  snd_pcm_suspend_all(emu->pcm_p16v);
#line 223
  snd_ac97_suspend(emu->ac97);
#line 225
  snd_emu10k1_efx_suspend(emu);
#line 226
  snd_emu10k1_suspend_regs(emu);
  }
#line 227
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 228
    snd_p16v_suspend(emu);
    }
  } else {

  }
  {
#line 230
  snd_emu10k1_done(emu);
#line 232
  pci_disable_device(pci);
#line 233
  pci_save_state(pci);
#line 234
  tmp___0 = pci_choose_state(pci, state);
#line 234
  pci_set_power_state(pci, tmp___0);
  }
#line 235
  return (0);
}
}
#line 238 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int snd_emu10k1_resume(struct pci_dev *pci ) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct snd_emu10k1 *emu ;
  int tmp___0 ;

  {
  {
#line 240
  tmp = pci_get_drvdata(pci);
#line 240
  card = (struct snd_card *)tmp;
#line 241
  emu = (struct snd_emu10k1 *)card->private_data;
#line 243
  pci_set_power_state(pci, 0);
#line 244
  pci_restore_state(pci);
#line 245
  tmp___0 = pci_enable_device(pci);
  }
#line 245
  if (tmp___0 < 0) {
    {
#line 246
    printk("<3>emu10k1: pci_enable_device failed, disabling device\n");
#line 248
    snd_card_disconnect(card);
    }
#line 249
    return (-5);
  } else {

  }
  {
#line 251
  pci_set_master(pci);
#line 253
  snd_emu10k1_resume_init(emu);
#line 254
  snd_emu10k1_efx_resume(emu);
#line 255
  snd_ac97_resume(emu->ac97);
#line 256
  snd_emu10k1_resume_regs(emu);
  }
#line 258
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 259
    snd_p16v_resume(emu);
    }
  } else {

  }
  {
#line 261
  snd_power_change_state(card, 0U);
  }
#line 262
  return (0);
}
}
#line 266 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static struct pci_driver driver  = 
#line 266
     {{0, 0}, "snd_emu10k1", (struct pci_device_id  const  *)(& snd_emu10k1_ids), & snd_card_emu10k1_probe,
    & snd_card_emu10k1_remove, & snd_emu10k1_suspend, 0, 0, & snd_emu10k1_resume,
    0, 0, {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}};
#line 277 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static int alsa_card_emu10k1_init(void) 
{ 
  int tmp ;

  {
  {
#line 279
  tmp = ldv___pci_register_driver_33(& driver, & __this_module, "snd_emu10k1");
  }
#line 279
  return (tmp);
}
}
#line 282 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1.c"
static void alsa_card_emu10k1_exit(void) 
{ 


  {
  {
#line 284
  ldv_pci_unregister_driver_34(& driver);
  }
#line 285
  return;
}
}
#line 198 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0 ) ;
#line 199
void ldv_dispatch_insmod_deregister_9_1(void) ;
#line 200
void ldv_dispatch_insmod_register_9_2(void) ;
#line 201
void ldv_dispatch_register_8_3(struct pci_driver *arg0 ) ;
#line 202
int ldv_emg___pci_register_driver(struct pci_driver *arg0 , struct module *arg1 ,
                                  char *arg2 ) ;
#line 204
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0 ) ;
#line 206
void ldv_insmod_4(void *arg0 ) ;
#line 207
void ldv_insmod_alsa_card_emu10k1_exit_4_11(void (*arg0)(void) ) ;
#line 208
void ldv_insmod_alsa_card_emu10k1_exit_4_2(void (*arg0)(void) ) ;
#line 209
void ldv_insmod_alsa_card_emu10k1_exit_4_6(void (*arg0)(void) ) ;
#line 210
int ldv_insmod_alsa_card_emu10k1_init_4_13(int (*arg0)(void) ) ;
#line 214
void ldv_main_9(void *arg0 ) ;
#line 215
void ldv_pci_scenario_3(void *arg0 ) ;
#line 216
int ldv_pci_scenario_probe_3_17(snd_pcm_hw_param_t (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) ;
#line 217
void ldv_pci_scenario_release_3_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 218
void ldv_pci_scenario_resume_3_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 219
void ldv_pci_scenario_resume_early_3_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 220
void ldv_pci_scenario_shutdown_3_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 221
int ldv_pci_scenario_suspend_3_8(int (*arg0)(struct pci_dev * , pm_message_t  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 222
int ldv_pci_scenario_suspend_late_3_7(int (*arg0)(struct pci_dev * , pm_message_t  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 223
int main(void) ;
#line 231 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_dispatch_deregister_7_1(struct pci_driver *arg0 ) 
{ 


  {
#line 234
  return;
}
}
#line 238 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_dispatch_insmod_deregister_9_1(void) 
{ 


  {
#line 241
  return;
}
}
#line 245 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_dispatch_insmod_register_9_2(void) 
{ 
  struct ldv_struct_main_9 *cf_arg_4 ;
  void *tmp ;

  {
  {
#line 247
  tmp = ldv_xmalloc(4UL);
#line 247
  cf_arg_4 = (struct ldv_struct_main_9 *)tmp;
#line 248
  ldv_insmod_4((void *)cf_arg_4);
  }
#line 249
  return;
}
}
#line 253 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_dispatch_register_8_3(struct pci_driver *arg0 ) 
{ 
  struct ldv_struct_pci_scenario_3 *cf_arg_3 ;
  void *tmp ;

  {
  {
#line 255
  tmp = ldv_xmalloc(16UL);
#line 255
  cf_arg_3 = (struct ldv_struct_pci_scenario_3 *)tmp;
#line 256
  cf_arg_3->arg0 = arg0;
#line 257
  ldv_pci_scenario_3((void *)cf_arg_3);
  }
#line 258
  return;
}
}
#line 262 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
int ldv_emg___pci_register_driver(struct pci_driver *arg0 , struct module *arg1 ,
                                  char *arg2 ) 
{ 
  struct pci_driver *ldv_8_pci_driver_pci_driver ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 269
  tmp___0 = ldv_undef_int();
  }
#line 269
  if (tmp___0 != 0) {
    {
#line 271
    ldv_8_pci_driver_pci_driver = arg0;
#line 275
    ldv_dispatch_register_8_3(ldv_8_pci_driver_pci_driver);
    }
#line 279
    return (0);
  } else {
    {
#line 286
    tmp = ldv_undef_int_negative();
    }
#line 286
    return (tmp);
  }
}
}
#line 296 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_emg_pci_unregister_driver(struct pci_driver *arg0 ) 
{ 
  struct pci_driver *ldv_7_pci_driver_pci_driver ;

  {
  {
#line 302
  ldv_7_pci_driver_pci_driver = arg0;
#line 306
  ldv_dispatch_deregister_7_1(ldv_7_pci_driver_pci_driver);
  }
#line 310
  return;
#line 312
  return;
}
}
#line 317 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_insmod_4(void *arg0 ) 
{ 
  void (*ldv_4_alsa_card_emu10k1_exit_default)(void) ;
  int (*ldv_4_alsa_card_emu10k1_init_default)(void) ;
  void (*ldv_4_alsa_emu10k1_synth_exit_default)(void) ;
  int (*ldv_4_alsa_emu10k1_synth_init_default)(void) ;
  int ldv_4_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 327
  ldv_free(arg0);
#line 332
  ldv_4_ret_default = ldv_insmod_alsa_card_emu10k1_init_4_13(ldv_4_alsa_card_emu10k1_init_default);
#line 334
  ldv_4_ret_default = ldv_post_init(ldv_4_ret_default);
#line 337
  tmp___0 = ldv_undef_int();
  }
#line 337
  if (tmp___0 != 0) {
    {
#line 339
    __VERIFIER_assume(ldv_4_ret_default != 0);
#line 344
    ldv_insmod_alsa_card_emu10k1_exit_4_11(ldv_4_alsa_card_emu10k1_exit_default);
    }
#line 352
    return;
  } else {
    {
#line 356
    __VERIFIER_assume(ldv_4_ret_default == 0);
#line 361
    ldv_4_ret_default = ldv_insmod_alsa_emu10k1_synth_init_4_8(ldv_4_alsa_emu10k1_synth_init_default);
#line 363
    ldv_4_ret_default = ldv_post_init(ldv_4_ret_default);
#line 366
    tmp = ldv_undef_int();
    }
#line 366
    if (tmp != 0) {
      {
#line 368
      __VERIFIER_assume(ldv_4_ret_default != 0);
#line 373
      ldv_insmod_alsa_card_emu10k1_exit_4_6(ldv_4_alsa_card_emu10k1_exit_default);
      }
#line 381
      return;
    } else {
      {
#line 385
      __VERIFIER_assume(ldv_4_ret_default == 0);
#line 390
      ldv_insmod_alsa_emu10k1_synth_exit_4_3(ldv_4_alsa_emu10k1_synth_exit_default);
#line 395
      ldv_insmod_alsa_card_emu10k1_exit_4_2(ldv_4_alsa_card_emu10k1_exit_default);
      }
#line 403
      return;
    }
  }
#line 407
  return;
}
}
#line 412 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_insmod_alsa_card_emu10k1_exit_4_11(void (*arg0)(void) ) 
{ 


  {
  {
#line 413
  alsa_card_emu10k1_exit();
  }
#line 414
  return;
}
}
#line 417 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_insmod_alsa_card_emu10k1_exit_4_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 418
  alsa_card_emu10k1_exit();
  }
#line 419
  return;
}
}
#line 422 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_insmod_alsa_card_emu10k1_exit_4_6(void (*arg0)(void) ) 
{ 


  {
  {
#line 423
  alsa_card_emu10k1_exit();
  }
#line 424
  return;
}
}
#line 427 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
int ldv_insmod_alsa_card_emu10k1_init_4_13(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 428
  tmp = alsa_card_emu10k1_init();
  }
#line 428
  return (tmp);
}
}
#line 432 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_main_9(void *arg0 ) 
{ 


  {
  {
#line 437
  ldv_dispatch_insmod_register_9_2();
#line 441
  ldv_dispatch_insmod_deregister_9_1();
  }
#line 445
  return;
#line 447
  return;
}
}
#line 452 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_pci_scenario_3(void *arg0 ) 
{ 
  struct pci_driver *ldv_3_container_pci_driver ;
  struct pci_device_id *ldv_3_ldv_param_17_1_default ;
  struct pci_dev *ldv_3_resource_dev ;
  pm_message_t ldv_3_resource_pm_message ;
  int ldv_3_ret_default ;
  struct ldv_struct_pci_scenario_3 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 461
  data = (struct ldv_struct_pci_scenario_3 *)arg0;
#line 465
  ldv_3_ret_default = ldv_undef_int();
  }
#line 468
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_pci_scenario_3 *)0)) {
    {
#line 469
    ldv_3_container_pci_driver = data->arg0;
#line 470
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 475
  tmp = ldv_xmalloc(2864UL);
#line 475
  ldv_3_resource_dev = (struct pci_dev *)tmp;
  }
#line 482
  goto ldv_main_3;
#line 484
  return;
  ldv_main_3: 
  {
#line 490
  tmp___2 = ldv_undef_int();
  }
#line 490
  if (tmp___2 != 0) {
    {
#line 492
    tmp___0 = ldv_xmalloc_unknown_size(0UL);
#line 492
    ldv_3_ldv_param_17_1_default = (struct pci_device_id *)tmp___0;
#line 497
    ldv_pre_probe();
#line 499
    ldv_3_ret_default = ldv_pci_scenario_probe_3_17((snd_pcm_hw_param_t (*)(struct pci_dev * ,
                                                                            struct pci_device_id * ))ldv_3_container_pci_driver->probe,
                                                    ldv_3_resource_dev, ldv_3_ldv_param_17_1_default);
#line 501
    ldv_3_ret_default = ldv_post_probe(ldv_3_ret_default);
#line 505
    ldv_free((void *)ldv_3_ldv_param_17_1_default);
#line 508
    tmp___1 = ldv_undef_int();
    }
#line 508
    if (tmp___1 != 0) {
      {
#line 510
      __VERIFIER_assume(ldv_3_ret_default == 0);
      }
#line 517
      goto ldv_call_3;
    } else {
      {
#line 521
      __VERIFIER_assume(ldv_3_ret_default != 0);
      }
#line 528
      goto ldv_main_3;
    }
  } else {
    {
#line 533
    ldv_free((void *)ldv_3_resource_dev);
    }
#line 541
    return;
  }
#line 544
  return;
  ldv_call_3: 
  {
#line 550
  tmp___3 = ldv_undef_int();
  }
  {
#line 551
  if (tmp___3 == 1) {
#line 551
    goto case_1;
  } else {

  }
#line 563
  if (tmp___3 == 2) {
#line 563
    goto case_2;
  } else {

  }
#line 599
  if (tmp___3 == 3) {
#line 599
    goto case_3;
  } else {

  }
#line 619
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 560
  goto ldv_call_3;
  case_2: /* CIL Label */ 
  {
#line 566
  ldv_3_ret_default = ldv_pci_scenario_suspend_3_8(ldv_3_container_pci_driver->suspend,
                                                   ldv_3_resource_dev, ldv_3_resource_pm_message);
#line 568
  ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
  }
#line 572
  if ((unsigned long )ldv_3_container_pci_driver->suspend_late != (unsigned long )((int (*)(struct pci_dev * ,
                                                                                            pm_message_t  ))0)) {
    {
#line 574
    ldv_3_ret_default = ldv_pci_scenario_suspend_late_3_7(ldv_3_container_pci_driver->suspend_late,
                                                          ldv_3_resource_dev, ldv_3_resource_pm_message);
    }
  } else {

  }
  {
#line 577
  ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
  }
#line 581
  if ((unsigned long )ldv_3_container_pci_driver->resume_early != (unsigned long )((int (*)(struct pci_dev * ))0)) {
    {
#line 583
    ldv_pci_scenario_resume_early_3_6(ldv_3_container_pci_driver->resume_early, ldv_3_resource_dev);
    }
  } else {

  }
  {
#line 589
  ldv_pci_scenario_resume_3_5(ldv_3_container_pci_driver->resume, ldv_3_resource_dev);
  }
#line 596
  goto ldv_call_3;
  case_3: /* CIL Label */ ;
#line 601
  if ((unsigned long )ldv_3_container_pci_driver->shutdown != (unsigned long )((void (*)(struct pci_dev * ))0)) {
    {
#line 603
    ldv_pci_scenario_shutdown_3_3(ldv_3_container_pci_driver->shutdown, ldv_3_resource_dev);
    }
  } else {

  }
  {
#line 609
  ldv_pci_scenario_release_3_2(ldv_3_container_pci_driver->remove, ldv_3_resource_dev);
  }
#line 616
  goto ldv_main_3;
  switch_default: /* CIL Label */ 
  {
#line 619
  __VERIFIER_assume(0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 622
  return;
}
}
#line 627 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
int ldv_pci_scenario_probe_3_17(snd_pcm_hw_param_t (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 628
  tmp = snd_card_emu10k1_probe(arg1, (struct pci_device_id  const  *)arg2);
  }
#line 628
  return (tmp);
}
}
#line 632 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_pci_scenario_release_3_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 633
  snd_card_emu10k1_remove(arg1);
  }
#line 634
  return;
}
}
#line 637 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_pci_scenario_resume_3_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 638
  snd_emu10k1_resume(arg1);
  }
#line 639
  return;
}
}
#line 642 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_pci_scenario_resume_early_3_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 643
  (*arg0)(arg1);
  }
#line 644
  return;
}
}
#line 647 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
void ldv_pci_scenario_shutdown_3_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 648
  (*arg0)(arg1);
  }
#line 649
  return;
}
}
#line 652 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
int ldv_pci_scenario_suspend_3_8(int (*arg0)(struct pci_dev * , pm_message_t  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 653
  tmp = snd_emu10k1_suspend(arg1, arg2);
  }
#line 653
  return (tmp);
}
}
#line 657 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
int ldv_pci_scenario_suspend_late_3_7(int (*arg0)(struct pci_dev * , pm_message_t  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 658
  tmp = (*arg0)(arg1, arg2);
  }
#line 658
  return (tmp);
}
}
#line 662 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
int main(void) 
{ 


  {
  {
#line 665
  ldv_initialize();
#line 668
  ldv_main_9((void *)0);
#line 671
  ldv_check_final_state();
  }
#line 673
  return (0);
}
}
#line 783 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
static void *ldv_dev_get_drvdata_14(struct device  const  *dev ) 
{ 
  void *tmp ;

  {
  {
#line 786
  tmp = ldv_dev_get_drvdata(dev);
  }
#line 786
  return (tmp);
}
}
#line 790 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
static int ldv_dev_set_drvdata_15(struct device *dev , void *data ) 
{ 
  int tmp ;

  {
  {
#line 793
  tmp = ldv_dev_set_drvdata(dev, data);
  }
#line 793
  return (tmp);
}
}
#line 950 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
static int ldv___pci_register_driver_33(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                        char const   *ldv_func_arg3 ) 
{ 
  int tmp ;

  {
  {
#line 954
  tmp = ldv_emg___pci_register_driver(ldv_func_arg1, ldv_func_arg2, (char *)ldv_func_arg3);
  }
#line 954
  return (tmp);
}
}
#line 958 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1.c.aux"
static void ldv_pci_unregister_driver_34(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
  {
#line 962
  ldv_emg_pci_unregister_driver(ldv_func_arg1);
  }
#line 963
  return;
}
}
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/slab.h"
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 64
extern int strcmp(char const   * , char const   * ) ;
#line 30 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
static void ldv___ldv_spin_lock_33___0(spinlock_t *ldv_func_arg1 ) ;
#line 49
void ldv_spin_lock_emu_lock_of_snd_emu10k1(void) ;
#line 50
void ldv_spin_unlock_emu_lock_of_snd_emu10k1(void) ;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 93 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 272 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 274
  return (& lock->__annonCompField19.rlock);
}
}
#line 390
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 66
extern void vfree(void const   * ) ;
#line 310 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
#line 310
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 311
  return;
}
}
#line 310 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned int inl(int port ) 
{ 
  unsigned int value ;

  {
#line 310
  __asm__  volatile   ("inl %w1, %0": "=a" (value): "Nd" (port));
#line 310
  return (value);
}
}
#line 754 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 756
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 770 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ 
  int tmp ;

  {
  {
#line 772
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
#line 772
  return (tmp);
}
}
#line 774 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val ) 
{ 
  int tmp ;

  {
  {
#line 777
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 777
  return (tmp);
}
}
#line 916
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 918
extern void pci_release_regions(struct pci_dev * ) ;
#line 161 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 349
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 58 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 59
extern int dma_set_mask(struct device * , u64  ) ;
#line 83 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 85
  tmp = dma_supported(dev, mask);
  }
#line 85
  if (tmp == 0) {
#line 86
    return (-5);
  } else {

  }
#line 87
  dev->coherent_dma_mask = mask;
#line 88
  return (0);
}
}
#line 105 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 107
  tmp = dma_set_mask(& dev->dev, mask);
  }
#line 107
  return (tmp);
}
}
#line 110 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 112
  tmp = dma_set_coherent_mask(& dev->dev, mask);
  }
#line 112
  return (tmp);
}
}
#line 143 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/interrupt.h"
__inline static int ldv_request_irq_36(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 189
static void ldv_free_irq_35(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 2172 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/sched.h"
extern int wake_up_process(struct task_struct * ) ;
#line 8 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 36
extern int kthread_stop(struct task_struct * ) ;
#line 37
extern int kthread_should_stop(void) ;
#line 10 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 47
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 207 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
extern int snd_ecards_limit ;
#line 279
extern struct snd_card *snd_cards[32U] ;
#line 308
extern int snd_device_new(struct snd_card * , snd_device_type_t  , void * , struct snd_device_ops * ) ;
#line 122 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
extern void snd_dma_free_pages(struct snd_dma_buffer * ) ;
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/util_mem.h"
extern struct snd_util_memhdr *snd_util_memhdr_new(int  ) ;
#line 52
extern void snd_util_memhdr_free(struct snd_util_memhdr * ) ;
#line 1816 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
int snd_p16v_free(struct snd_emu10k1 *chip ) ;
#line 1824
irqreturn_t snd_emu10k1_interrupt(int irq , void *dev_id ) ;
#line 1826
void snd_emu10k1_voice_init(struct snd_emu10k1 *emu , int ch ) ;
#line 1827
int snd_emu10k1_init_efx(struct snd_emu10k1 *emu ) ;
#line 1828
void snd_emu10k1_free_efx(struct snd_emu10k1 *emu ) ;
#line 1829
int snd_emu10k1_fx8010_tram_setup(struct snd_emu10k1 *emu , u32 size ) ;
#line 1836
void snd_emu10k1_ptr20_write(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ,
                             unsigned int data ) ;
#line 1837
int snd_emu10k1_spi_write(struct snd_emu10k1 *emu , unsigned int data ) ;
#line 1838
int snd_emu10k1_i2c_write(struct snd_emu10k1 *emu , u32 reg , u32 value ) ;
#line 1839
int snd_emu1010_fpga_write(struct snd_emu10k1 *emu , u32 reg , u32 value ) ;
#line 1840
int snd_emu1010_fpga_read(struct snd_emu10k1 *emu , u32 reg , u32 *value ) ;
#line 1841
int snd_emu1010_fpga_link_dst_src_write(struct snd_emu10k1 *emu , u32 dst , u32 src ) ;
#line 1843
void snd_emu10k1_intr_enable(struct snd_emu10k1 *emu , unsigned int intrenb ) ;
#line 1853
void snd_emu10k1_wait(struct snd_emu10k1 *emu , unsigned int wait ) ;
#line 1863
int snd_emu10k1_efx_alloc_pm_buffer(struct snd_emu10k1 *emu ) ;
#line 1864
void snd_emu10k1_efx_free_pm_buffer(struct snd_emu10k1 *emu ) ;
#line 1867
int snd_p16v_alloc_pm_buffer(struct snd_emu10k1 *emu ) ;
#line 1868
void snd_p16v_free_pm_buffer(struct snd_emu10k1 *emu ) ;
#line 1891
int snd_emu10k1_proc_init(struct snd_emu10k1 *emu ) ;
#line 39 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 46
extern void release_firmware(struct firmware  const  * ) ;
#line 73 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
void snd_emu10k1_voice_init(struct snd_emu10k1 *emu , int ch ) 
{ 


  {
  {
#line 75
  snd_emu10k1_ptr_write(emu, 18U, (unsigned int )ch, 0U);
#line 76
  snd_emu10k1_ptr_write(emu, 24U, (unsigned int )ch, 0U);
#line 77
  snd_emu10k1_ptr_write(emu, 3U, (unsigned int )ch, 65535U);
#line 78
  snd_emu10k1_ptr_write(emu, 2U, (unsigned int )ch, 65535U);
#line 79
  snd_emu10k1_ptr_write(emu, 1U, (unsigned int )ch, 0U);
#line 80
  snd_emu10k1_ptr_write(emu, 0U, (unsigned int )ch, 0U);
#line 81
  snd_emu10k1_ptr_write(emu, 9U, (unsigned int )ch, 0U);
#line 83
  snd_emu10k1_ptr_write(emu, 6U, (unsigned int )ch, 0U);
#line 84
  snd_emu10k1_ptr_write(emu, 7U, (unsigned int )ch, 16U);
#line 85
  snd_emu10k1_ptr_write(emu, 8U, (unsigned int )ch, 0U);
#line 86
  snd_emu10k1_ptr_write(emu, 5U, (unsigned int )ch, 0U);
#line 87
  snd_emu10k1_ptr_write(emu, 4U, (unsigned int )ch, 0U);
#line 88
  snd_emu10k1_ptr_write(emu, 11U, (unsigned int )ch, 839909376U);
#line 90
  snd_emu10k1_ptr_write(emu, 21U, (unsigned int )ch, 0U);
#line 91
  snd_emu10k1_ptr_write(emu, 22U, (unsigned int )ch, 0U);
#line 92
  snd_emu10k1_ptr_write(emu, 25U, (unsigned int )ch, 65535U);
#line 93
  snd_emu10k1_ptr_write(emu, 26U, (unsigned int )ch, 0U);
#line 94
  snd_emu10k1_ptr_write(emu, 27U, (unsigned int )ch, 0U);
#line 95
  snd_emu10k1_ptr_write(emu, 28U, (unsigned int )ch, 24U);
#line 96
  snd_emu10k1_ptr_write(emu, 29U, (unsigned int )ch, 24U);
#line 97
  snd_emu10k1_ptr_write(emu, 30U, (unsigned int )ch, 0U);
#line 100
  snd_emu10k1_ptr_write(emu, 23U, (unsigned int )ch, 0U);
#line 101
  snd_emu10k1_ptr_write(emu, 19U, (unsigned int )ch, 0U);
#line 102
  snd_emu10k1_ptr_write(emu, 17U, (unsigned int )ch, 0U);
#line 103
  snd_emu10k1_ptr_write(emu, 16U, (unsigned int )ch, 0U);
#line 104
  snd_emu10k1_ptr_write(emu, 20U, (unsigned int )ch, 0U);
  }
#line 107
  if (emu->audigy != 0U) {
    {
#line 108
    snd_emu10k1_ptr_write(emu, 76U, (unsigned int )ch, 0U);
#line 109
    snd_emu10k1_ptr_write(emu, 77U, (unsigned int )ch, 0U);
#line 110
    snd_emu10k1_ptr_write(emu, 78U, (unsigned int )ch, 0U);
#line 111
    snd_emu10k1_ptr_write(emu, 79U, (unsigned int )ch, 0U);
#line 112
    snd_emu10k1_ptr_write(emu, 126U, (unsigned int )ch, 50462976U);
#line 113
    snd_emu10k1_ptr_write(emu, 124U, (unsigned int )ch, 1061109567U);
#line 114
    snd_emu10k1_ptr_write(emu, 125U, (unsigned int )ch, 0U);
    }
  } else {

  }
#line 116
  return;
}
}
#line 118 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static unsigned int spi_dac_init[21U]  = 
#line 118
  {      255U,      767U,      1024U,      1312U, 
        1536U,      2303U,      2815U,      3327U, 
        3839U,      4351U,      4608U,      5120U, 
        5248U,      6144U,      6911U,      7423U, 
        7680U,      1328U,      1538U,      1570U, 
        5120U};
#line 142 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static unsigned int i2c_adc_init[13U][2U]  = 
#line 142
  { {        23U,        0U}, 
   {        7U,        0U}, 
   {        11U,        34U}, 
   {        12U,        34U}, 
   {        13U,        8U}, 
   {        14U,        207U}, 
   {        15U,        207U}, 
   {        16U,        123U}, 
   {        17U,        0U}, 
   {        18U,        50U}, 
   {        19U,        0U}, 
   {        20U,        166U}, 
   {        21U,        4U}};
#line 158 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu10k1_init(struct snd_emu10k1 *emu , int enable_ir___0 , int resume ) 
{ 
  unsigned int silent_page ;
  int ch ;
  u32 tmp ;
  unsigned int tmp___0 ;
  int size ;
  int n ;
  int size___0 ;
  int n___0 ;
  unsigned int reg ;
  unsigned int tmp___1 ;
  unsigned int reg___0 ;
  unsigned int tmp___2 ;
  unsigned int reg___1 ;
  unsigned int tmp___3 ;

  {
  {
#line 165
  outl(14U, (int )((unsigned int )emu->port + 20U));
#line 169
  snd_emu10k1_ptr_write(emu, 73U, 0U, 0U);
#line 170
  snd_emu10k1_ptr_write(emu, 69U, 0U, 0U);
#line 171
  snd_emu10k1_ptr_write(emu, 75U, 0U, 0U);
#line 172
  snd_emu10k1_ptr_write(emu, 71U, 0U, 0U);
#line 173
  snd_emu10k1_ptr_write(emu, 74U, 0U, 0U);
#line 174
  snd_emu10k1_ptr_write(emu, 70U, 0U, 0U);
#line 177
  outl(0U, (int )((unsigned int )emu->port + 12U));
#line 178
  snd_emu10k1_ptr_write(emu, 88U, 0U, 0U);
#line 179
  snd_emu10k1_ptr_write(emu, 89U, 0U, 0U);
#line 180
  snd_emu10k1_ptr_write(emu, 92U, 0U, 0U);
#line 181
  snd_emu10k1_ptr_write(emu, 93U, 0U, 0U);
  }
#line 183
  if (emu->audigy != 0U) {
    {
#line 185
    snd_emu10k1_ptr_write(emu, 94U, 0U, 3840U);
#line 187
    snd_emu10k1_ptr_write(emu, 95U, 0U, 3U);
    }
  } else {

  }
#line 192
  ch = 0;
#line 192
  goto ldv_31376;
  ldv_31375: 
  {
#line 193
  snd_emu10k1_voice_init(emu, ch);
#line 192
  ch = ch + 1;
  }
  ldv_31376: ;
#line 192
  if (ch <= 63) {
#line 194
    goto ldv_31375;
  } else {

  }
  {
#line 195
  snd_emu10k1_ptr_write(emu, 84U, 0U, emu->spdif_bits[0]);
#line 196
  snd_emu10k1_ptr_write(emu, 85U, 0U, emu->spdif_bits[1]);
#line 197
  snd_emu10k1_ptr_write(emu, 86U, 0U, emu->spdif_bits[2]);
  }
#line 199
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 202
    tmp = snd_emu10k1_ptr_read(emu, 118U, 0U);
#line 203
    tmp = tmp & 4294963711U;
#line 204
    tmp = tmp | 1024U;
#line 205
    snd_emu10k1_ptr_write(emu, 118U, 0U, tmp);
#line 208
    snd_emu10k1_ptr20_write(emu, 96U, 0U, 20U);
#line 211
    snd_emu10k1_ptr20_write(emu, 110U, 0U, 4294967295U);
#line 214
    outl(513U, (int )((unsigned int )emu->port + 52U));
#line 216
    snd_emu10k1_ptr20_write(emu, 22U, 0U, 30948U);
    }
  } else {

  }
#line 218
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0108_chip) != 0U) {
    {
#line 220
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 220, "<6>Audigy2 value: Special config.\n");
#line 222
    tmp = snd_emu10k1_ptr_read(emu, 118U, 0U);
#line 223
    tmp = tmp & 4294963711U;
#line 224
    tmp = tmp | 1024U;
#line 225
    snd_emu10k1_ptr_write(emu, 118U, 0U, tmp);
#line 228
    outl(6291456U, (int )((unsigned int )emu->port + 32U));
#line 229
    outl(20U, (int )((unsigned int )emu->port + 36U));
#line 232
    outl(8060928U, (int )((unsigned int )emu->port + 32U));
#line 233
    outl(4278190080U, (int )((unsigned int )emu->port + 36U));
#line 239
    outl(7995392U, (int )((unsigned int )emu->port + 32U));
#line 240
    outl(4278190080U, (int )((unsigned int )emu->port + 36U));
#line 241
    tmp___0 = inl((int )((unsigned int )emu->port + 24U));
#line 241
    tmp = tmp___0 & 4294967287U;
#line 242
    outl(tmp, (int )((unsigned int )emu->port + 24U));
    }
  } else {

  }
#line 244
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->spi_dac) != 0U) {
#line 247
    size = 21;
#line 248
    n = 0;
#line 248
    goto ldv_31383;
    ldv_31382: 
    {
#line 249
    snd_emu10k1_spi_write(emu, spi_dac_init[n]);
#line 248
    n = n + 1;
    }
    ldv_31383: ;
#line 248
    if (n < size) {
#line 250
      goto ldv_31382;
    } else {

    }
    {
#line 251
    snd_emu10k1_ptr20_write(emu, 96U, 0U, 16U);
#line 262
    outl(118U, (int )((unsigned int )emu->port + 24U));
    }
  } else {

  }
#line 264
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {
    {
#line 267
    snd_emu10k1_ptr20_write(emu, 147U, 0U, 538976351U);
#line 268
    tmp = inl((int )((unsigned int )emu->port + 24U));
#line 269
    outl(tmp | 4U, (int )((unsigned int )emu->port + 24U));
#line 270
    tmp = inl((int )((unsigned int )emu->port + 24U));
#line 271
    size___0 = 13;
#line 272
    n___0 = 0;
    }
#line 272
    goto ldv_31390;
    ldv_31389: 
    {
#line 273
    snd_emu10k1_i2c_write(emu, i2c_adc_init[n___0][0], i2c_adc_init[n___0][1]);
#line 272
    n___0 = n___0 + 1;
    }
    ldv_31390: ;
#line 272
    if (n___0 < size___0) {
#line 274
      goto ldv_31389;
    } else {

    }
#line 274
    n___0 = 0;
#line 274
    goto ldv_31393;
    ldv_31392: 
#line 275
    emu->i2c_capture_volume[n___0][0] = 207U;
#line 276
    emu->i2c_capture_volume[n___0][1] = 207U;
#line 274
    n___0 = n___0 + 1;
    ldv_31393: ;
#line 274
    if (n___0 <= 3) {
#line 276
      goto ldv_31392;
    } else {

    }

  } else {

  }
  {
#line 281
  snd_emu10k1_ptr_write(emu, 64U, 0U, (unsigned int )emu->ptb_pages.addr);
#line 282
  snd_emu10k1_ptr_write(emu, 65U, 0U, 0U);
#line 283
  snd_emu10k1_ptr_write(emu, 68U, 0U, 4U);
#line 285
  silent_page = ((unsigned int )emu->silent_page.addr << 1U) | 8191U;
#line 286
  ch = 0;
  }
#line 286
  goto ldv_31396;
  ldv_31395: 
  {
#line 287
  snd_emu10k1_ptr_write(emu, 12U, (unsigned int )ch, silent_page);
#line 288
  snd_emu10k1_ptr_write(emu, 13U, (unsigned int )ch, silent_page);
#line 286
  ch = ch + 1;
  }
  ldv_31396: ;
#line 286
  if (ch <= 63) {
#line 288
    goto ldv_31395;
  } else {

  }

#line 291
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 292
    outl(40961U, (int )((unsigned int )emu->port + 20U));
    }
  } else
#line 302
  if (emu->audigy != 0U) {
#line 303
    if (emu->revision == 4U) {
      {
#line 304
      outl(625U, (int )((unsigned int )emu->port + 20U));
      }
    } else {
      {
#line 309
      outl(528U, (int )((unsigned int )emu->port + 20U));
      }
    }
  } else
#line 312
  if (((unsigned int )emu->model == 32U || (unsigned int )emu->model == 50176U) || ((unsigned int )emu->model == 33U && emu->revision <= 5U)) {
    {
#line 315
    outl(20U, (int )((unsigned int )emu->port + 20U));
    }
  } else {
    {
#line 318
    outl(532U, (int )((unsigned int )emu->port + 20U));
    }
  }
#line 320
  if (enable_ir___0 != 0) {
#line 321
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {

    } else
#line 323
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {

    } else
#line 325
    if (emu->audigy != 0U) {
      {
#line 326
      tmp___1 = inl((int )((unsigned int )emu->port + 24U));
#line 326
      reg = tmp___1;
#line 327
      outl(reg | 1U, (int )((unsigned int )emu->port + 24U));
#line 328
      __const_udelay(2147500UL);
#line 329
      outl(reg | 3U, (int )((unsigned int )emu->port + 24U));
#line 330
      __const_udelay(429500UL);
#line 331
      outl(reg, (int )((unsigned int )emu->port + 24U));
      }
    } else {
      {
#line 333
      tmp___2 = inl((int )((unsigned int )emu->port + 20U));
#line 333
      reg___0 = tmp___2;
#line 334
      outl(reg___0 | 1024U, (int )((unsigned int )emu->port + 20U));
#line 335
      __const_udelay(2147500UL);
#line 336
      outl(reg___0 | 3072U, (int )((unsigned int )emu->port + 20U));
#line 337
      __const_udelay(429500UL);
#line 338
      outl(reg___0, (int )((unsigned int )emu->port + 20U));
      }
    }
  } else {

  }
#line 342
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {

  } else
#line 344
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {

  } else
#line 346
  if (emu->audigy != 0U) {
    {
#line 347
    tmp___3 = inl((int )((unsigned int )emu->port + 24U));
#line 347
    reg___1 = tmp___3;
#line 348
    outl(reg___1 | 68U, (int )((unsigned int )emu->port + 24U));
    }
  } else {

  }
#line 351
  return (0);
}
}
#line 354 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static void snd_emu10k1_audio_enable(struct snd_emu10k1 *emu ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 359
  tmp = inl((int )((unsigned int )emu->port + 20U));
#line 359
  outl(tmp | 1U, (int )((unsigned int )emu->port + 20U));
  }
#line 362
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {

  } else
#line 364
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {

  } else
#line 366
  if (emu->audigy != 0U) {
    {
#line 367
    tmp___0 = inl((int )((unsigned int )emu->port + 24U));
#line 367
    outl(tmp___0 & 4294967227U, (int )((unsigned int )emu->port + 24U));
    }
#line 369
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
      {
#line 373
      tmp___1 = inl((int )((unsigned int )emu->port + 24U));
#line 373
      outl(tmp___1 | 64U, (int )((unsigned int )emu->port + 24U));
      }
    } else
#line 374
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0108_chip) != 0U) {
      {
#line 376
      tmp___2 = inl((int )((unsigned int )emu->port + 24U));
#line 376
      outl(tmp___2 | 96U, (int )((unsigned int )emu->port + 24U));
      }
    } else {
      {
#line 379
      tmp___3 = inl((int )((unsigned int )emu->port + 24U));
#line 379
      outl(tmp___3 | 128U, (int )((unsigned int )emu->port + 24U));
      }
    }
  } else {

  }
  {
#line 401
  snd_emu10k1_intr_enable(emu, 2048U);
  }
#line 402
  return;
}
}
#line 404 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
int snd_emu10k1_done(struct snd_emu10k1 *emu ) 
{ 
  int ch ;

  {
  {
#line 408
  outl(0U, (int )((unsigned int )emu->port + 12U));
#line 413
  ch = 0;
  }
#line 413
  goto ldv_31409;
  ldv_31408: 
  {
#line 414
  snd_emu10k1_ptr_write(emu, 18U, (unsigned int )ch, 0U);
#line 413
  ch = ch + 1;
  }
  ldv_31409: ;
#line 413
  if (ch <= 63) {
#line 415
    goto ldv_31408;
  } else {

  }
#line 415
  ch = 0;
#line 415
  goto ldv_31412;
  ldv_31411: 
  {
#line 416
  snd_emu10k1_ptr_write(emu, 3U, (unsigned int )ch, 0U);
#line 417
  snd_emu10k1_ptr_write(emu, 2U, (unsigned int )ch, 0U);
#line 418
  snd_emu10k1_ptr_write(emu, 1U, (unsigned int )ch, 0U);
#line 419
  snd_emu10k1_ptr_write(emu, 0U, (unsigned int )ch, 0U);
#line 415
  ch = ch + 1;
  }
  ldv_31412: ;
#line 415
  if (ch <= 63) {
#line 417
    goto ldv_31411;
  } else {

  }
  {
#line 423
  snd_emu10k1_ptr_write(emu, 73U, 0U, 0U);
#line 424
  snd_emu10k1_ptr_write(emu, 69U, 0U, 0U);
#line 425
  snd_emu10k1_ptr_write(emu, 75U, 0U, 0U);
#line 426
  snd_emu10k1_ptr_write(emu, 71U, 0U, 0U);
#line 427
  snd_emu10k1_ptr_write(emu, 67U, 0U, 0U);
#line 428
  snd_emu10k1_ptr_write(emu, 74U, 0U, 0U);
#line 429
  snd_emu10k1_ptr_write(emu, 70U, 0U, 0U);
#line 430
  snd_emu10k1_ptr_write(emu, 68U, 0U, 0U);
#line 431
  snd_emu10k1_ptr_write(emu, 65U, 0U, 0U);
  }
#line 432
  if (emu->audigy != 0U) {
    {
#line 433
    snd_emu10k1_ptr_write(emu, 83U, 0U, 131072U);
    }
  } else {
    {
#line 435
    snd_emu10k1_ptr_write(emu, 82U, 0U, 32768U);
    }
  }
  {
#line 438
  snd_emu10k1_ptr_write(emu, 88U, 0U, 0U);
#line 439
  snd_emu10k1_ptr_write(emu, 89U, 0U, 0U);
#line 440
  snd_emu10k1_ptr_write(emu, 92U, 0U, 0U);
#line 441
  snd_emu10k1_ptr_write(emu, 93U, 0U, 0U);
#line 444
  outl(14U, (int )((unsigned int )emu->port + 20U));
#line 445
  snd_emu10k1_ptr_write(emu, 64U, 0U, 0U);
  }
#line 447
  return (0);
}
}
#line 527 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static void snd_emu10k1_ecard_write(struct snd_emu10k1 *emu , unsigned int value ) 
{ 
  unsigned short count ;
  unsigned int data ;
  unsigned long hc_port ;
  unsigned int hc_value ;
  unsigned int tmp ;

  {
  {
#line 534
  hc_port = emu->port + 20UL;
#line 535
  tmp = inl((int )hc_port);
#line 535
  hc_value = tmp & 4294960127U;
#line 536
  outl(hc_value, (int )hc_port);
#line 538
  count = 0U;
  }
#line 538
  goto ldv_31423;
  ldv_31422: 
  {
#line 541
  data = (int )value & 1 ? 1024U : 0U;
#line 542
  value = value >> 1;
#line 544
  outl(hc_value | data, (int )hc_port);
#line 547
  outl((hc_value | data) | 2048U, (int )hc_port);
#line 548
  outl(hc_value | data, (int )hc_port);
#line 538
  count = (unsigned short )((int )count + 1);
  }
  ldv_31423: ;
#line 538
  if ((unsigned int )count <= 19U) {
#line 540
    goto ldv_31422;
  } else {

  }
  {
#line 552
  outl(hc_value | 4096U, (int )hc_port);
#line 553
  outl(hc_value, (int )hc_port);
  }
#line 554
  return;
}
}
#line 565 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static void snd_emu10k1_ecard_setadcgain(struct snd_emu10k1 *emu , unsigned short gain ) 
{ 
  unsigned int bit ;
  unsigned int value ;

  {
  {
#line 571
  snd_emu10k1_ecard_write(emu, emu->ecard_ctrl & 4294967231U);
#line 574
  snd_emu10k1_ecard_write(emu, emu->ecard_ctrl & 4294967231U);
#line 576
  bit = 32768U;
  }
#line 576
  goto ldv_31432;
  ldv_31431: 
#line 579
  value = emu->ecard_ctrl & 4294966975U;
#line 581
  if (((unsigned int )gain & bit) != 0U) {
#line 582
    value = value | 256U;
  } else {

  }
  {
#line 585
  snd_emu10k1_ecard_write(emu, value);
#line 586
  snd_emu10k1_ecard_write(emu, value | 128U);
#line 587
  snd_emu10k1_ecard_write(emu, value);
#line 576
  bit = bit >> 1;
  }
  ldv_31432: ;
#line 576
  if (bit != 0U) {
#line 578
    goto ldv_31431;
  } else {

  }
  {
#line 590
  snd_emu10k1_ecard_write(emu, emu->ecard_ctrl);
  }
#line 591
  return;
}
}
#line 593 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu10k1_ecard_init(struct snd_emu10k1 *emu ) 
{ 
  unsigned int hc_value ;

  {
  {
#line 598
  emu->ecard_ctrl = 535104U;
#line 604
  hc_value = inl((int )((unsigned int )emu->port + 20U));
#line 605
  outl(hc_value | 65537U, (int )((unsigned int )emu->port + 20U));
#line 606
  inl((int )((unsigned int )emu->port + 20U));
#line 609
  snd_emu10k1_ecard_write(emu, 17472U);
#line 612
  snd_emu10k1_ecard_write(emu, 20544U);
#line 617
  snd_emu10k1_wait(emu, 48000U);
#line 622
  snd_emu10k1_ecard_write(emu, 17472U);
#line 625
  snd_emu10k1_ecard_write(emu, emu->ecard_ctrl);
#line 628
  snd_emu10k1_ecard_setadcgain(emu, 50372);
  }
#line 630
  return (0);
}
}
#line 633 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu10k1_cardbus_init(struct snd_emu10k1 *emu ) 
{ 
  unsigned long special_port ;
  unsigned int value ;

  {
  {
#line 641
  special_port = emu->port + 56UL;
#line 642
  value = inl((int )special_port);
#line 643
  outl(13631488U, (int )special_port);
#line 644
  value = inl((int )special_port);
#line 645
  outl(13631489U, (int )special_port);
#line 646
  value = inl((int )special_port);
#line 647
  outl(13631583U, (int )special_port);
#line 648
  value = inl((int )special_port);
#line 649
  outl(13631615U, (int )special_port);
#line 650
  value = inl((int )special_port);
#line 651
  outl(9437311U, (int )special_port);
#line 652
  value = inl((int )special_port);
#line 654
  snd_emu10k1_ptr20_write(emu, 113U, 0U, 4278124286U);
#line 656
  msleep(200U);
  }
#line 657
  return (0);
}
}
#line 660 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu1010_load_firmware(struct snd_emu10k1 *emu , char const   *filename ) 
{ 
  int err ;
  int n ;
  int i ;
  int reg ;
  int value ;
  unsigned int write_post ;
  unsigned long flags ;
  struct firmware  const  *fw_entry ;

  {
  {
#line 670
  err = request_firmware(& fw_entry, filename, & (emu->pci)->dev);
  }
#line 671
  if (err != 0) {
    {
#line 672
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 672, "<3>firmware: %s not found. Err = %d\n",
                 filename, err);
    }
#line 673
    return (err);
  } else {

  }
  {
#line 675
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 675, "<6>firmware size = 0x%zx\n",
               fw_entry->size);
#line 683
  ldv___ldv_spin_lock_33___0(& emu->emu_lock);
#line 684
  outl(0U, (int )((unsigned int )emu->port + 24U));
#line 685
  write_post = inl((int )((unsigned int )emu->port + 24U));
#line 686
  __const_udelay(429500UL);
#line 687
  outl(128U, (int )((unsigned int )emu->port + 24U));
#line 688
  write_post = inl((int )((unsigned int )emu->port + 24U));
#line 689
  __const_udelay(429500UL);
#line 690
  n = 0;
  }
#line 690
  goto ldv_31459;
  ldv_31458: 
#line 691
  value = (int )*(fw_entry->data + (unsigned long )n);
#line 692
  i = 0;
#line 692
  goto ldv_31456;
  ldv_31455: 
#line 693
  reg = 128;
#line 694
  if (value & 1) {
#line 695
    reg = reg | 32;
  } else {

  }
  {
#line 696
  value = value >> 1;
#line 697
  outl((unsigned int )reg, (int )((unsigned int )emu->port + 24U));
#line 698
  write_post = inl((int )((unsigned int )emu->port + 24U));
#line 699
  outl((unsigned int )(reg | 64), (int )((unsigned int )emu->port + 24U));
#line 700
  write_post = inl((int )((unsigned int )emu->port + 24U));
#line 692
  i = i + 1;
  }
  ldv_31456: ;
#line 692
  if (i <= 7) {
#line 694
    goto ldv_31455;
  } else {

  }
#line 690
  n = n + 1;
  ldv_31459: ;
#line 690
  if ((unsigned long )n < (unsigned long )fw_entry->size) {
#line 692
    goto ldv_31458;
  } else {

  }
  {
#line 704
  outl(16U, (int )((unsigned int )emu->port + 24U));
#line 705
  write_post = inl((int )((unsigned int )emu->port + 24U));
#line 706
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
#line 708
  release_firmware(fw_entry);
  }
#line 709
  return (0);
}
}
#line 712 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int emu1010_firmware_thread(void *data ) 
{ 
  struct snd_emu10k1 *emu ;
  u32 tmp ;
  u32 tmp2 ;
  u32 reg ;
  int err ;
  int tmp___0 ;

  {
#line 714
  emu = (struct snd_emu10k1 *)data;
  ldv_31471: 
  {
#line 720
  msleep_interruptible(1000U);
#line 721
  tmp___0 = kthread_should_stop();
  }
#line 721
  if (tmp___0 != 0) {
#line 722
    goto ldv_31469;
  } else {

  }
  {
#line 723
  snd_emu1010_fpga_read(emu, 32U, & tmp);
#line 724
  snd_emu1010_fpga_read(emu, 33U, & reg);
  }
#line 725
  if ((reg & 8U) != 0U) {
    {
#line 728
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 728, "<6>emu1010: Loading Audio Dock Firmware\n");
#line 729
    snd_emu1010_fpga_write(emu, 8U, 1U);
    }
#line 730
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 1U) {
      {
#line 732
      err = snd_emu1010_load_firmware(emu, "emu/audio_dock.fw");
      }
#line 733
      if (err != 0) {
#line 734
        goto ldv_31470;
      } else {

      }
    } else
#line 735
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 2U) {
      {
#line 737
      err = snd_emu1010_load_firmware(emu, "emu/micro_dock.fw");
      }
#line 738
      if (err != 0) {
#line 739
        goto ldv_31470;
      } else {

      }
    } else
#line 740
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U) {
      {
#line 742
      err = snd_emu1010_load_firmware(emu, "emu/micro_dock.fw");
      }
#line 743
      if (err != 0) {
#line 744
        goto ldv_31470;
      } else {

      }
    } else {

    }
    {
#line 747
    snd_emu1010_fpga_write(emu, 8U, 0U);
#line 748
    snd_emu1010_fpga_read(emu, 32U, & reg);
#line 749
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 749, "<6>emu1010: EMU_HANA+DOCK_IRQ_STATUS = 0x%x\n",
                 reg);
#line 751
    snd_emu1010_fpga_read(emu, 34U, & reg);
#line 752
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 752, "<6>emu1010: EMU_HANA+DOCK_ID = 0x%x\n",
                 reg);
    }
#line 753
    if ((reg & 31U) != 21U) {
      {
#line 755
      __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 755, "<6>emu1010: Loading Audio Dock Firmware file failed, reg = 0x%x\n",
                   reg);
      }
#line 756
      goto ldv_31470;
    } else {

    }
    {
#line 758
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 758, "<6>emu1010: Audio Dock Firmware loaded\n");
#line 759
    snd_emu1010_fpga_read(emu, 37U, & tmp);
#line 760
    snd_emu1010_fpga_read(emu, 38U, & tmp2);
#line 761
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 762, "<6>Audio Dock ver: %u.%u\n",
                 tmp, tmp2);
#line 765
    msleep(10U);
#line 767
    snd_emu1010_fpga_write(emu, 7U, 1U);
    }
  } else {

  }
  ldv_31470: ;
#line 769
  goto ldv_31471;
  ldv_31469: 
  {
#line 770
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 770, "<6>emu1010: firmware thread stopping\n");
  }
#line 771
  return (0);
}
}
#line 805 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu10k1_emu1010_init(struct snd_emu10k1 *emu ) 
{ 
  unsigned int i ;
  u32 tmp ;
  u32 tmp2 ;
  u32 reg ;
  int err ;
  char const   *filename ;

  {
  {
#line 810
  filename = (char const   *)0;
#line 812
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 812, "<6>emu1010: Special config.\n");
#line 817
  outl(368652U, (int )((unsigned int )emu->port + 20U));
#line 822
  outl(368644U, (int )((unsigned int )emu->port + 20U));
#line 826
  outl(368640U, (int )((unsigned int )emu->port + 20U));
#line 830
  outl(368640U, (int )((unsigned int )emu->port + 20U));
#line 833
  snd_emu1010_fpga_write(emu, 4U, 0U);
#line 836
  snd_emu1010_fpga_read(emu, 34U, & reg);
#line 837
  __snd_printk(2U, "sound/pci/emu10k1/emu10k1_main.c", 837, "reg1 = 0x%x\n", reg);
  }
#line 838
  if ((reg & 63U) == 21U) {
    {
#line 842
    snd_emu1010_fpga_write(emu, 8U, 2U);
    }
  } else {

  }
  {
#line 844
  snd_emu1010_fpga_read(emu, 34U, & reg);
#line 845
  __snd_printk(2U, "sound/pci/emu10k1/emu10k1_main.c", 845, "reg2 = 0x%x\n", reg);
  }
#line 846
  if ((reg & 63U) == 21U) {
    {
#line 848
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 848, "<6>emu1010: FPGA failed to return to programming mode\n");
    }
#line 849
    return (-19);
  } else {

  }
  {
#line 851
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 851, "<6>emu1010: EMU_HANA_ID = 0x%x\n",
               reg);
  }
  {
#line 853
  if ((int )(emu->card_capabilities)->emu_model == 1) {
#line 853
    goto case_1;
  } else {

  }
#line 856
  if ((int )(emu->card_capabilities)->emu_model == 2) {
#line 856
    goto case_2;
  } else {

  }
#line 859
  if ((int )(emu->card_capabilities)->emu_model == 3) {
#line 859
    goto case_3;
  } else {

  }
#line 862
  if ((int )(emu->card_capabilities)->emu_model == 4) {
#line 862
    goto case_4;
  } else {

  }
#line 865
  goto switch_default;
  case_1: /* CIL Label */ 
#line 854
  filename = "emu/hana.fw";
#line 855
  goto ldv_31482;
  case_2: /* CIL Label */ 
#line 857
  filename = "emu/emu1010b.fw";
#line 858
  goto ldv_31482;
  case_3: /* CIL Label */ 
#line 860
  filename = "emu/emu1010_notebook.fw";
#line 861
  goto ldv_31482;
  case_4: /* CIL Label */ 
#line 863
  filename = "emu/emu0404.fw";
#line 864
  goto ldv_31482;
  switch_default: /* CIL Label */ 
#line 866
  filename = (char const   *)0;
#line 867
  return (-19);
  switch_break: /* CIL Label */ ;
  }
  ldv_31482: 
  {
#line 870
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 870, "<6>emu1010: filename %s testing\n",
               filename);
#line 871
  err = snd_emu1010_load_firmware(emu, filename);
  }
#line 872
  if (err != 0) {
    {
#line 873
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 875, "<6>emu1010: Loading Firmware file %s failed\n",
                 filename);
    }
#line 876
    return (err);
  } else {

  }
  {
#line 880
  snd_emu1010_fpga_read(emu, 34U, & reg);
  }
#line 881
  if ((reg & 63U) != 21U) {
    {
#line 883
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 883, "<6>emu1010: Loading Hana Firmware file failed, reg = 0x%x\n",
                 reg);
    }
#line 884
    return (-19);
  } else {

  }
  {
#line 887
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 887, "<6>emu1010: Hana Firmware loaded\n");
#line 888
  snd_emu1010_fpga_read(emu, 35U, & tmp);
#line 889
  snd_emu1010_fpga_read(emu, 36U, & tmp2);
#line 890
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 890, "<6>emu1010: Hana version: %u.%u\n",
               tmp, tmp2);
#line 892
  snd_emu1010_fpga_write(emu, 4U, 1U);
#line 894
  snd_emu1010_fpga_read(emu, 33U, & reg);
#line 895
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 895, "<6>emu1010: Card options = 0x%x\n",
               reg);
#line 896
  snd_emu1010_fpga_read(emu, 33U, & reg);
#line 897
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 897, "<6>emu1010: Card options = 0x%x\n",
               reg);
#line 898
  snd_emu1010_fpga_read(emu, 11U, & tmp);
#line 903
  emu->emu1010.optical_in = 1U;
#line 904
  emu->emu1010.optical_out = 1U;
#line 905
  tmp = 0U;
#line 906
  tmp = (u32 )((emu->emu1010.optical_in != 0U) | (emu->emu1010.optical_out != 0U ? 2 : 0));
#line 908
  snd_emu1010_fpga_write(emu, 11U, tmp);
#line 909
  snd_emu1010_fpga_read(emu, 16U, & tmp);
#line 911
  snd_emu1010_fpga_write(emu, 16U, 0U);
#line 912
  emu->emu1010.adc_pads = 0U;
#line 913
  snd_emu1010_fpga_read(emu, 17U, & tmp);
#line 915
  snd_emu1010_fpga_write(emu, 17U, 48U);
#line 916
  snd_emu1010_fpga_write(emu, 14U, 18U);
#line 917
  snd_emu1010_fpga_read(emu, 19U, & tmp);
#line 919
  snd_emu1010_fpga_write(emu, 19U, 15U);
#line 920
  emu->emu1010.dac_pads = 15U;
#line 921
  snd_emu1010_fpga_read(emu, 17U, & tmp);
#line 922
  snd_emu1010_fpga_write(emu, 17U, 48U);
#line 923
  snd_emu1010_fpga_read(emu, 10U, & tmp);
#line 925
  snd_emu1010_fpga_write(emu, 10U, 16U);
#line 927
  snd_emu1010_fpga_write(emu, 12U, 25U);
#line 929
  snd_emu1010_fpga_write(emu, 18U, 12U);
#line 933
  snd_emu1010_fpga_write(emu, 9U, 0U);
#line 935
  snd_emu1010_fpga_read(emu, 33U, & reg);
#line 936
  __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 936, "<6>emu1010: Card options3 = 0x%x\n",
               reg);
#line 938
  snd_emu1010_fpga_write(emu, 6U, 0U);
#line 940
  snd_emu1010_fpga_write(emu, 5U, 0U);
#line 943
  snd_emu1010_fpga_write(emu, 14U, 18U);
#line 977
  snd_emu1010_fpga_link_dst_src_write(emu, 15U, 256U);
#line 979
  snd_emu1010_fpga_link_dst_src_write(emu, 0U, 260U);
#line 981
  snd_emu1010_fpga_link_dst_src_write(emu, 1U, 514U);
#line 983
  snd_emu1010_fpga_link_dst_src_write(emu, 2U, 514U);
#line 985
  snd_emu1010_fpga_link_dst_src_write(emu, 3U, 264U);
#line 987
  snd_emu1010_fpga_link_dst_src_write(emu, 4U, 268U);
#line 989
  snd_emu1010_fpga_link_dst_src_write(emu, 5U, 272U);
#line 991
  snd_emu1010_fpga_link_dst_src_write(emu, 6U, 276U);
#line 998
  snd_emu1010_fpga_link_dst_src_write(emu, 7U, 256U);
#line 1000
  snd_emu1010_fpga_link_dst_src_write(emu, 8U, 260U);
#line 1002
  snd_emu1010_fpga_link_dst_src_write(emu, 9U, 514U);
#line 1004
  snd_emu1010_fpga_link_dst_src_write(emu, 10U, 514U);
#line 1006
  snd_emu1010_fpga_link_dst_src_write(emu, 11U, 264U);
#line 1008
  snd_emu1010_fpga_link_dst_src_write(emu, 12U, 268U);
#line 1010
  snd_emu1010_fpga_link_dst_src_write(emu, 13U, 272U);
#line 1012
  snd_emu1010_fpga_link_dst_src_write(emu, 14U, 276U);
#line 1042
  i = 0U;
  }
#line 1042
  goto ldv_31488;
  ldv_31487: 
  {
#line 1044
  snd_emu1010_fpga_link_dst_src_write(emu, i + 256U, 0U);
#line 1042
  i = i + 1U;
  }
  ldv_31488: ;
#line 1042
  if (i <= 31U) {
#line 1044
    goto ldv_31487;
  } else {

  }
#line 1046
  i = 0U;
#line 1046
  goto ldv_31491;
  ldv_31490: 
  {
#line 1048
  snd_emu1010_fpga_link_dst_src_write(emu, i + 512U, 0U);
#line 1046
  i = i + 1U;
  }
  ldv_31491: ;
#line 1046
  if (i <= 3U) {
#line 1048
    goto ldv_31490;
  } else {

  }
#line 1050
  i = 0U;
#line 1050
  goto ldv_31494;
  ldv_31493: 
  {
#line 1052
  snd_emu1010_fpga_link_dst_src_write(emu, i + 768U, 0U);
#line 1050
  i = i + 1U;
  }
  ldv_31494: ;
#line 1050
  if (i <= 6U) {
#line 1052
    goto ldv_31493;
  } else {

  }
#line 1054
  i = 0U;
#line 1054
  goto ldv_31497;
  ldv_31496: 
  {
#line 1056
  snd_emu1010_fpga_link_dst_src_write(emu, i + 1024U, 0U);
#line 1054
  i = i + 1U;
  }
  ldv_31497: ;
#line 1054
  if (i <= 6U) {
#line 1056
    goto ldv_31496;
  } else {

  }
  {
#line 1058
  snd_emu1010_fpga_link_dst_src_write(emu, 1280U, 264U);
#line 1060
  snd_emu1010_fpga_link_dst_src_write(emu, 1281U, 268U);
#line 1062
  snd_emu1010_fpga_link_dst_src_write(emu, 1536U, 272U);
#line 1064
  snd_emu1010_fpga_link_dst_src_write(emu, 1537U, 276U);
#line 1066
  snd_emu1010_fpga_link_dst_src_write(emu, 1792U, 280U);
#line 1068
  snd_emu1010_fpga_link_dst_src_write(emu, 1793U, 284U);
#line 1070
  snd_emu1010_fpga_write(emu, 7U, 1U);
#line 1072
  snd_emu1010_fpga_read(emu, 33U, & tmp);
#line 1078
  outl(40960U, (int )((unsigned int )emu->port + 20U));
#line 1083
  outl(40961U, (int )((unsigned int )emu->port + 20U));
#line 1087
  snd_emu1010_fpga_read(emu, 33U, & tmp);
#line 1088
  snd_emu1010_fpga_write(emu, 12U, 25U);
#line 1089
  snd_emu1010_fpga_write(emu, 18U, 12U);
#line 1090
  snd_emu1010_fpga_write(emu, 12U, 25U);
#line 1091
  snd_emu1010_fpga_write(emu, 18U, 12U);
#line 1092
  snd_emu1010_fpga_read(emu, 10U, & tmp);
#line 1093
  snd_emu1010_fpga_write(emu, 10U, 16U);
  }
#line 1096
  if ((unsigned long )emu->emu1010.firmware_thread == (unsigned long )((struct task_struct *)0)) {
    {
#line 1097
    emu->emu1010.firmware_thread = kthread_create_on_node(& emu1010_firmware_thread,
                                                          (void *)emu, -1, "emu1010_firmware");
#line 1100
    wake_up_process(emu->emu1010.firmware_thread);
    }
  } else {

  }
#line 1114
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U) {
    {
#line 1117
    snd_emu1010_fpga_link_dst_src_write(emu, 256U, 768U);
#line 1119
    emu->emu1010.output_source[0] = 17U;
#line 1120
    snd_emu1010_fpga_link_dst_src_write(emu, 260U, 769U);
#line 1122
    emu->emu1010.output_source[1] = 18U;
#line 1123
    snd_emu1010_fpga_link_dst_src_write(emu, 264U, 770U);
#line 1125
    emu->emu1010.output_source[2] = 19U;
#line 1126
    snd_emu1010_fpga_link_dst_src_write(emu, 268U, 771U);
#line 1128
    emu->emu1010.output_source[3] = 20U;
#line 1129
    snd_emu1010_fpga_link_dst_src_write(emu, 272U, 772U);
#line 1131
    emu->emu1010.output_source[4] = 21U;
#line 1132
    snd_emu1010_fpga_link_dst_src_write(emu, 276U, 773U);
#line 1134
    emu->emu1010.output_source[5] = 22U;
#line 1136
    snd_emu1010_fpga_link_dst_src_write(emu, 768U, 768U);
#line 1138
    emu->emu1010.output_source[16] = 17U;
#line 1139
    snd_emu1010_fpga_link_dst_src_write(emu, 769U, 769U);
#line 1141
    emu->emu1010.output_source[17] = 18U;
    }
  } else {
    {
#line 1144
    snd_emu1010_fpga_link_dst_src_write(emu, 256U, 768U);
#line 1146
    emu->emu1010.output_source[0] = 21U;
#line 1147
    snd_emu1010_fpga_link_dst_src_write(emu, 260U, 769U);
#line 1149
    emu->emu1010.output_source[1] = 22U;
#line 1150
    snd_emu1010_fpga_link_dst_src_write(emu, 264U, 770U);
#line 1152
    emu->emu1010.output_source[2] = 23U;
#line 1153
    snd_emu1010_fpga_link_dst_src_write(emu, 268U, 771U);
#line 1155
    emu->emu1010.output_source[3] = 24U;
#line 1156
    snd_emu1010_fpga_link_dst_src_write(emu, 272U, 772U);
#line 1158
    emu->emu1010.output_source[4] = 25U;
#line 1159
    snd_emu1010_fpga_link_dst_src_write(emu, 276U, 773U);
#line 1161
    emu->emu1010.output_source[5] = 26U;
#line 1162
    snd_emu1010_fpga_link_dst_src_write(emu, 280U, 774U);
#line 1164
    emu->emu1010.output_source[6] = 27U;
#line 1165
    snd_emu1010_fpga_link_dst_src_write(emu, 284U, 775U);
#line 1167
    emu->emu1010.output_source[7] = 28U;
#line 1169
    snd_emu1010_fpga_link_dst_src_write(emu, 274U, 768U);
#line 1171
    emu->emu1010.output_source[8] = 21U;
#line 1172
    snd_emu1010_fpga_link_dst_src_write(emu, 278U, 769U);
#line 1174
    emu->emu1010.output_source[9] = 22U;
#line 1176
    snd_emu1010_fpga_link_dst_src_write(emu, 282U, 768U);
#line 1178
    emu->emu1010.output_source[10] = 21U;
#line 1179
    snd_emu1010_fpga_link_dst_src_write(emu, 286U, 769U);
#line 1181
    emu->emu1010.output_source[11] = 22U;
#line 1183
    snd_emu1010_fpga_link_dst_src_write(emu, 512U, 768U);
#line 1185
    emu->emu1010.output_source[12] = 21U;
#line 1186
    snd_emu1010_fpga_link_dst_src_write(emu, 513U, 769U);
#line 1188
    emu->emu1010.output_source[13] = 22U;
#line 1190
    snd_emu1010_fpga_link_dst_src_write(emu, 768U, 768U);
#line 1192
    emu->emu1010.output_source[14] = 21U;
#line 1193
    snd_emu1010_fpga_link_dst_src_write(emu, 769U, 769U);
#line 1195
    emu->emu1010.output_source[15] = 22U;
#line 1197
    snd_emu1010_fpga_link_dst_src_write(emu, 1024U, 768U);
#line 1199
    emu->emu1010.output_source[16] = 21U;
#line 1200
    snd_emu1010_fpga_link_dst_src_write(emu, 1025U, 769U);
#line 1202
    emu->emu1010.output_source[17] = 22U;
#line 1203
    snd_emu1010_fpga_link_dst_src_write(emu, 1026U, 770U);
#line 1205
    emu->emu1010.output_source[18] = 23U;
#line 1206
    snd_emu1010_fpga_link_dst_src_write(emu, 1027U, 771U);
#line 1208
    emu->emu1010.output_source[19] = 24U;
#line 1209
    snd_emu1010_fpga_link_dst_src_write(emu, 1028U, 772U);
#line 1211
    emu->emu1010.output_source[20] = 25U;
#line 1212
    snd_emu1010_fpga_link_dst_src_write(emu, 1029U, 773U);
#line 1214
    emu->emu1010.output_source[21] = 26U;
#line 1215
    snd_emu1010_fpga_link_dst_src_write(emu, 1030U, 774U);
#line 1217
    emu->emu1010.output_source[22] = 27U;
#line 1218
    snd_emu1010_fpga_link_dst_src_write(emu, 1031U, 775U);
#line 1220
    emu->emu1010.output_source[23] = 28U;
    }
  }
  {
#line 1226
  snd_emu1010_fpga_write(emu, 7U, 0U);
#line 1227
  snd_emu1010_fpga_write(emu, 6U, 0U);
#line 1229
  snd_emu1010_fpga_write(emu, 5U, 0U);
#line 1231
  emu->emu1010.internal_clock = 1U;
#line 1232
  snd_emu1010_fpga_write(emu, 14U, 18U);
#line 1233
  snd_emu1010_fpga_write(emu, 7U, 1U);
  }
#line 1238
  return (0);
}
}
#line 1245
static int alloc_pm_buffer(struct snd_emu10k1 *emu ) ;
#line 1246
static void free_pm_buffer(struct snd_emu10k1 *emu ) ;
#line 1249 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu10k1_free(struct snd_emu10k1 *emu ) 
{ 


  {
#line 1251
  if (emu->port != 0UL) {
    {
#line 1252
    snd_emu10k1_fx8010_tram_setup(emu, 0U);
#line 1253
    snd_emu10k1_done(emu);
#line 1254
    snd_emu10k1_free_efx(emu);
    }
  } else {

  }
#line 1256
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 1U) {
    {
#line 1258
    snd_emu1010_fpga_write(emu, 4U, 0U);
    }
  } else {

  }
#line 1260
  if ((unsigned long )emu->emu1010.firmware_thread != (unsigned long )((struct task_struct *)0)) {
    {
#line 1261
    kthread_stop(emu->emu1010.firmware_thread);
    }
  } else {

  }
#line 1262
  if (emu->irq >= 0) {
    {
#line 1263
    ldv_free_irq_35((unsigned int )emu->irq, (void *)emu);
    }
  } else {

  }
#line 1265
  if ((unsigned long )emu->reserved_page != (unsigned long )((struct snd_emu10k1_memblk *)0)) {
    {
#line 1266
    snd_emu10k1_synth_free(emu, (struct snd_util_memblk *)emu->reserved_page);
#line 1268
    emu->reserved_page = (struct snd_emu10k1_memblk *)0;
    }
  } else {

  }
#line 1270
  if ((unsigned long )emu->memhdr != (unsigned long )((struct snd_util_memhdr *)0)) {
    {
#line 1271
    snd_util_memhdr_free(emu->memhdr);
    }
  } else {

  }
#line 1272
  if ((unsigned long )emu->silent_page.area != (unsigned long )((unsigned char *)0U)) {
    {
#line 1273
    snd_dma_free_pages(& emu->silent_page);
    }
  } else {

  }
#line 1274
  if ((unsigned long )emu->ptb_pages.area != (unsigned long )((unsigned char *)0U)) {
    {
#line 1275
    snd_dma_free_pages(& emu->ptb_pages);
    }
  } else {

  }
  {
#line 1276
  vfree((void const   *)emu->page_ptr_table);
#line 1277
  vfree((void const   *)emu->page_addr_table);
#line 1279
  free_pm_buffer(emu);
  }
#line 1281
  if (emu->port != 0UL) {
    {
#line 1282
    pci_release_regions(emu->pci);
    }
  } else {

  }
#line 1283
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 1284
    snd_p16v_free(emu);
    }
  } else {

  }
  {
#line 1285
  pci_disable_device(emu->pci);
#line 1286
  kfree((void const   *)emu);
  }
#line 1287
  return (0);
}
}
#line 1290 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int snd_emu10k1_dev_free(struct snd_device *device ) 
{ 
  struct snd_emu10k1 *emu ;
  int tmp ;

  {
  {
#line 1292
  emu = (struct snd_emu10k1 *)device->device_data;
#line 1293
  tmp = snd_emu10k1_free(emu);
  }
#line 1293
  return (tmp);
}
}
#line 1296 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static struct snd_emu_chip_details emu_chip_details[46U]  = 
#line 1296
  {      {4354U, 8U, 270602498U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, "Audigy2", "SB Audigy 4 [SB0610]", "Audigy2"}, 
        {4354U, 8U, 268505346U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "SB Audigy 2 Value [SB0400]",
      "Audigy2"}, 
        {4354U, 8U, 536940802U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, 1U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      "Audigy2", "SB Audigy 2 ZS Notebook [SB0530]", "Audigy2"}, 
        {4354U, 8U, 1107366146U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, 1U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 3U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, "Audigy2", "E-mu 1010 Notebook [MAEM8950]", "EMU1010"}, 
        {4354U, 8U, 1074008322U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 2U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "E-mu 1010b PCI [MAEM8960]",
      "EMU1010"}, 
        {4354U, 8U, 1074204930U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 2U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "E-mu 1010 PCIe [MAEM8986]",
      "EMU1010"}, 
        {4354U, 4U, 1073811714U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "E-mu 1010 [MAEM8810]", "EMU1010"}, 
        {4354U,
      8U, 1073877250U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, 1U,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 4U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "E-mu 0404b PCI [MAEM8852]",
      "EMU0404"}, 
        {4354U, 4U, 1073877250U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 4U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "E-mu 0404 [MAEM8850]", "EMU0404"}, 
        {4354U,
      8U, 1074073858U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, 1U,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 4U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "E-mu 0404 PCIe [MAEM8984]",
      "EMU0404"}, 
        {4354U, 8U, 0U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, 1U,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy2", "SB Audigy 2 Value [Unknown]",
      "Audigy2"}, 
        {4354U, 4U, 537334018U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, "Audigy2",
      "SB Audigy 4 PRO [SB0380]", "Audigy2"}, 
        {4354U, 4U, 537268482U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, "Audigy2", "SB Audigy 2 [SB0350b]",
      "Audigy2"}, 
        {4354U, 4U, 537006338U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, "Audigy2", "SB Audigy 2 ZS [SB0350]",
      "Audigy2"}, 
        {4354U, 4U, 536940802U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, "Audigy2", "SB Audigy 2 ZS [SB0360]",
      "Audigy2"}, 
        {4354U, 4U, 268898562U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, "Audigy2", "SB Audigy 2 [SB0240]",
      "Audigy2"}, 
        {4354U, 4U, 268767490U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      "Audigy2", "SB Audigy 2 Platinum EX [SB0280]", "Audigy2"}, 
        {4354U, 4U, 268636418U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, "Audigy2", "SB Audigy 2 ZS [SB0353]",
      "Audigy2"}, 
        {4354U, 4U, 268570882U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, 1U, 1U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, 1U, "Audigy2", "SB Audigy 2 Platinum [SB0240P]",
      "Audigy2"}, 
        {4354U, 4U, 0U, 4U, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, "Audigy2",
      "SB Audigy 2 [Unknown]", "Audigy2"}, 
        {4354U, 4U, 5443842U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy", "SB Audigy 1 [SB0092]", "Audigy"}, 
        {4354U,
      4U, 5378306U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy", "SB Audigy 1 ES [SB0160]", "Audigy"}, 
        {4354U,
      4U, 5312770U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "Audigy", "SB Audigy 1 [SB0090]", "Audigy"}, 
        {4354U,
      4U, 0U, (unsigned char)0, (unsigned char)0, 1U, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, "Audigy", "Audigy 1 [Unknown]", "Audigy"}, 
        {4354U, 2U, 269095170U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! 5.1 [SB0220]",
      "Live"}, 
        {4354U, 2U, 2154500354U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! [SB0105]",
      "Live"}, 
        {4354U, 2U, 2154434818U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [SB0103]",
      "Live"}, 
        {4354U, 2U, 2154369282U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [SB0101]",
      "Live"}, 
        {4354U, 2U, 2154172674U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! 5.1 Dell OEM [SB0228]",
      "Live"}, 
        {4354U, 2U, 2154107138U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! 5.1 [SB0220]",
      "Live"}, 
        {4354U, 2U, 2154041602U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! 5.1",
      "Live"}, 
        {4354U, 2U, 2153844994U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 2U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! 5.1 [SB0060]",
      "Live"}, 
        {4354U, 2U, 2152796418U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4850]",
      "Live"}, 
        {4354U, 2U, 2151682306U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Platinum [CT4760P]",
      "Live"}, 
        {4354U, 2U, 2150764802U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4871]",
      "Live"}, 
        {4354U, 2U, 2150699266U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4831]",
      "Live"}, 
        {4354U, 2U, 2150109442U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4870]",
      "Live"}, 
        {4354U, 2U, 2150043906U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4832]",
      "Live"}, 
        {4354U, 2U, 2149978370U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4830]",
      "Live"}, 
        {4354U, 2U, 2149781762U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB PCI512 [CT4790]",
      "Live"}, 
        {4354U, 2U, 2149716226U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4780]",
      "Live"}, 
        {4354U, 2U, 1073811714U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "E-mu APS [PC545]",
      "APS"}, 
        {4354U, 2U, 2167042U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! [CT4620]",
      "Live"}, 
        {4354U, 2U, 2101506U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
      (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! Value [CT4670]",
      "Live"}, 
        {4354U, 2U, 0U, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
      1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, "EMU10K1", "SB Live! [Unknown]", "Live"}};
#line 1729 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
int snd_emu10k1_create(struct snd_card *card , struct pci_dev *pci , unsigned short extin_mask ,
                       unsigned short extout_mask , long max_cache_bytes , int enable_ir___0 ,
                       uint subsystem___0 , struct snd_emu10k1 **remu ) 
{ 
  struct snd_emu10k1 *emu ;
  int idx ;
  int err ;
  int is_audigy ;
  unsigned int silent_page ;
  struct snd_emu_chip_details  const  *c ;
  struct snd_device_ops ops ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;
  int i ;
  int n ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  struct snd_util_memblk *tmp___11 ;

  {
  {
#line 1743
  ops.dev_free = & snd_emu10k1_dev_free;
#line 1743
  ops.dev_register = 0;
#line 1743
  ops.dev_disconnect = 0;
#line 1747
  *remu = (struct snd_emu10k1 *)0;
#line 1750
  err = pci_enable_device(pci);
  }
#line 1751
  if (err < 0) {
#line 1752
    return (err);
  } else {

  }
  {
#line 1754
  tmp = kzalloc(9032UL, 208U);
#line 1754
  emu = (struct snd_emu10k1 *)tmp;
  }
#line 1755
  if ((unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0)) {
    {
#line 1756
    pci_disable_device(pci);
    }
#line 1757
    return (-12);
  } else {

  }
  {
#line 1759
  emu->card = card;
#line 1760
  spinlock_check(& emu->reg_lock);
#line 1760
  __raw_spin_lock_init(& emu->reg_lock.__annonCompField19.rlock, "&(&emu->reg_lock)->rlock",
                       & __key);
#line 1761
  spinlock_check(& emu->emu_lock);
#line 1761
  __raw_spin_lock_init(& emu->emu_lock.__annonCompField19.rlock, "&(&emu->emu_lock)->rlock",
                       & __key___0);
#line 1762
  spinlock_check(& emu->spi_lock);
#line 1762
  __raw_spin_lock_init(& emu->spi_lock.__annonCompField19.rlock, "&(&emu->spi_lock)->rlock",
                       & __key___1);
#line 1763
  spinlock_check(& emu->i2c_lock);
#line 1763
  __raw_spin_lock_init(& emu->i2c_lock.__annonCompField19.rlock, "&(&emu->i2c_lock)->rlock",
                       & __key___2);
#line 1764
  spinlock_check(& emu->voice_lock);
#line 1764
  __raw_spin_lock_init(& emu->voice_lock.__annonCompField19.rlock, "&(&emu->voice_lock)->rlock",
                       & __key___3);
#line 1765
  spinlock_check(& emu->synth_lock);
#line 1765
  __raw_spin_lock_init(& emu->synth_lock.__annonCompField19.rlock, "&(&emu->synth_lock)->rlock",
                       & __key___4);
#line 1766
  spinlock_check(& emu->memblk_lock);
#line 1766
  __raw_spin_lock_init(& emu->memblk_lock.__annonCompField19.rlock, "&(&emu->memblk_lock)->rlock",
                       & __key___5);
#line 1767
  __mutex_init(& emu->fx8010.lock, "&emu->fx8010.lock", & __key___6);
#line 1768
  INIT_LIST_HEAD(& emu->mapped_link_head);
#line 1769
  INIT_LIST_HEAD(& emu->mapped_order_link_head);
#line 1770
  emu->pci = pci;
#line 1771
  emu->irq = -1;
#line 1772
  emu->synth = (void *)0;
#line 1773
  emu->get_synth_voice = (int (*)(struct snd_emu10k1 * ))0;
#line 1775
  emu->revision = (unsigned int )pci->revision;
#line 1776
  pci_read_config_dword(pci, 44, & emu->serial);
#line 1777
  pci_read_config_word(pci, 46, & emu->model);
#line 1778
  __snd_printk(2U, "sound/pci/emu10k1/emu10k1_main.c", 1778, "vendor = 0x%x, device = 0x%x, subsystem_vendor_id = 0x%x, subsystem_id = 0x%x\n",
               (int )pci->vendor, (int )pci->device, emu->serial, (int )emu->model);
#line 1780
  c = (struct snd_emu_chip_details  const  *)(& emu_chip_details);
  }
#line 1780
  goto ldv_31539;
  ldv_31538: ;
#line 1781
  if ((unsigned int )c->vendor == (unsigned int )pci->vendor && (unsigned int )c->device == (unsigned int )pci->device) {
#line 1782
    if (subsystem___0 != 0U) {
#line 1783
      if ((unsigned int )c->subsystem != 0U && (unsigned int )c->subsystem == subsystem___0) {
#line 1784
        goto ldv_31536;
      } else {
#line 1786
        goto ldv_31537;
      }
    } else {
#line 1788
      if ((unsigned int )c->subsystem != 0U && (unsigned int )c->subsystem != emu->serial) {
#line 1789
        goto ldv_31537;
      } else {

      }
#line 1790
      if ((unsigned int )((unsigned char )c->revision) != 0U && (unsigned int )c->revision != emu->revision) {
#line 1791
        goto ldv_31537;
      } else {

      }
    }
#line 1793
    goto ldv_31536;
  } else {

  }
  ldv_31537: 
#line 1780
  c = c + 1;
  ldv_31539: ;
#line 1780
  if ((unsigned int )c->vendor != 0U) {
#line 1782
    goto ldv_31538;
  } else {

  }
  ldv_31536: ;
#line 1796
  if ((unsigned int )c->vendor == 0U) {
    {
#line 1797
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 1797, "<3>emu10k1: Card not recognised\n");
#line 1798
    kfree((void const   *)emu);
#line 1799
    pci_disable_device(pci);
    }
#line 1800
    return (-2);
  } else {

  }
#line 1802
  emu->card_capabilities = c;
#line 1803
  if ((unsigned int )c->subsystem != 0U && subsystem___0 == 0U) {
    {
#line 1804
    __snd_printk(2U, "sound/pci/emu10k1/emu10k1_main.c", 1804, "Sound card name = %s\n",
                 c->name);
    }
  } else
#line 1805
  if (subsystem___0 != 0U) {
    {
#line 1806
    __snd_printk(2U, "sound/pci/emu10k1/emu10k1_main.c", 1809, "Sound card name = %s, vendor = 0x%x, device = 0x%x, subsystem = 0x%x. Forced to subsystem = 0x%x\n",
                 c->name, (int )pci->vendor, (int )pci->device, emu->serial, c->subsystem);
    }
  } else {
    {
#line 1811
    __snd_printk(2U, "sound/pci/emu10k1/emu10k1_main.c", 1814, "Sound card name = %s, vendor = 0x%x, device = 0x%x, subsystem = 0x%x.\n",
                 c->name, (int )pci->vendor, (int )pci->device, emu->serial);
    }
  }
#line 1816
  if ((int )((signed char )*((char *)(& card->id))) == 0 && (unsigned long )c->id != (unsigned long )((char const   */* const  */)0)) {
    {
#line 1817
    n = 0;
#line 1818
    strlcpy((char *)(& card->id), c->id, 16UL);
    }
    ldv_31546: 
#line 1820
    i = 0;
#line 1820
    goto ldv_31544;
    ldv_31543: ;
#line 1821
    if ((unsigned long )snd_cards[i] != (unsigned long )((struct snd_card *)0)) {
      {
#line 1821
      tmp___0 = strcmp((char const   *)(& (snd_cards[i])->id), (char const   *)(& card->id));
      }
#line 1821
      if (tmp___0 == 0) {
#line 1822
        goto ldv_31542;
      } else {

      }
    } else {

    }
#line 1820
    i = i + 1;
    ldv_31544: ;
#line 1820
    if (i < snd_ecards_limit) {
#line 1822
      goto ldv_31543;
    } else {

    }
    ldv_31542: ;
#line 1824
    if (i >= snd_ecards_limit) {
#line 1825
      goto ldv_31545;
    } else {

    }
#line 1826
    n = n + 1;
#line 1827
    if (n > 31) {
#line 1828
      goto ldv_31545;
    } else {

    }
    {
#line 1829
    snprintf((char *)(& card->id), 16UL, "%s_%d", c->id, n);
    }
#line 1830
    goto ldv_31546;
    ldv_31545: ;
  } else {

  }
  {
#line 1833
  tmp___1 = (unsigned int )c->emu10k2_chip;
#line 1833
  emu->audigy = tmp___1;
#line 1833
  is_audigy = (int )tmp___1;
#line 1836
  emu->dma_mask = 2147483647UL;
#line 1837
  tmp___2 = pci_set_dma_mask(pci, (u64 )emu->dma_mask);
  }
#line 1837
  if (tmp___2 < 0) {
    {
#line 1839
    __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 1839, "<3>architecture does not support PCI busmaster DMA with mask 0x%lx\n",
                 emu->dma_mask);
#line 1840
    kfree((void const   *)emu);
#line 1841
    pci_disable_device(pci);
    }
#line 1842
    return (-6);
  } else {
    {
#line 1837
    tmp___3 = pci_set_consistent_dma_mask(pci, (u64 )emu->dma_mask);
    }
#line 1837
    if (tmp___3 < 0) {
      {
#line 1839
      __snd_printk(0U, "sound/pci/emu10k1/emu10k1_main.c", 1839, "<3>architecture does not support PCI busmaster DMA with mask 0x%lx\n",
                   emu->dma_mask);
#line 1840
      kfree((void const   *)emu);
#line 1841
      pci_disable_device(pci);
      }
#line 1842
      return (-6);
    } else {

    }
  }
#line 1844
  if (is_audigy != 0) {
#line 1845
    emu->gpr_base = 1024;
  } else {
#line 1847
    emu->gpr_base = 256;
  }
  {
#line 1849
  err = pci_request_regions(pci, "EMU10K1");
  }
#line 1850
  if (err < 0) {
    {
#line 1851
    kfree((void const   *)emu);
#line 1852
    pci_disable_device(pci);
    }
#line 1853
    return (err);
  } else {

  }
  {
#line 1855
  emu->port = (unsigned long )pci->resource[0].start;
#line 1857
  emu->max_cache_pages = (int )(max_cache_bytes >> 12);
#line 1858
  tmp___4 = snd_dma_alloc_pages(2, & pci->dev, 32768UL, & emu->ptb_pages);
  }
#line 1858
  if (tmp___4 < 0) {
#line 1860
    err = -12;
#line 1861
    goto error;
  } else {

  }
  {
#line 1864
  tmp___5 = vmalloc((unsigned long )emu->max_cache_pages * 8UL);
#line 1864
  emu->page_ptr_table = (void **)tmp___5;
#line 1865
  tmp___6 = vmalloc((unsigned long )emu->max_cache_pages * 8UL);
#line 1865
  emu->page_addr_table = (unsigned long *)tmp___6;
  }
#line 1867
  if ((unsigned long )emu->page_ptr_table == (unsigned long )((void **)0) || (unsigned long )emu->page_addr_table == (unsigned long )((unsigned long *)0UL)) {
#line 1868
    err = -12;
#line 1869
    goto error;
  } else {

  }
  {
#line 1872
  tmp___7 = snd_dma_alloc_pages(2, & pci->dev, 4096UL, & emu->silent_page);
  }
#line 1872
  if (tmp___7 < 0) {
#line 1874
    err = -12;
#line 1875
    goto error;
  } else {

  }
  {
#line 1877
  emu->memhdr = snd_util_memhdr_new((int )((unsigned int )emu->max_cache_pages * 4096U));
  }
#line 1878
  if ((unsigned long )emu->memhdr == (unsigned long )((struct snd_util_memhdr *)0)) {
#line 1879
    err = -12;
#line 1880
    goto error;
  } else {

  }
  {
#line 1882
  (emu->memhdr)->block_extra_size = 56;
#line 1885
  pci_set_master(pci);
#line 1887
  emu->fx8010.fxbus_mask = 12351U;
  }
#line 1888
  if ((unsigned int )extin_mask == 0U) {
#line 1889
    extin_mask = 16335U;
  } else {

  }
#line 1890
  if ((unsigned int )extout_mask == 0U) {
#line 1891
    extout_mask = 32767U;
  } else {

  }
#line 1892
  emu->fx8010.extin_mask = extin_mask;
#line 1893
  emu->fx8010.extout_mask = extout_mask;
#line 1894
  emu->enable_ir = (unsigned char )enable_ir___0;
#line 1896
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca_cardbus_chip) != 0U) {
    {
#line 1897
    err = snd_emu10k1_cardbus_init(emu);
    }
#line 1898
    if (err < 0) {
#line 1899
      goto error;
    } else {

    }
  } else {

  }
#line 1901
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ecard) != 0U) {
    {
#line 1902
    err = snd_emu10k1_ecard_init(emu);
    }
#line 1903
    if (err < 0) {
#line 1904
      goto error;
    } else {

    }
  } else
#line 1905
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 1906
    err = snd_emu10k1_emu1010_init(emu);
    }
#line 1907
    if (err < 0) {
      {
#line 1908
      snd_emu10k1_free(emu);
      }
#line 1909
      return (err);
    } else {

    }
  } else {
    {
#line 1914
    snd_emu10k1_ptr_write(emu, 95U, 0U, 48U);
    }
  }
  {
#line 1919
  emu->fx8010.itram_size = 8192U;
#line 1920
  emu->fx8010.etram_pages.area = (unsigned char *)0U;
#line 1921
  emu->fx8010.etram_pages.bytes = 0UL;
#line 1924
  tmp___8 = ldv_request_irq_36(pci->irq, & snd_emu10k1_interrupt, 128UL, "snd_emu10k1",
                               (void *)emu);
  }
#line 1924
  if (tmp___8 != 0) {
#line 1926
    err = -16;
#line 1927
    goto error;
  } else {

  }
  {
#line 1929
  emu->irq = (int )pci->irq;
#line 1945
  tmp___10 = 34640388U;
#line 1945
  emu->spdif_bits[2] = tmp___10;
#line 1945
  tmp___9 = tmp___10;
#line 1945
  emu->spdif_bits[1] = tmp___9;
#line 1945
  emu->spdif_bits[0] = tmp___9;
#line 1951
  tmp___11 = snd_emu10k1_synth_alloc(emu, 4096U);
#line 1951
  emu->reserved_page = (struct snd_emu10k1_memblk *)tmp___11;
  }
#line 1953
  if ((unsigned long )emu->reserved_page != (unsigned long )((struct snd_emu10k1_memblk *)0)) {
#line 1954
    (emu->reserved_page)->map_locked = 1U;
  } else {

  }
  {
#line 1957
  memset((void *)emu->silent_page.area, 0, 4096UL);
#line 1958
  silent_page = (unsigned int )emu->silent_page.addr << 1U;
#line 1959
  idx = 0;
  }
#line 1959
  goto ldv_31549;
  ldv_31548: 
#line 1960
  *((u32 *)emu->ptb_pages.area + (unsigned long )idx) = silent_page | (unsigned int )idx;
#line 1959
  idx = idx + 1;
  ldv_31549: ;
#line 1959
  if (idx <= 8191) {
#line 1961
    goto ldv_31548;
  } else {

  }
#line 1963
  idx = 0;
#line 1963
  goto ldv_31552;
  ldv_31551: 
#line 1964
  emu->voices[idx].emu = emu;
#line 1965
  emu->voices[idx].number = idx;
#line 1963
  idx = idx + 1;
  ldv_31552: ;
#line 1963
  if (idx <= 63) {
#line 1965
    goto ldv_31551;
  } else {

  }
  {
#line 1968
  err = snd_emu10k1_init(emu, enable_ir___0, 0);
  }
#line 1969
  if (err < 0) {
#line 1970
    goto error;
  } else {

  }
  {
#line 1972
  err = alloc_pm_buffer(emu);
  }
#line 1973
  if (err < 0) {
#line 1974
    goto error;
  } else {

  }
  {
#line 1978
  err = snd_emu10k1_init_efx(emu);
  }
#line 1979
  if (err < 0) {
#line 1980
    goto error;
  } else {

  }
  {
#line 1981
  snd_emu10k1_audio_enable(emu);
#line 1983
  err = snd_device_new(card, 8192, (void *)emu, & ops);
  }
#line 1984
  if (err < 0) {
#line 1985
    goto error;
  } else {

  }
  {
#line 1988
  snd_emu10k1_proc_init(emu);
#line 1991
  card->dev = & pci->dev;
#line 1992
  *remu = emu;
  }
#line 1993
  return (0);
  error: 
  {
#line 1996
  snd_emu10k1_free(emu);
  }
#line 1997
  return (err);
}
}
#line 2001 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static unsigned char saved_regs[51U]  = 
#line 2001
  {      0U,      1U,      2U,      3U, 
        5U,      4U,      6U,      7U, 
        8U,      9U,      10U,      11U, 
        12U,      13U,      16U,      17U, 
        18U,      19U,      20U,      21U, 
        22U,      23U,      24U,      25U, 
        26U,      27U,      28U,      29U, 
        30U,      66U,      67U,      69U, 
        70U,      71U,      73U,      74U, 
        75U,      80U,      81U,      84U, 
        85U,      86U,      94U,      95U, 
        96U,      97U,      98U,      99U, 
        100U,      101U,      255U};
#line 2010 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static unsigned char saved_regs_audigy[9U]  = 
#line 2010
  {      99U,      100U,      116U,      117U, 
        118U,      124U,      125U,      126U, 
        255U};
#line 2016 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static int alloc_pm_buffer(struct snd_emu10k1 *emu ) 
{ 
  int size ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2020
  size = 51;
#line 2021
  if (emu->audigy != 0U) {
#line 2022
    size = (int )((unsigned int )size + 9U);
  } else {

  }
  {
#line 2023
  tmp = vmalloc((unsigned long )(size * 256));
#line 2023
  emu->saved_ptr = (unsigned int *)tmp;
  }
#line 2024
  if ((unsigned long )emu->saved_ptr == (unsigned long )((unsigned int *)0U)) {
#line 2025
    return (-12);
  } else {

  }
  {
#line 2026
  tmp___0 = snd_emu10k1_efx_alloc_pm_buffer(emu);
  }
#line 2026
  if (tmp___0 < 0) {
#line 2027
    return (-12);
  } else {

  }
#line 2028
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 2028
    tmp___1 = snd_p16v_alloc_pm_buffer(emu);
    }
#line 2028
    if (tmp___1 < 0) {
#line 2030
      return (-12);
    } else {

    }
  } else {

  }
#line 2031
  return (0);
}
}
#line 2034 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
static void free_pm_buffer(struct snd_emu10k1 *emu ) 
{ 


  {
  {
#line 2036
  vfree((void const   *)emu->saved_ptr);
#line 2037
  snd_emu10k1_efx_free_pm_buffer(emu);
  }
#line 2038
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 2039
    snd_p16v_free_pm_buffer(emu);
    }
  } else {

  }
#line 2040
  return;
}
}
#line 2042 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
void snd_emu10k1_suspend_regs(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  unsigned char *reg ;
  unsigned int *val ;

  {
#line 2048
  val = emu->saved_ptr;
#line 2049
  reg = (unsigned char *)(& saved_regs);
#line 2049
  goto ldv_31577;
  ldv_31576: 
#line 2050
  i = 0;
#line 2050
  goto ldv_31574;
  ldv_31573: 
  {
#line 2051
  *val = snd_emu10k1_ptr_read(emu, (unsigned int )*reg, (unsigned int )i);
#line 2050
  i = i + 1;
#line 2050
  val = val + 1;
  }
  ldv_31574: ;
#line 2050
  if (i <= 63) {
#line 2052
    goto ldv_31573;
  } else {

  }
#line 2049
  reg = reg + 1;
  ldv_31577: ;
#line 2049
  if ((unsigned int )*reg != 255U) {
#line 2051
    goto ldv_31576;
  } else {

  }

#line 2052
  if (emu->audigy != 0U) {
#line 2053
    reg = (unsigned char *)(& saved_regs_audigy);
#line 2053
    goto ldv_31583;
    ldv_31582: 
#line 2054
    i = 0;
#line 2054
    goto ldv_31580;
    ldv_31579: 
    {
#line 2055
    *val = snd_emu10k1_ptr_read(emu, (unsigned int )*reg, (unsigned int )i);
#line 2054
    i = i + 1;
#line 2054
    val = val + 1;
    }
    ldv_31580: ;
#line 2054
    if (i <= 63) {
#line 2056
      goto ldv_31579;
    } else {

    }
#line 2053
    reg = reg + 1;
    ldv_31583: ;
#line 2053
    if ((unsigned int )*reg != 255U) {
#line 2055
      goto ldv_31582;
    } else {

    }

  } else {

  }
#line 2057
  if (emu->audigy != 0U) {
    {
#line 2058
    emu->saved_a_iocfg = inl((int )((unsigned int )emu->port + 24U));
    }
  } else {

  }
  {
#line 2059
  emu->saved_hcfg = inl((int )((unsigned int )emu->port + 20U));
  }
#line 2060
  return;
}
}
#line 2062 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
void snd_emu10k1_resume_init(struct snd_emu10k1 *emu ) 
{ 


  {
#line 2064
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca_cardbus_chip) != 0U) {
    {
#line 2065
    snd_emu10k1_cardbus_init(emu);
    }
  } else {

  }
#line 2066
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ecard) != 0U) {
    {
#line 2067
    snd_emu10k1_ecard_init(emu);
    }
  } else
#line 2068
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 2069
    snd_emu10k1_emu1010_init(emu);
    }
  } else {
    {
#line 2071
    snd_emu10k1_ptr_write(emu, 95U, 0U, 48U);
    }
  }
  {
#line 2072
  snd_emu10k1_init(emu, (int )emu->enable_ir, 1);
  }
#line 2073
  return;
}
}
#line 2075 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emu10k1_main.c"
void snd_emu10k1_resume_regs(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  unsigned char *reg ;
  unsigned int *val ;

  {
  {
#line 2081
  snd_emu10k1_audio_enable(emu);
  }
#line 2084
  if (emu->audigy != 0U) {
    {
#line 2085
    outl(emu->saved_a_iocfg, (int )((unsigned int )emu->port + 24U));
    }
  } else {

  }
  {
#line 2086
  outl(emu->saved_hcfg, (int )((unsigned int )emu->port + 20U));
#line 2088
  val = emu->saved_ptr;
#line 2089
  reg = (unsigned char *)(& saved_regs);
  }
#line 2089
  goto ldv_31598;
  ldv_31597: 
#line 2090
  i = 0;
#line 2090
  goto ldv_31595;
  ldv_31594: 
  {
#line 2091
  snd_emu10k1_ptr_write(emu, (unsigned int )*reg, (unsigned int )i, *val);
#line 2090
  i = i + 1;
#line 2090
  val = val + 1;
  }
  ldv_31595: ;
#line 2090
  if (i <= 63) {
#line 2092
    goto ldv_31594;
  } else {

  }
#line 2089
  reg = reg + 1;
  ldv_31598: ;
#line 2089
  if ((unsigned int )*reg != 255U) {
#line 2091
    goto ldv_31597;
  } else {

  }

#line 2092
  if (emu->audigy != 0U) {
#line 2093
    reg = (unsigned char *)(& saved_regs_audigy);
#line 2093
    goto ldv_31604;
    ldv_31603: 
#line 2094
    i = 0;
#line 2094
    goto ldv_31601;
    ldv_31600: 
    {
#line 2095
    snd_emu10k1_ptr_write(emu, (unsigned int )*reg, (unsigned int )i, *val);
#line 2094
    i = i + 1;
#line 2094
    val = val + 1;
    }
    ldv_31601: ;
#line 2094
    if (i <= 63) {
#line 2096
      goto ldv_31600;
    } else {

    }
#line 2093
    reg = reg + 1;
    ldv_31604: ;
#line 2093
    if ((unsigned int )*reg != 255U) {
#line 2095
      goto ldv_31603;
    } else {

    }

  } else {

  }
#line 2101
  return;
}
}
#line 198 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
void ldv_dispatch_irq_deregister_5_1(int arg0 ) ;
#line 199
void ldv_dispatch_irq_register_6_3(int arg0 , irqreturn_t (*arg1)(int  , void * ) ,
                                   irqreturn_t (*arg2)(int  , void * ) , void *arg3 ) ;
#line 200
void ldv_emg_free_irq(int arg0 , void *arg1 ) ;
#line 201
int ldv_emg_request_irq(unsigned int arg0 , irqreturn_t (*arg1)(int  , void * ) ,
                        unsigned long arg2 , char *arg3 , void *arg4 ) ;
#line 202
void ldv_interrupt_scenario_2(void *arg0 ) ;
#line 203
enum irqreturn ldv_interrupt_scenario_handler_2_5(irqreturn_t (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 204
void ldv_interrupt_scenario_thread_2_3(irqreturn_t (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 212 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
void ldv_dispatch_irq_deregister_5_1(int arg0 ) 
{ 


  {
#line 215
  return;
}
}
#line 219 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
void ldv_dispatch_irq_register_6_3(int arg0 , irqreturn_t (*arg1)(int  , void * ) ,
                                   irqreturn_t (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_scenario_2 *cf_arg_2 ;
  void *tmp ;

  {
  {
#line 221
  tmp = ldv_xmalloc(40UL);
#line 221
  cf_arg_2 = (struct ldv_struct_interrupt_scenario_2 *)tmp;
#line 222
  cf_arg_2->arg0 = arg0;
#line 223
  cf_arg_2->arg1 = arg1;
#line 224
  cf_arg_2->arg2 = arg2;
#line 225
  cf_arg_2->arg3 = arg3;
#line 226
  ldv_interrupt_scenario_2((void *)cf_arg_2);
  }
#line 227
  return;
}
}
#line 231 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
void ldv_emg_free_irq(int arg0 , void *arg1 ) 
{ 
  int ldv_5_line_line ;

  {
  {
#line 237
  ldv_5_line_line = arg0;
#line 241
  ldv_dispatch_irq_deregister_5_1(ldv_5_line_line);
  }
#line 245
  return;
#line 247
  return;
}
}
#line 252 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
int ldv_emg_request_irq(unsigned int arg0 , irqreturn_t (*arg1)(int  , void * ) ,
                        unsigned long arg2 , char *arg3 , void *arg4 ) 
{ 
  irqreturn_t (*ldv_6_callback_handler)(int  , void * ) ;
  void *ldv_6_data_data ;
  int ldv_6_line_line ;
  irqreturn_t (*ldv_6_thread_thread)(int  , void * ) ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  tmp___0 = ldv_undef_int();
  }
#line 262
  if (tmp___0 != 0) {
    {
#line 264
    ldv_6_line_line = (int )arg0;
#line 265
    ldv_6_callback_handler = arg1;
#line 266
    ldv_6_thread_thread = (irqreturn_t (*)(int  , void * ))0;
#line 267
    ldv_6_data_data = arg4;
#line 271
    ldv_dispatch_irq_register_6_3(ldv_6_line_line, ldv_6_callback_handler, ldv_6_thread_thread,
                                  ldv_6_data_data);
    }
#line 275
    return (0);
  } else {
    {
#line 282
    tmp = ldv_undef_int_negative();
    }
#line 282
    return (tmp);
  }
}
}
#line 292 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
void ldv_interrupt_scenario_2(void *arg0 ) 
{ 
  irqreturn_t (*ldv_2_callback_handler)(int  , void * ) ;
  void *ldv_2_data_data ;
  int ldv_2_line_line ;
  enum irqreturn ldv_2_ret_val_default ;
  irqreturn_t (*ldv_2_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_scenario_2 *data ;
  int tmp ;

  {
#line 301
  data = (struct ldv_struct_interrupt_scenario_2 *)arg0;
#line 306
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_scenario_2 *)0)) {
    {
#line 307
    ldv_2_line_line = data->arg0;
#line 308
    ldv_2_callback_handler = data->arg1;
#line 309
    ldv_2_thread_thread = data->arg2;
#line 310
    ldv_2_data_data = data->arg3;
#line 311
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 317
  ldv_switch_to_interrupt_context();
#line 319
  ldv_2_ret_val_default = ldv_interrupt_scenario_handler_2_5(ldv_2_callback_handler,
                                                             ldv_2_line_line, ldv_2_data_data);
#line 321
  ldv_switch_to_process_context();
#line 324
  tmp = ldv_undef_int();
  }
#line 324
  if (tmp != 0) {
    {
#line 326
    __VERIFIER_assume((unsigned int )ldv_2_ret_val_default == 2U);
    }
#line 330
    if ((unsigned long )ldv_2_thread_thread != (unsigned long )((irqreturn_t (*)(int  ,
                                                                                 void * ))0)) {
      {
#line 332
      ldv_interrupt_scenario_thread_2_3(ldv_2_thread_thread, ldv_2_line_line, ldv_2_data_data);
      }
    } else {

    }
  } else {
    {
#line 339
    __VERIFIER_assume((unsigned int )ldv_2_ret_val_default != 2U);
    }
  }
#line 348
  return;
#line 350
  return;
}
}
#line 355 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
enum irqreturn ldv_interrupt_scenario_handler_2_5(irqreturn_t (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 356
  tmp = snd_emu10k1_interrupt(arg1, arg2);
  }
#line 356
  return (tmp);
}
}
#line 360 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
void ldv_interrupt_scenario_thread_2_3(irqreturn_t (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 361
  (*arg0)(arg1, arg2);
  }
#line 362
  return;
}
}
#line 463 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 466
  tmp = ldv_kzalloc(size, flags);
  }
#line 466
  return (tmp);
}
}
#line 637 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
static void ldv___ldv_spin_lock_33___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 640
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 642
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 643
  return;
}
}
#line 646 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 649
  ldv_spin_unlock_emu_lock_of_snd_emu10k1();
#line 651
  spin_unlock_irqrestore(lock, flags);
  }
#line 652
  return;
}
}
#line 655 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
static void ldv_free_irq_35(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 659
  ldv_emg_free_irq((int )ldv_func_arg1, ldv_func_arg2);
  }
#line 660
  return;
}
}
#line 663 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emu10k1_main.c.aux"
__inline static int ldv_request_irq_36(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  int tmp ;

  {
  {
#line 667
  tmp = ldv_emg_request_irq(irq, handler, flags, (char *)name, dev);
  }
#line 667
  return (tmp);
}
}
#line 876 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
extern void snd_pcm_period_elapsed(struct snd_pcm_substream * ) ;
#line 141 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/timer.h"
extern void snd_timer_interrupt(struct snd_timer * , unsigned long  ) ;
#line 1844 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
void snd_emu10k1_intr_disable(struct snd_emu10k1 *emu , unsigned int intrenb ) ;
#line 1846
void snd_emu10k1_voice_intr_disable(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1847
void snd_emu10k1_voice_intr_ack(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1849
void snd_emu10k1_voice_half_loop_intr_disable(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1850
void snd_emu10k1_voice_half_loop_intr_ack(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/irq.c"
irqreturn_t snd_emu10k1_interrupt(int irq , void *dev_id ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int status ;
  unsigned int status2 ;
  unsigned int orig_status ;
  unsigned int orig_status2 ;
  int handled ;
  int timeout ;
  int voice ;
  int voice_max ;
  u32 val ;
  struct snd_emu10k1_voice *pvoice ;
  u32 mask ;
  struct snd_emu10k1_voice *pvoice___0 ;
  struct snd_emu10k1_voice *cvoice ;
  unsigned int bits ;

  {
#line 34
  emu = (struct snd_emu10k1 *)dev_id;
#line 36
  handled = 0;
#line 37
  timeout = 0;
#line 39
  goto ldv_30227;
  ldv_30226: 
#line 40
  timeout = timeout + 1;
#line 41
  orig_status = status;
#line 42
  handled = 1;
#line 43
  if (status == 4294967295U) {
    {
#line 44
    __snd_printk(0U, "sound/pci/emu10k1/irq.c", 44, "<6>snd-emu10k1: Suspected sound card removal\n");
    }
#line 45
    goto ldv_30208;
  } else {

  }
#line 47
  if ((status & 2097152U) != 0U) {
    {
#line 48
    __snd_printk(0U, "sound/pci/emu10k1/irq.c", 48, "<3>interrupt: PCI error\n");
#line 49
    snd_emu10k1_intr_disable(emu, 2048U);
#line 50
    status = status & 4292870143U;
    }
  } else {

  }
#line 52
  if ((status & 1835008U) != 0U) {
#line 53
    if ((unsigned long )emu->hwvol_interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                           unsigned int  ))0)) {
      {
#line 54
      (*(emu->hwvol_interrupt))(emu, status);
      }
    } else {
      {
#line 56
      snd_emu10k1_intr_disable(emu, 1792U);
      }
    }
#line 57
    status = status & 4293132287U;
  } else {

  }
#line 59
  if ((status & 64U) != 0U) {
    {
#line 61
    voice_max = (int )status & 63;
#line 63
    pvoice = (struct snd_emu10k1_voice *)(& emu->voices);
#line 65
    val = snd_emu10k1_ptr_read(emu, 90U, 0U);
#line 66
    voice = 0;
    }
#line 66
    goto ldv_30214;
    ldv_30213: ;
#line 67
    if (voice == 32) {
      {
#line 68
      val = snd_emu10k1_ptr_read(emu, 91U, 0U);
      }
    } else {

    }
#line 69
    if ((int )val & 1) {
#line 70
      if ((unsigned int )*((unsigned char *)pvoice + 12UL) != 0U && (unsigned long )pvoice->interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                                                                                    struct snd_emu10k1_voice * ))0)) {
        {
#line 71
        (*(pvoice->interrupt))(emu, pvoice);
#line 72
        snd_emu10k1_voice_intr_ack(emu, (unsigned int )voice);
        }
      } else {
        {
#line 74
        snd_emu10k1_voice_intr_disable(emu, (unsigned int )voice);
        }
      }
    } else {

    }
#line 77
    val = val >> 1;
#line 78
    pvoice = pvoice + 1;
#line 66
    voice = voice + 1;
    ldv_30214: ;
#line 66
    if (voice <= voice_max) {
#line 68
      goto ldv_30213;
    } else {

    }
    {
#line 80
    val = snd_emu10k1_ptr_read(emu, 104U, 0U);
#line 81
    voice = 0;
    }
#line 81
    goto ldv_30217;
    ldv_30216: ;
#line 82
    if (voice == 32) {
      {
#line 83
      val = snd_emu10k1_ptr_read(emu, 105U, 0U);
      }
    } else {

    }
#line 84
    if ((int )val & 1) {
#line 85
      if ((unsigned int )*((unsigned char *)pvoice + 12UL) != 0U && (unsigned long )pvoice->interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                                                                                    struct snd_emu10k1_voice * ))0)) {
        {
#line 86
        (*(pvoice->interrupt))(emu, pvoice);
#line 87
        snd_emu10k1_voice_half_loop_intr_ack(emu, (unsigned int )voice);
        }
      } else {
        {
#line 89
        snd_emu10k1_voice_half_loop_intr_disable(emu, (unsigned int )voice);
        }
      }
    } else {

    }
#line 92
    val = val >> 1;
#line 93
    pvoice = pvoice + 1;
#line 81
    voice = voice + 1;
    ldv_30217: ;
#line 81
    if (voice <= voice_max) {
#line 83
      goto ldv_30216;
    } else {

    }
#line 95
    status = status & 4294967231U;
  } else {

  }
#line 97
  status = status & 4294967232U;
#line 98
  if ((status & 49152U) != 0U) {
#line 99
    if ((unsigned long )emu->capture_interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                             unsigned int  ))0)) {
      {
#line 100
      (*(emu->capture_interrupt))(emu, status);
      }
    } else {
      {
#line 102
      snd_emu10k1_intr_disable(emu, 64U);
      }
    }
#line 103
    status = status & 4294918143U;
  } else {

  }
#line 105
  if ((status & 196608U) != 0U) {
#line 106
    if ((unsigned long )emu->capture_mic_interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                                 unsigned int  ))0)) {
      {
#line 107
      (*(emu->capture_mic_interrupt))(emu, status);
      }
    } else {
      {
#line 109
      snd_emu10k1_intr_disable(emu, 128U);
      }
    }
#line 110
    status = status & 4294770687U;
  } else {

  }
#line 112
  if ((status & 12288U) != 0U) {
#line 113
    if ((unsigned long )emu->capture_efx_interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                                 unsigned int  ))0)) {
      {
#line 114
      (*(emu->capture_efx_interrupt))(emu, status);
      }
    } else {
      {
#line 116
      snd_emu10k1_intr_disable(emu, 32U);
      }
    }
#line 117
    status = status & 4294955007U;
  } else {

  }
#line 119
  if ((status & 384U) != 0U) {
#line 120
    if ((unsigned long )emu->midi.interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                          unsigned int  ))0)) {
      {
#line 121
      (*(emu->midi.interrupt))(emu, status);
      }
    } else {
      {
#line 123
      snd_emu10k1_intr_disable(emu, 3U);
      }
    }
#line 124
    status = status & 4294966911U;
  } else {

  }
#line 126
  if ((status & 402653184U) != 0U) {
#line 127
    if ((unsigned long )emu->midi2.interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                           unsigned int  ))0)) {
      {
#line 128
      (*(emu->midi2.interrupt))(emu, status);
      }
    } else {
      {
#line 130
      snd_emu10k1_intr_disable(emu, 196608U);
      }
    }
#line 131
    status = status & 3892314111U;
  } else {

  }
#line 133
  if ((status & 512U) != 0U) {
#line 134
    if ((unsigned long )emu->timer != (unsigned long )((struct snd_timer *)0)) {
      {
#line 135
      snd_timer_interrupt(emu->timer, (emu->timer)->sticks);
      }
    } else {
      {
#line 137
      snd_emu10k1_intr_disable(emu, 4U);
      }
    }
#line 138
    status = status & 4294966783U;
  } else {

  }
#line 140
  if ((status & 3072U) != 0U) {
#line 141
    if ((unsigned long )emu->spdif_interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ,
                                                                           unsigned int  ))0)) {
      {
#line 142
      (*(emu->spdif_interrupt))(emu, status);
      }
    } else {
      {
#line 144
      snd_emu10k1_intr_disable(emu, 24U);
      }
    }
#line 145
    status = status & 4294964223U;
  } else {

  }
#line 147
  if ((status & 8388608U) != 0U) {
#line 148
    if ((unsigned long )emu->dsp_interrupt != (unsigned long )((void (*)(struct snd_emu10k1 * ))0)) {
      {
#line 149
      (*(emu->dsp_interrupt))(emu);
      }
    } else {
      {
#line 151
      snd_emu10k1_intr_disable(emu, 4096U);
      }
    }
#line 152
    status = status & 4286578687U;
  } else {

  }
#line 154
  if ((int )status < 0) {
#line 155
    goto ldv_30223;
    ldv_30222: 
#line 156
    mask = 4096U;
#line 157
    pvoice___0 = (struct snd_emu10k1_voice *)(& emu->p16v_voices);
#line 158
    cvoice = & emu->p16v_capture_voice;
#line 161
    orig_status2 = status2;
#line 162
    if ((status2 & mask) != 0U) {
#line 163
      if ((unsigned int )*((unsigned char *)pvoice___0 + 12UL) != 0U) {
        {
#line 164
        snd_pcm_period_elapsed((pvoice___0->epcm)->substream);
        }
      } else {
        {
#line 166
        __snd_printk(0U, "sound/pci/emu10k1/irq.c", 166, "<3>p16v: status: 0x%08x, mask=0x%08x, pvoice=%p, use=%d\n",
                     status2, mask, pvoice___0, (int )pvoice___0->use);
        }
      }
    } else {

    }
#line 169
    if ((status2 & 1114112U) != 0U) {
#line 171
      if ((unsigned int )*((unsigned char *)cvoice + 12UL) != 0U) {
        {
#line 173
        snd_pcm_period_elapsed((cvoice->epcm)->substream);
        }
      } else {

      }
    } else {

    }
    {
#line 176
    outl(orig_status2, (int )((unsigned int )emu->port + 40U));
    }
    ldv_30223: 
    {
#line 155
    status2 = inl((int )((unsigned int )emu->port + 40U));
    }
#line 155
    if (status2 != 0U) {
#line 157
      goto ldv_30222;
    } else {

    }
#line 178
    status = status & 2147483647U;
  } else {

  }
#line 181
  if (status != 0U) {
    {
#line 183
    __snd_printk(0U, "sound/pci/emu10k1/irq.c", 183, "<3>emu10k1: unhandled interrupt: 0x%08x\n",
                 status);
#line 185
    bits = 8191U;
    }
#line 198
    if (emu->audigy != 0U) {
#line 199
      bits = bits | 196608U;
    } else {

    }
    {
#line 200
    snd_emu10k1_intr_disable(emu, bits);
    }
  } else {

  }
  {
#line 202
  outl(orig_status, (int )((unsigned int )emu->port + 8U));
  }
  ldv_30227: 
  {
#line 39
  status = inl((int )((unsigned int )emu->port + 8U));
  }
#line 39
  if (status != 0U && timeout <= 999) {
#line 41
    goto ldv_30226;
  } else {

  }
  ldv_30208: ;
#line 204
  if (timeout == 1000) {
    {
#line 205
    __snd_printk(0U, "sound/pci/emu10k1/irq.c", 205, "<6>emu10k1 irq routine failure\n");
    }
  } else {

  }
#line 207
  return (handled != 0);
}
}
#line 1 "<compiler builtins>"
unsigned long __builtin_object_size(void * , int  ) ;
#line 47 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 76
  __list_add(new, head->prev, head);
  }
#line 77
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 192 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kernel.h"
extern void might_fault(void) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_memory.c.aux"
static void ldv___ldv_spin_lock_33___1(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_36(spinlock_t *ldv_func_arg1 ) ;
#line 109
void ldv_spin_lock_memblk_lock_of_snd_emu10k1(void) ;
#line 110
void ldv_spin_unlock_memblk_lock_of_snd_emu10k1(void) ;
#line 390 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_34___1(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34___1(spinlock_t *lock , unsigned long flags ) ;
#line 398
__inline static void ldv_spin_unlock_irqrestore_34___1(spinlock_t *lock , unsigned long flags ) ;
#line 134 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 169
extern void mutex_unlock(struct mutex * ) ;
#line 322 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 325 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
  {
#line 327
  tmp = alloc_pages_current(gfp_mask, order);
  }
#line 327
  return (tmp);
}
}
#line 358
extern void __free_pages(struct page * , unsigned int  ) ;
#line 359
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 736 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 738
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 42 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 50
  tmp = __builtin_object_size((void const   *)to, 0);
#line 50
  sz = (int )tmp;
#line 52
  might_fault();
#line 53
  tmp___1 = __builtin_expect(sz == -1, 1L);
  }
#line 53
  if (tmp___1 != 0L) {
    {
#line 54
    n = _copy_from_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 53
    tmp___2 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 53
    if (tmp___2 != 0L) {
      {
#line 54
      n = _copy_from_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 57
      __ret_warn_on = 1;
#line 57
      tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
      }
#line 57
      if (tmp___0 != 0L) {
        {
#line 57
        warn_slowpath_fmt("/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/uaccess_64.h",
                          57, "Buffer overflow detected!\n");
        }
      } else {

      }
      {
#line 57
      __builtin_expect(__ret_warn_on != 0, 0L);
      }
    }
  }
#line 59
  return (n);
}
}
#line 101 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/memalloc.h"
__inline static dma_addr_t snd_sgbuf_get_addr(struct snd_sg_buf *sgbuf , size_t offset ) 
{ 
  dma_addr_t addr ;

  {
#line 103
  addr = (sgbuf->table + (offset >> 12))->addr;
#line 104
  addr = addr & 0xfffffffffffff000ULL;
#line 105
  return (addr + ((unsigned long long )offset & 4095ULL));
}
}
#line 987 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static dma_addr_t snd_pcm_sgbuf_get_addr(struct snd_pcm_substream *substream ,
                                                  unsigned int ofs ) 
{ 
  struct snd_sg_buf *sg ;
  dma_addr_t tmp ;

  {
  {
#line 989
  sg = (struct snd_sg_buf *)((substream->runtime)->dma_buffer_p)->private_data;
#line 990
  tmp = snd_sgbuf_get_addr(sg, (size_t )ofs);
  }
#line 990
  return (tmp);
}
}
#line 58 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/util_mem.h"
extern struct snd_util_memblk *__snd_util_mem_alloc(struct snd_util_memhdr * , int  ) ;
#line 59
extern void __snd_util_mem_free(struct snd_util_memhdr * , struct snd_util_memblk * ) ;
#line 60
extern struct snd_util_memblk *__snd_util_memblk_new(struct snd_util_memhdr * , unsigned int  ,
                                                     struct list_head * ) ;
#line 1874 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
struct snd_util_memblk *snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu , struct snd_pcm_substream *substream ) ;
#line 1875
int snd_emu10k1_free_pages(struct snd_emu10k1 *emu , struct snd_util_memblk *blk ) ;
#line 76 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int synth_alloc_pages(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) ;
#line 77
static int synth_free_pages(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) ;
#line 83 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static void emu10k1_memblk_init(struct snd_emu10k1_memblk *blk ) 
{ 


  {
  {
#line 85
  blk->mapped_page = -1;
#line 86
  INIT_LIST_HEAD(& blk->mapped_link);
#line 87
  INIT_LIST_HEAD(& blk->mapped_order_link);
#line 88
  blk->map_locked = 0U;
#line 90
  blk->first_page = (int )(blk->mem.offset >> 12);
#line 91
  blk->last_page = (int )(((blk->mem.offset + blk->mem.size) - 1U) >> 12);
#line 92
  blk->pages = (blk->last_page - blk->first_page) + 1;
  }
#line 93
  return;
}
}
#line 102 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int search_empty_map_area(struct snd_emu10k1 *emu , int npages , struct list_head **nextp ) 
{ 
  int page ;
  int found_page ;
  int max_size ;
  int size ;
  struct list_head *candidate ;
  struct list_head *pos ;
  struct snd_emu10k1_memblk *blk ;
  struct list_head  const  *__mptr ;

  {
#line 104
  page = 0;
#line 104
  found_page = -12;
#line 105
  max_size = npages;
#line 107
  candidate = & emu->mapped_link_head;
#line 110
  pos = emu->mapped_link_head.next;
#line 110
  goto ldv_30258;
  ldv_30257: 
#line 111
  __mptr = (struct list_head  const  *)pos;
#line 111
  blk = (struct snd_emu10k1_memblk *)((char *)__mptr + 0xffffffffffffffd0UL);
#line 112
  if (blk->mapped_page < 0) {
#line 113
    goto ldv_30256;
  } else {

  }
#line 114
  size = blk->mapped_page - page;
#line 115
  if (size == npages) {
#line 116
    *nextp = pos;
#line 117
    return (page);
  } else
#line 119
  if (size > max_size) {
#line 121
    max_size = size;
#line 122
    candidate = pos;
#line 123
    found_page = page;
  } else {

  }
#line 125
  page = blk->mapped_page + blk->pages;
  ldv_30256: 
#line 110
  pos = pos->next;
  ldv_30258: ;
#line 110
  if ((unsigned long )pos != (unsigned long )(& emu->mapped_link_head)) {
#line 112
    goto ldv_30257;
  } else {

  }
#line 127
  size = (int )(8192U - (unsigned int )page);
#line 128
  if (size >= max_size) {
#line 129
    *nextp = pos;
#line 130
    return (page);
  } else {

  }
#line 132
  *nextp = candidate;
#line 133
  return (found_page);
}
}
#line 141 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int map_memblk(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) 
{ 
  int page ;
  int pg ;
  struct list_head *next ;

  {
  {
#line 146
  page = search_empty_map_area(emu, blk->pages, & next);
  }
#line 147
  if (page < 0) {
#line 148
    return (page);
  } else {

  }
  {
#line 150
  list_add_tail(& blk->mapped_link, next);
#line 152
  list_add_tail(& blk->mapped_order_link, & emu->mapped_order_link_head);
#line 153
  blk->mapped_page = page;
#line 155
  pg = blk->first_page;
  }
#line 155
  goto ldv_30268;
  ldv_30267: 
#line 156
  *((u32 *)emu->ptb_pages.area + (unsigned long )page) = ((unsigned int )*(emu->page_addr_table + (unsigned long )pg) << 1U) | (unsigned int )page;
#line 157
  page = page + 1;
#line 155
  pg = pg + 1;
  ldv_30268: ;
#line 155
  if (pg <= blk->last_page) {
#line 157
    goto ldv_30267;
  } else {

  }

#line 159
  return (0);
}
}
#line 168 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int unmap_memblk(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) 
{ 
  int start_page ;
  int end_page ;
  int mpage ;
  int pg ;
  struct list_head *p ;
  struct snd_emu10k1_memblk *q ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 175
  p = blk->mapped_link.prev;
#line 175
  if ((unsigned long )p != (unsigned long )(& emu->mapped_link_head)) {
#line 176
    __mptr = (struct list_head  const  *)p;
#line 176
    q = (struct snd_emu10k1_memblk *)((char *)__mptr + 0xffffffffffffffd0UL);
#line 177
    start_page = q->mapped_page + q->pages;
  } else {
#line 179
    start_page = 0;
  }
#line 180
  p = blk->mapped_link.next;
#line 180
  if ((unsigned long )p != (unsigned long )(& emu->mapped_link_head)) {
#line 181
    __mptr___0 = (struct list_head  const  *)p;
#line 181
    q = (struct snd_emu10k1_memblk *)((char *)__mptr___0 + 0xffffffffffffffd0UL);
#line 182
    end_page = q->mapped_page;
  } else {
#line 184
    end_page = 8192;
  }
  {
#line 187
  list_del(& blk->mapped_link);
#line 188
  list_del(& blk->mapped_order_link);
#line 190
  mpage = blk->mapped_page;
#line 191
  pg = blk->first_page;
  }
#line 191
  goto ldv_30285;
  ldv_30284: 
#line 192
  *((u32 *)emu->ptb_pages.area + (unsigned long )mpage) = ((unsigned int )emu->silent_page.addr << 1U) | (unsigned int )mpage;
#line 193
  mpage = mpage + 1;
#line 191
  pg = pg + 1;
  ldv_30285: ;
#line 191
  if (pg <= blk->last_page) {
#line 193
    goto ldv_30284;
  } else {

  }
#line 195
  blk->mapped_page = -1;
#line 196
  return (end_page - start_page);
}
}
#line 205 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static struct snd_emu10k1_memblk *search_empty(struct snd_emu10k1 *emu , int size ) 
{ 
  struct list_head *p ;
  struct snd_emu10k1_memblk *blk ;
  int page ;
  int psize ;
  struct list_head  const  *__mptr ;
  struct snd_util_memblk *tmp ;

  {
#line 211
  psize = (int )(((unsigned long )size + 4095UL) >> 12);
#line 212
  page = 0;
#line 213
  p = (emu->memhdr)->block.next;
#line 213
  goto ldv_30299;
  ldv_30298: 
#line 214
  __mptr = (struct list_head  const  *)p;
#line 214
  blk = (struct snd_emu10k1_memblk *)((char *)__mptr + 0xfffffffffffffff8UL);
#line 215
  if (page + psize <= blk->first_page) {
#line 216
    goto __found_pages;
  } else {

  }
#line 217
  page = blk->last_page + 1;
#line 213
  p = p->next;
  ldv_30299: ;
#line 213
  if ((unsigned long )p != (unsigned long )(& (emu->memhdr)->block)) {
#line 215
    goto ldv_30298;
  } else {

  }

#line 219
  if (page + psize > emu->max_cache_pages) {
#line 220
    return ((struct snd_emu10k1_memblk *)0);
  } else {

  }
  __found_pages: 
  {
#line 224
  tmp = __snd_util_memblk_new(emu->memhdr, (unsigned int )(psize << 12), p->prev);
#line 224
  blk = (struct snd_emu10k1_memblk *)tmp;
  }
#line 225
  if ((unsigned long )blk == (unsigned long )((struct snd_emu10k1_memblk *)0)) {
#line 226
    return ((struct snd_emu10k1_memblk *)0);
  } else {

  }
  {
#line 227
  blk->mem.offset = (unsigned int )(page << 12);
#line 228
  emu10k1_memblk_init(blk);
  }
#line 229
  return (blk);
}
}
#line 236 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int is_valid_page(struct snd_emu10k1 *emu , dma_addr_t addr ) 
{ 


  {
#line 238
  if ((addr & (unsigned long long )(~ emu->dma_mask)) != 0ULL) {
    {
#line 239
    __snd_printk(0U, "sound/pci/emu10k1/memory.c", 239, "<3>max memory size is 0x%lx (addr = 0x%lx)!!\n",
                 emu->dma_mask, (unsigned long )addr);
    }
#line 240
    return (0);
  } else {

  }
#line 242
  if ((addr & 4095ULL) != 0ULL) {
    {
#line 243
    __snd_printk(0U, "sound/pci/emu10k1/memory.c", 243, "<3>page is not aligned\n");
    }
#line 244
    return (0);
  } else {

  }
#line 246
  return (1);
}
}
#line 255 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
int snd_emu10k1_memblk_map(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) 
{ 
  int err ;
  int size ;
  struct list_head *p ;
  struct list_head *nextp ;
  struct snd_emu10k1_memblk *deleted ;
  unsigned long flags ;
  struct list_head  const  *__mptr ;

  {
  {
#line 263
  ldv___ldv_spin_lock_33___1(& emu->memblk_lock);
  }
#line 264
  if (blk->mapped_page >= 0) {
    {
#line 266
    list_del(& blk->mapped_order_link);
#line 267
    list_add_tail(& blk->mapped_order_link, & emu->mapped_order_link_head);
#line 268
    ldv_spin_unlock_irqrestore_34___1(& emu->memblk_lock, flags);
    }
#line 269
    return (0);
  } else {

  }
  {
#line 271
  err = map_memblk(emu, blk);
  }
#line 271
  if (err < 0) {
#line 274
    p = emu->mapped_order_link_head.next;
#line 275
    goto ldv_30320;
    ldv_30319: 
#line 276
    nextp = p->next;
#line 277
    __mptr = (struct list_head  const  *)p;
#line 277
    deleted = (struct snd_emu10k1_memblk *)((char *)__mptr + 0xffffffffffffffc0UL);
#line 278
    if (deleted->map_locked != 0U) {
#line 279
      goto ldv_30317;
    } else {

    }
    {
#line 280
    size = unmap_memblk(emu, deleted);
    }
#line 281
    if (size >= blk->pages) {
      {
#line 283
      err = map_memblk(emu, blk);
      }
#line 284
      goto ldv_30318;
    } else {

    }
    ldv_30317: 
#line 275
    p = nextp;
    ldv_30320: ;
#line 275
    if ((unsigned long )p != (unsigned long )(& emu->mapped_order_link_head)) {
#line 277
      goto ldv_30319;
    } else {

    }
    ldv_30318: ;
  } else {

  }
  {
#line 288
  ldv_spin_unlock_irqrestore_34___1(& emu->memblk_lock, flags);
  }
#line 289
  return (err);
}
}
#line 298 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
struct snd_util_memblk *snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu , struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  struct snd_util_memhdr *hdr ;
  struct snd_emu10k1_memblk *blk ;
  int page ;
  int err ;
  int idx ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___1 ;
  long tmp___3 ;
  long tmp___4 ;
  unsigned long ofs ;
  dma_addr_t addr ;
  int tmp___5 ;

  {
  {
#line 300
  runtime = substream->runtime;
#line 305
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 305
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 305
  if (tmp != 0L) {
    {
#line 305
    warn_slowpath_fmt("sound/pci/emu10k1/memory.c", 305, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 305
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 305
  if (tmp___0 != 0L) {
#line 306
    return ((struct snd_util_memblk *)0);
  } else {

  }
  {
#line 307
  __ret_warn_on___0 = runtime->dma_bytes - 1UL > 33554430UL;
#line 307
  tmp___1 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 307
  if (tmp___1 != 0L) {
    {
#line 307
    warn_slowpath_fmt("sound/pci/emu10k1/memory.c", 308, "BUG? (%s)\n", (char *)"runtime->dma_bytes <= 0 || runtime->dma_bytes >= 8192 * 4096");
    }
  } else {

  }
  {
#line 307
  tmp___2 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 307
  if (tmp___2 != 0L) {
#line 309
    return ((struct snd_util_memblk *)0);
  } else {

  }
  {
#line 310
  hdr = emu->memhdr;
#line 311
  __ret_warn_on___1 = (unsigned long )hdr == (unsigned long )((struct snd_util_memhdr *)0);
#line 311
  tmp___3 = __builtin_expect(__ret_warn_on___1 != 0, 0L);
  }
#line 311
  if (tmp___3 != 0L) {
    {
#line 311
    warn_slowpath_fmt("sound/pci/emu10k1/memory.c", 311, "BUG? (%s)\n", (char *)"!hdr");
    }
  } else {

  }
  {
#line 311
  tmp___4 = __builtin_expect(__ret_warn_on___1 != 0, 0L);
  }
#line 311
  if (tmp___4 != 0L) {
#line 312
    return ((struct snd_util_memblk *)0);
  } else {

  }
  {
#line 314
  idx = runtime->period_size >= runtime->buffer_size ? (int )(emu->delay_pcm_irq * 2U) : 0;
#line 316
  mutex_lock_nested(& hdr->block_mutex, 0U);
#line 317
  blk = search_empty(emu, (int )((unsigned int )runtime->dma_bytes + (unsigned int )idx));
  }
#line 318
  if ((unsigned long )blk == (unsigned long )((struct snd_emu10k1_memblk *)0)) {
    {
#line 319
    mutex_unlock(& hdr->block_mutex);
    }
#line 320
    return ((struct snd_util_memblk *)0);
  } else {

  }
#line 325
  idx = 0;
#line 326
  page = blk->first_page;
#line 326
  goto ldv_30347;
  ldv_30346: 
  {
#line 327
  ofs = (unsigned long )(idx << 12);
#line 329
  addr = snd_pcm_sgbuf_get_addr(substream, (unsigned int )ofs);
#line 330
  tmp___5 = is_valid_page(emu, addr);
  }
#line 330
  if (tmp___5 == 0) {
    {
#line 331
    printk("<3>emu: failure page = %d\n", idx);
#line 332
    mutex_unlock(& hdr->block_mutex);
    }
#line 333
    return ((struct snd_util_memblk *)0);
  } else {

  }
#line 335
  *(emu->page_addr_table + (unsigned long )page) = (unsigned long )addr;
#line 336
  *(emu->page_ptr_table + (unsigned long )page) = (void *)0;
#line 326
  page = page + 1;
#line 326
  idx = idx + 1;
  ldv_30347: ;
#line 326
  if (page <= blk->last_page) {
#line 328
    goto ldv_30346;
  } else {

  }
  {
#line 340
  blk->map_locked = 1U;
#line 341
  err = snd_emu10k1_memblk_map(emu, blk);
  }
#line 342
  if (err < 0) {
    {
#line 343
    __snd_util_mem_free(hdr, (struct snd_util_memblk *)blk);
#line 344
    mutex_unlock(& hdr->block_mutex);
    }
#line 345
    return ((struct snd_util_memblk *)0);
  } else {

  }
  {
#line 347
  mutex_unlock(& hdr->block_mutex);
  }
#line 348
  return ((struct snd_util_memblk *)blk);
}
}
#line 355 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
int snd_emu10k1_free_pages(struct snd_emu10k1 *emu , struct snd_util_memblk *blk ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 357
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0) || (unsigned long )blk == (unsigned long )((struct snd_util_memblk *)0);
#line 357
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 357
  if (tmp != 0L) {
    {
#line 357
    warn_slowpath_fmt("sound/pci/emu10k1/memory.c", 357, "BUG? (%s)\n", (char *)"!emu || !blk");
    }
  } else {

  }
  {
#line 357
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 357
  if (tmp___0 != 0L) {
#line 358
    return (-22);
  } else {

  }
  {
#line 359
  tmp___1 = snd_emu10k1_synth_free(emu, blk);
  }
#line 359
  return (tmp___1);
}
}
#line 372 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
struct snd_util_memblk *snd_emu10k1_synth_alloc(struct snd_emu10k1 *hw , unsigned int size ) 
{ 
  struct snd_emu10k1_memblk *blk ;
  struct snd_util_memhdr *hdr ;
  struct snd_util_memblk *tmp ;
  int tmp___0 ;

  {
  {
#line 375
  hdr = hw->memhdr;
#line 377
  mutex_lock_nested(& hdr->block_mutex, 0U);
#line 378
  tmp = __snd_util_mem_alloc(hdr, (int )size);
#line 378
  blk = (struct snd_emu10k1_memblk *)tmp;
  }
#line 379
  if ((unsigned long )blk == (unsigned long )((struct snd_emu10k1_memblk *)0)) {
    {
#line 380
    mutex_unlock(& hdr->block_mutex);
    }
#line 381
    return ((struct snd_util_memblk *)0);
  } else {

  }
  {
#line 383
  tmp___0 = synth_alloc_pages(hw, blk);
  }
#line 383
  if (tmp___0 != 0) {
    {
#line 384
    __snd_util_mem_free(hdr, (struct snd_util_memblk *)blk);
#line 385
    mutex_unlock(& hdr->block_mutex);
    }
#line 386
    return ((struct snd_util_memblk *)0);
  } else {

  }
  {
#line 388
  snd_emu10k1_memblk_map(hw, blk);
#line 389
  mutex_unlock(& hdr->block_mutex);
  }
#line 390
  return ((struct snd_util_memblk *)blk);
}
}
#line 399 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
int snd_emu10k1_synth_free(struct snd_emu10k1 *emu , struct snd_util_memblk *memblk ) 
{ 
  struct snd_util_memhdr *hdr ;
  struct snd_emu10k1_memblk *blk ;
  unsigned long flags ;

  {
  {
#line 401
  hdr = emu->memhdr;
#line 402
  blk = (struct snd_emu10k1_memblk *)memblk;
#line 405
  mutex_lock_nested(& hdr->block_mutex, 0U);
#line 406
  ldv___ldv_spin_lock_36(& emu->memblk_lock);
  }
#line 407
  if (blk->mapped_page >= 0) {
    {
#line 408
    unmap_memblk(emu, blk);
    }
  } else {

  }
  {
#line 409
  ldv_spin_unlock_irqrestore_34___1(& emu->memblk_lock, flags);
#line 410
  synth_free_pages(emu, blk);
#line 411
  __snd_util_mem_free(hdr, memblk);
#line 412
  mutex_unlock(& hdr->block_mutex);
  }
#line 413
  return (0);
}
}
#line 419 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static void get_single_page_range(struct snd_util_memhdr *hdr , struct snd_emu10k1_memblk *blk ,
                                  int *first_page_ret , int *last_page_ret ) 
{ 
  struct list_head *p ;
  struct snd_emu10k1_memblk *q ;
  int first_page ;
  int last_page ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 426
  first_page = blk->first_page;
#line 427
  p = blk->mem.list.prev;
#line 427
  if ((unsigned long )p != (unsigned long )(& hdr->block)) {
#line 428
    __mptr = (struct list_head  const  *)p;
#line 428
    q = (struct snd_emu10k1_memblk *)((char *)__mptr + 0xfffffffffffffff8UL);
#line 429
    if (q->last_page == first_page) {
#line 430
      first_page = first_page + 1;
    } else {

    }
  } else {

  }
#line 432
  last_page = blk->last_page;
#line 433
  p = blk->mem.list.next;
#line 433
  if ((unsigned long )p != (unsigned long )(& hdr->block)) {
#line 434
    __mptr___0 = (struct list_head  const  *)p;
#line 434
    q = (struct snd_emu10k1_memblk *)((char *)__mptr___0 + 0xfffffffffffffff8UL);
#line 435
    if (q->first_page == last_page) {
#line 436
      last_page = last_page - 1;
    } else {

    }
  } else {

  }
#line 438
  *first_page_ret = first_page;
#line 439
  *last_page_ret = last_page;
#line 440
  return;
}
}
#line 443 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static void __synth_free_pages(struct snd_emu10k1 *emu , int first_page , int last_page ) 
{ 
  int page ;

  {
#line 448
  page = first_page;
#line 448
  goto ldv_30403;
  ldv_30402: 
  {
#line 449
  free_pages((unsigned long )*(emu->page_ptr_table + (unsigned long )page), 0U);
#line 450
  *(emu->page_addr_table + (unsigned long )page) = 0UL;
#line 451
  *(emu->page_ptr_table + (unsigned long )page) = (void *)0;
#line 448
  page = page + 1;
  }
  ldv_30403: ;
#line 448
  if (page <= last_page) {
#line 450
    goto ldv_30402;
  } else {

  }

#line 455
  return;
}
}
#line 458 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int synth_alloc_pages(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) 
{ 
  int page ;
  int first_page ;
  int last_page ;
  struct page *p ;
  struct page *tmp ;

  {
  {
#line 462
  emu10k1_memblk_init(blk);
#line 463
  get_single_page_range(emu->memhdr, blk, & first_page, & last_page);
#line 465
  page = first_page;
  }
#line 465
  goto ldv_30414;
  ldv_30413: 
  {
#line 467
  tmp = alloc_pages(724U, 0U);
#line 467
  p = tmp;
  }
#line 469
  if ((unsigned long )p == (unsigned long )((struct page *)0) || ((unsigned long )(((long )p + 24189255811072L) / 64L) & ~ (emu->dma_mask >> 12)) != 0UL) {
#line 470
    if ((unsigned long )p != (unsigned long )((struct page *)0)) {
      {
#line 471
      __free_pages(p, 0U);
      }
    } else {

    }
    {
#line 473
    p = alloc_pages(4641U, 0U);
    }
  } else {

  }
#line 477
  if ((unsigned long )p == (unsigned long )((struct page *)0)) {
    {
#line 478
    __synth_free_pages(emu, first_page, page + -1);
    }
#line 479
    return (-12);
  } else {

  }
  {
#line 481
  *(emu->page_addr_table + (unsigned long )page) = (unsigned long )((unsigned long long )(((long )p + 24189255811072L) / 64L) << 12);
#line 482
  *(emu->page_ptr_table + (unsigned long )page) = lowmem_page_address((struct page  const  *)p);
#line 465
  page = page + 1;
  }
  ldv_30414: ;
#line 465
  if (page <= last_page) {
#line 467
    goto ldv_30413;
  } else {

  }

#line 484
  return (0);
}
}
#line 490 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
static int synth_free_pages(struct snd_emu10k1 *emu , struct snd_emu10k1_memblk *blk ) 
{ 
  int first_page ;
  int last_page ;

  {
  {
#line 494
  get_single_page_range(emu->memhdr, blk, & first_page, & last_page);
#line 495
  __synth_free_pages(emu, first_page, last_page);
  }
#line 496
  return (0);
}
}
#line 500 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
__inline static void *offset_ptr(struct snd_emu10k1 *emu , int page , int offset ) 
{ 
  char *ptr ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 503
  __ret_warn_on = page < 0 || page >= emu->max_cache_pages;
#line 503
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 503
  if (tmp != 0L) {
    {
#line 503
    warn_slowpath_fmt("sound/pci/emu10k1/memory.c", 503, "BUG? (%s)\n", (char *)"page < 0 || page >= emu->max_cache_pages");
    }
  } else {

  }
  {
#line 503
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 503
  if (tmp___0 != 0L) {
#line 504
    return ((void *)0);
  } else {

  }
#line 505
  ptr = (char *)*(emu->page_ptr_table + (unsigned long )page);
#line 506
  if ((unsigned long )ptr == (unsigned long )((char *)0)) {
    {
#line 507
    printk("<3>emu10k1: access to NULL ptr: page = %d\n", page);
    }
#line 508
    return ((void *)0);
  } else {

  }
#line 510
  ptr = ptr + ((unsigned long )offset & 4095UL);
#line 511
  return ((void *)ptr);
}
}
#line 517 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
int snd_emu10k1_synth_bzero(struct snd_emu10k1 *emu , struct snd_util_memblk *blk ,
                            int offset , int size ) 
{ 
  int page ;
  int nextofs ;
  int end_offset ;
  int temp ;
  int temp1 ;
  void *ptr ;
  struct snd_emu10k1_memblk *p ;

  {
#line 522
  p = (struct snd_emu10k1_memblk *)blk;
#line 524
  offset = (int )((unsigned int )offset + (blk->offset & 4095U));
#line 525
  end_offset = offset + size;
#line 526
  page = offset >> 12;
  ldv_30443: 
#line 528
  nextofs = (page + 1) << 12;
#line 529
  temp = nextofs - offset;
#line 530
  temp1 = end_offset - offset;
#line 531
  if (temp1 < temp) {
#line 532
    temp = temp1;
  } else {

  }
  {
#line 533
  ptr = offset_ptr(emu, page + p->first_page, offset);
  }
#line 534
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 535
    memset(ptr, 0, (size_t )temp);
    }
  } else {

  }
#line 536
  offset = nextofs;
#line 537
  page = page + 1;
#line 538
  if (offset < end_offset) {
#line 540
    goto ldv_30443;
  } else {

  }

#line 539
  return (0);
}
}
#line 547 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/memory.c"
int snd_emu10k1_synth_copy_from_user(struct snd_emu10k1 *emu , struct snd_util_memblk *blk ,
                                     int offset , char const   *data , int size ) 
{ 
  int page ;
  int nextofs ;
  int end_offset ;
  int temp ;
  int temp1 ;
  void *ptr ;
  struct snd_emu10k1_memblk *p ;
  unsigned long tmp ;

  {
#line 552
  p = (struct snd_emu10k1_memblk *)blk;
#line 554
  offset = (int )((unsigned int )offset + (blk->offset & 4095U));
#line 555
  end_offset = offset + size;
#line 556
  page = offset >> 12;
  ldv_30468: 
#line 558
  nextofs = (page + 1) << 12;
#line 559
  temp = nextofs - offset;
#line 560
  temp1 = end_offset - offset;
#line 561
  if (temp1 < temp) {
#line 562
    temp = temp1;
  } else {

  }
  {
#line 563
  ptr = offset_ptr(emu, page + p->first_page, offset);
  }
#line 564
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 564
    tmp = copy_from_user(ptr, (void const   *)data, (unsigned long )temp);
    }
#line 564
    if (tmp != 0UL) {
#line 565
      return (-14);
    } else {

    }
  } else {

  }
#line 566
  offset = nextofs;
#line 567
  data = data + (unsigned long )temp;
#line 568
  page = page + 1;
#line 569
  if (offset < end_offset) {
#line 571
    goto ldv_30468;
  } else {

  }

#line 570
  return (0);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_memory.c.aux"
static void ldv___ldv_spin_lock_33___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_memblk_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 488 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_memory.c.aux"
__inline static void ldv_spin_unlock_irqrestore_34___1(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 491
  ldv_spin_unlock_memblk_lock_of_snd_emu10k1();
#line 493
  spin_unlock_irqrestore(lock, flags);
  }
#line 494
  return;
}
}
#line 506 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_memory.c.aux"
static void ldv___ldv_spin_lock_36(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 509
  ldv_spin_lock_memblk_lock_of_snd_emu10k1();
#line 511
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 512
  return;
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_voice.c.aux"
static void ldv___ldv_spin_lock_33___2(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___0(spinlock_t *ldv_func_arg1 ) ;
#line 390 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_34(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34(spinlock_t *lock , unsigned long flags ) ;
#line 48 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/voice.c"
static int voice_alloc(struct snd_emu10k1 *emu , int type , int number , struct snd_emu10k1_voice **rvoice ) 
{ 
  struct snd_emu10k1_voice *voice ;
  int i ;
  int j ;
  int k ;
  int first_voice ;
  int last_voice ;
  int skip ;

  {
#line 54
  *rvoice = (struct snd_emu10k1_voice *)0;
#line 55
  last_voice = 0;
#line 55
  first_voice = last_voice;
#line 56
  i = (int )emu->next_free_voice;
#line 56
  j = 0;
#line 56
  goto ldv_30244;
  ldv_30243: 
#line 61
  i = i % 64;
#line 64
  if (number == 2 && i & 1) {
#line 65
    i = i + 1;
#line 66
    goto ldv_30238;
  } else {

  }
#line 69
  skip = 0;
#line 70
  k = 0;
#line 70
  goto ldv_30241;
  ldv_30240: 
#line 71
  voice = (struct snd_emu10k1_voice *)(& emu->voices) + (unsigned long )((i + k) % 64);
#line 72
  if ((unsigned int )*((unsigned char *)voice + 12UL) != 0U) {
#line 73
    skip = 1;
#line 74
    goto ldv_30239;
  } else {

  }
#line 70
  k = k + 1;
  ldv_30241: ;
#line 70
  if (k < number) {
#line 72
    goto ldv_30240;
  } else {

  }
  ldv_30239: ;
#line 77
  if (skip == 0) {
#line 79
    first_voice = i;
#line 80
    last_voice = (i + number) % 64;
#line 81
    emu->next_free_voice = (unsigned int )last_voice;
#line 82
    goto ldv_30242;
  } else {

  }
  ldv_30238: 
#line 56
  i = i + number;
#line 56
  j = j + number;
  ldv_30244: ;
#line 56
  if (j <= 63) {
#line 58
    goto ldv_30243;
  } else {

  }
  ldv_30242: ;
#line 86
  if (first_voice == last_voice) {
#line 87
    return (-12);
  } else {

  }
#line 89
  i = 0;
#line 89
  goto ldv_30251;
  ldv_30250: 
#line 90
  voice = (struct snd_emu10k1_voice *)(& emu->voices) + (unsigned long )((first_voice + i) % 64);
#line 95
  voice->use = 1U;
  {
#line 97
  if (type == 1) {
#line 97
    goto case_1;
  } else {

  }
#line 100
  if (type == 2) {
#line 100
    goto case_2;
  } else {

  }
#line 103
  if (type == 3) {
#line 103
    goto case_3;
  } else {

  }
#line 106
  if (type == 0) {
#line 106
    goto case_0;
  } else {

  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
#line 98
  voice->pcm = 1U;
#line 99
  goto ldv_30246;
  case_2: /* CIL Label */ 
#line 101
  voice->synth = 1U;
#line 102
  goto ldv_30246;
  case_3: /* CIL Label */ 
#line 104
  voice->midi = 1U;
#line 105
  goto ldv_30246;
  case_0: /* CIL Label */ 
#line 107
  voice->efx = 1U;
#line 108
  goto ldv_30246;
  switch_break: /* CIL Label */ ;
  }
  ldv_30246: 
#line 89
  i = i + 1;
  ldv_30251: ;
#line 89
  if (i < number) {
#line 91
    goto ldv_30250;
  } else {

  }
#line 111
  *rvoice = (struct snd_emu10k1_voice *)(& emu->voices) + (unsigned long )first_voice;
#line 112
  return (0);
}
}
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/voice.c"
int snd_emu10k1_voice_alloc(struct snd_emu10k1 *emu , int type , int number , struct snd_emu10k1_voice **rvoice ) 
{ 
  unsigned long flags ;
  int result ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct snd_emu10k1_voice *pvoice ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
  {
#line 121
  __ret_warn_on = (unsigned long )rvoice == (unsigned long )((struct snd_emu10k1_voice **)0);
#line 121
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 121
  if (tmp != 0L) {
    {
#line 121
    warn_slowpath_fmt("sound/pci/emu10k1/voice.c", 121, "BUG? (%s)\n", (char *)"!rvoice");
    }
  } else {

  }
  {
#line 121
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 121
  if (tmp___0 != 0L) {
#line 122
    return (-22);
  } else {

  }
  {
#line 123
  __ret_warn_on___0 = number == 0;
#line 123
  tmp___1 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 123
  if (tmp___1 != 0L) {
    {
#line 123
    warn_slowpath_fmt("sound/pci/emu10k1/voice.c", 123, "BUG? (%s)\n", (char *)"!number");
    }
  } else {

  }
  {
#line 123
  tmp___2 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 123
  if (tmp___2 != 0L) {
#line 124
    return (-22);
  } else {

  }
  {
#line 126
  ldv___ldv_spin_lock_33___2(& emu->voice_lock);
  }
  ldv_30267: 
  {
#line 128
  result = voice_alloc(emu, type, number, rvoice);
  }
#line 129
  if ((result == 0 || type == 2) || type == 3) {
#line 130
    goto ldv_30265;
  } else {

  }
#line 133
  if ((unsigned long )emu->get_synth_voice != (unsigned long )((int (*)(struct snd_emu10k1 * ))0)) {
    {
#line 134
    result = (*(emu->get_synth_voice))(emu);
    }
#line 135
    if (result >= 0) {
#line 136
      pvoice = (struct snd_emu10k1_voice *)(& emu->voices) + (unsigned long )result;
#line 137
      pvoice->interrupt = (void (*)(struct snd_emu10k1 * , struct snd_emu10k1_voice * ))0;
#line 138
      tmp___6 = 0U;
#line 138
      pvoice->efx = tmp___6;
#line 138
      tmp___5 = tmp___6;
#line 138
      pvoice->midi = tmp___5;
#line 138
      tmp___4 = tmp___5;
#line 138
      pvoice->synth = tmp___4;
#line 138
      tmp___3 = tmp___4;
#line 138
      pvoice->pcm = tmp___3;
#line 138
      pvoice->use = tmp___3;
#line 139
      pvoice->epcm = (struct snd_emu10k1_pcm *)0;
    } else {

    }
  } else {

  }
#line 142
  if (result < 0) {
#line 143
    goto ldv_30265;
  } else {

  }
#line 144
  goto ldv_30267;
  ldv_30265: 
  {
#line 145
  ldv_spin_unlock_irqrestore_34(& emu->voice_lock, flags);
  }
#line 147
  return (result);
}
}
#line 152 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/voice.c"
int snd_emu10k1_voice_free(struct snd_emu10k1 *emu , struct snd_emu10k1_voice *pvoice ) 
{ 
  unsigned long flags ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 157
  __ret_warn_on = (unsigned long )pvoice == (unsigned long )((struct snd_emu10k1_voice *)0);
#line 157
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 157
  if (tmp != 0L) {
    {
#line 157
    warn_slowpath_fmt("sound/pci/emu10k1/voice.c", 157, "BUG? (%s)\n", (char *)"!pvoice");
    }
  } else {

  }
  {
#line 157
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 157
  if (tmp___0 != 0L) {
#line 158
    return (-22);
  } else {

  }
  {
#line 159
  ldv___ldv_spin_lock_35___0(& emu->voice_lock);
#line 160
  pvoice->interrupt = (void (*)(struct snd_emu10k1 * , struct snd_emu10k1_voice * ))0;
#line 161
  tmp___4 = 0U;
#line 161
  pvoice->efx = tmp___4;
#line 161
  tmp___3 = tmp___4;
#line 161
  pvoice->midi = tmp___3;
#line 161
  tmp___2 = tmp___3;
#line 161
  pvoice->synth = tmp___2;
#line 161
  tmp___1 = tmp___2;
#line 161
  pvoice->pcm = tmp___1;
#line 161
  pvoice->use = tmp___1;
#line 162
  pvoice->epcm = (struct snd_emu10k1_pcm *)0;
#line 163
  snd_emu10k1_voice_init(emu, pvoice->number);
#line 164
  ldv_spin_unlock_irqrestore_34(& emu->voice_lock, flags);
  }
#line 165
  return (0);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_voice.c.aux"
static void ldv___ldv_spin_lock_33___2(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_voice_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_voice.c.aux"
static void ldv___ldv_spin_lock_35___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_voice_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_37(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_39(spinlock_t *ldv_func_arg1 ) ;
#line 33
static void ldv___ldv_spin_lock_42(spinlock_t *ldv_func_arg1 ) ;
#line 37
static void ldv___ldv_spin_lock_45(spinlock_t *ldv_func_arg1 ) ;
#line 41
static void ldv___ldv_spin_lock_48(spinlock_t *ldv_func_arg1 ) ;
#line 45
static void ldv___ldv_spin_lock_51(spinlock_t *ldv_func_arg1 ) ;
#line 93
void ldv_spin_lock_input_lock_of_snd_emu10k1_midi(void) ;
#line 94
void ldv_spin_unlock_input_lock_of_snd_emu10k1_midi(void) ;
#line 141
void ldv_spin_lock_open_lock_of_snd_emu10k1_midi(void) ;
#line 142
void ldv_spin_unlock_open_lock_of_snd_emu10k1_midi(void) ;
#line 149
void ldv_spin_lock_output_lock_of_snd_emu10k1_midi(void) ;
#line 150
void ldv_spin_unlock_output_lock_of_snd_emu10k1_midi(void) ;
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 283 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  {
#line 285
  _raw_spin_lock(& lock->__annonCompField19.rlock);
  }
#line 286
  return;
}
}
#line 323
__inline static void ldv_spin_lock_33(spinlock_t *lock ) ;
#line 327
__inline static void ldv_spin_lock_35(spinlock_t *lock ) ;
#line 323 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 325
  _raw_spin_unlock(& lock->__annonCompField19.rlock);
  }
#line 326
  return;
}
}
#line 363
__inline static void ldv_spin_unlock_34(spinlock_t *lock ) ;
#line 367
__inline static void ldv_spin_unlock_36(spinlock_t *lock ) ;
#line 398
__inline static void ldv_spin_unlock_irqrestore_38(spinlock_t *lock , unsigned long flags ) ;
#line 402
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 406
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 410
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 414
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 418
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 422
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 426
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 430
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) ;
#line 434
__inline static void ldv_spin_unlock_irqrestore_52(spinlock_t *lock , unsigned long flags ) ;
#line 438
__inline static void ldv_spin_unlock_irqrestore_52(spinlock_t *lock , unsigned long flags ) ;
#line 308 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value , int port ) 
{ 


  {
#line 308
  __asm__  volatile   ("outb %b0, %w1": : "a" (value), "Nd" (port));
#line 309
  return;
}
}
#line 308 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port ) 
{ 
  unsigned char value ;

  {
#line 308
  __asm__  volatile   ("inb %w1, %b0": "=a" (value): "Nd" (port));
#line 308
  return (value);
}
}
#line 152 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/rawmidi.h"
extern int snd_rawmidi_new(struct snd_card * , char * , int  , int  , int  , struct snd_rawmidi ** ) ;
#line 155
extern void snd_rawmidi_set_ops(struct snd_rawmidi * , int  , struct snd_rawmidi_ops * ) ;
#line 161
extern int snd_rawmidi_receive(struct snd_rawmidi_substream * , unsigned char const   * ,
                               int  ) ;
#line 168
extern int snd_rawmidi_transmit(struct snd_rawmidi_substream * , unsigned char * ,
                                int  ) ;
#line 30 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
__inline static unsigned char mpu401_read(struct snd_emu10k1 *emu , struct snd_emu10k1_midi *mpu ,
                                          int idx ) 
{ 
  unsigned int tmp ;
  unsigned char tmp___0 ;

  {
#line 33
  if (emu->audigy != 0U) {
    {
#line 34
    tmp = snd_emu10k1_ptr_read(emu, (unsigned int )(mpu->port + idx), 0U);
    }
#line 34
    return ((unsigned char )tmp);
  } else {
    {
#line 36
    tmp___0 = inb((int )(((unsigned int )emu->port + (unsigned int )mpu->port) + (unsigned int )idx));
    }
#line 36
    return (tmp___0);
  }
}
}
#line 39 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
__inline static void mpu401_write(struct snd_emu10k1 *emu , struct snd_emu10k1_midi *mpu ,
                                  int data , int idx ) 
{ 


  {
#line 42
  if (emu->audigy != 0U) {
    {
#line 43
    snd_emu10k1_ptr_write(emu, (unsigned int )(mpu->port + idx), 0U, (unsigned int )data);
    }
  } else {
    {
#line 45
    outb((int )((unsigned char )data), (int )(((unsigned int )emu->port + (unsigned int )mpu->port) + (unsigned int )idx));
    }
  }
#line 46
  return;
}
}
#line 60 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void mpu401_clear_rx(struct snd_emu10k1 *emu , struct snd_emu10k1_midi *mpu ) 
{ 
  int timeout ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 62
  timeout = 100000;
#line 63
  goto ldv_30346;
  ldv_30345: 
  {
#line 64
  mpu401_read(emu, mpu, 0);
#line 63
  timeout = timeout - 1;
  }
  ldv_30346: ;
#line 63
  if (timeout > 0) {
    {
#line 63
    tmp = mpu401_read(emu, mpu, 1);
    }
#line 63
    if ((int )((signed char )tmp) >= 0) {
#line 65
      goto ldv_30345;
    } else {
#line 68
      goto ldv_30347;
    }
  } else {

  }
  ldv_30347: ;
#line 66
  if (timeout <= 0) {
    {
#line 67
    tmp___0 = mpu401_read(emu, mpu, 1);
#line 67
    __snd_printk(0U, "sound/pci/emu10k1/emumpu401.c", 67, "<3>cmd: clear rx timeout (status = 0x%x)\n",
                 (int )tmp___0);
    }
  } else {

  }
#line 68
  return;
}
}
#line 75 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void do_emu10k1_midi_interrupt(struct snd_emu10k1 *emu , struct snd_emu10k1_midi *midi ,
                                      unsigned int status ) 
{ 
  unsigned char byte ;
  unsigned char tmp ;
  int tmp___0 ;
  unsigned char tmp___1 ;

  {
#line 79
  if ((unsigned long )midi->rmidi == (unsigned long )((struct snd_rawmidi *)0)) {
    {
#line 80
    snd_emu10k1_intr_disable(emu, (unsigned int )(midi->tx_enable | midi->rx_enable));
    }
#line 81
    return;
  } else {

  }
  {
#line 84
  ldv_spin_lock_33(& midi->input_lock);
  }
#line 85
  if ((status & (unsigned int )midi->ipr_rx) != 0U) {
    {
#line 85
    tmp = mpu401_read(emu, midi, 1);
    }
#line 85
    if ((int )((signed char )tmp) >= 0) {
#line 86
      if ((midi->midi_mode & 1U) == 0U) {
        {
#line 87
        mpu401_clear_rx(emu, midi);
        }
      } else {
        {
#line 89
        byte = mpu401_read(emu, midi, 0);
        }
#line 90
        if ((unsigned long )midi->substream_input != (unsigned long )((struct snd_rawmidi_substream *)0)) {
          {
#line 91
          snd_rawmidi_receive(midi->substream_input, (unsigned char const   *)(& byte),
                              1);
          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  {
#line 94
  ldv_spin_unlock_34(& midi->input_lock);
#line 96
  ldv_spin_lock_35(& midi->output_lock);
  }
#line 97
  if ((status & (unsigned int )midi->ipr_tx) != 0U) {
    {
#line 97
    tmp___1 = mpu401_read(emu, midi, 1);
    }
#line 97
    if (((int )tmp___1 & 64) == 0) {
#line 98
      if ((unsigned long )midi->substream_output != (unsigned long )((struct snd_rawmidi_substream *)0)) {
        {
#line 98
        tmp___0 = snd_rawmidi_transmit(midi->substream_output, & byte, 1);
        }
#line 98
        if (tmp___0 == 1) {
          {
#line 100
          mpu401_write(emu, midi, (int )byte, 0);
          }
        } else {
          {
#line 102
          snd_emu10k1_intr_disable(emu, (unsigned int )midi->tx_enable);
          }
        }
      } else {
        {
#line 102
        snd_emu10k1_intr_disable(emu, (unsigned int )midi->tx_enable);
        }
      }
    } else {

    }
  } else {

  }
  {
#line 105
  ldv_spin_unlock_36(& midi->output_lock);
  }
#line 106
  return;
}
}
#line 108 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void snd_emu10k1_midi_interrupt(struct snd_emu10k1 *emu , unsigned int status ) 
{ 


  {
  {
#line 110
  do_emu10k1_midi_interrupt(emu, & emu->midi, status);
  }
#line 111
  return;
}
}
#line 113 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void snd_emu10k1_midi_interrupt2(struct snd_emu10k1 *emu , unsigned int status ) 
{ 


  {
  {
#line 115
  do_emu10k1_midi_interrupt(emu, & emu->midi2, status);
  }
#line 116
  return;
}
}
#line 118 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static int snd_emu10k1_midi_cmd(struct snd_emu10k1 *emu , struct snd_emu10k1_midi *midi ,
                                unsigned char cmd , int ack ) 
{ 
  unsigned long flags ;
  int timeout ;
  int ok ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
  {
#line 123
  ldv___ldv_spin_lock_37(& midi->input_lock);
#line 124
  mpu401_write(emu, midi, 0, 0);
#line 127
  mpu401_write(emu, midi, (int )cmd, 1);
  }
#line 128
  if (ack != 0) {
#line 129
    ok = 0;
#line 130
    timeout = 10000;
#line 131
    goto ldv_30372;
    ldv_30371: 
    {
#line 132
    tmp___0 = mpu401_read(emu, midi, 1);
    }
#line 132
    if ((int )((signed char )tmp___0) >= 0) {
      {
#line 133
      tmp = mpu401_read(emu, midi, 0);
      }
#line 133
      if ((unsigned int )tmp == 254U) {
#line 134
        ok = 1;
      } else {

      }
    } else {

    }
    ldv_30372: ;
#line 131
    if (ok == 0) {
#line 131
      tmp___1 = timeout;
#line 131
      timeout = timeout - 1;
#line 131
      if (tmp___1 > 0) {
#line 133
        goto ldv_30371;
      } else {
#line 136
        goto ldv_30373;
      }
    } else {

    }
    ldv_30373: ;
#line 137
    if (ok == 0) {
      {
#line 137
      tmp___2 = mpu401_read(emu, midi, 0);
      }
#line 137
      if ((unsigned int )tmp___2 == 254U) {
#line 138
        ok = 1;
      } else {

      }
    } else {

    }
  } else {
#line 140
    ok = 1;
  }
  {
#line 142
  ldv_spin_unlock_irqrestore_38(& midi->input_lock, flags);
  }
#line 143
  if (ok == 0) {
    {
#line 144
    tmp___3 = mpu401_read(emu, midi, 0);
#line 144
    tmp___4 = mpu401_read(emu, midi, 1);
#line 144
    __snd_printk(0U, "sound/pci/emu10k1/emumpu401.c", 147, "<3>midi_cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)!!!\n",
                 (int )cmd, emu->port, (int )tmp___4, (int )tmp___3);
    }
#line 148
    return (1);
  } else {

  }
#line 150
  return (0);
}
}
#line 153 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static int snd_emu10k1_midi_input_open(struct snd_rawmidi_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_midi *midi ;
  unsigned long flags ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 156
  midi = (struct snd_emu10k1_midi *)(substream->rmidi)->private_data;
#line 159
  emu = midi->emu;
#line 160
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 160
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 160
  if (tmp != 0L) {
    {
#line 160
    warn_slowpath_fmt("sound/pci/emu10k1/emumpu401.c", 160, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 160
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 160
  if (tmp___0 != 0L) {
#line 161
    return (-6);
  } else {

  }
  {
#line 162
  ldv___ldv_spin_lock_39(& midi->open_lock);
#line 163
  midi->midi_mode = midi->midi_mode | 1U;
#line 164
  midi->substream_input = substream;
  }
#line 165
  if ((midi->midi_mode & 2U) == 0U) {
    {
#line 166
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
#line 167
    tmp___1 = snd_emu10k1_midi_cmd(emu, midi, 255, 1);
    }
#line 167
    if (tmp___1 != 0) {
#line 168
      goto error_out;
    } else {

    }
    {
#line 169
    tmp___2 = snd_emu10k1_midi_cmd(emu, midi, 63, 1);
    }
#line 169
    if (tmp___2 != 0) {
#line 170
      goto error_out;
    } else {

    }
  } else {
    {
#line 172
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
    }
  }
#line 174
  return (0);
  error_out: ;
#line 177
  return (-5);
}
}
#line 180 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static int snd_emu10k1_midi_output_open(struct snd_rawmidi_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_midi *midi ;
  unsigned long flags ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 183
  midi = (struct snd_emu10k1_midi *)(substream->rmidi)->private_data;
#line 186
  emu = midi->emu;
#line 187
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 187
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 187
  if (tmp != 0L) {
    {
#line 187
    warn_slowpath_fmt("sound/pci/emu10k1/emumpu401.c", 187, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 187
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 187
  if (tmp___0 != 0L) {
#line 188
    return (-6);
  } else {

  }
  {
#line 189
  ldv___ldv_spin_lock_42(& midi->open_lock);
#line 190
  midi->midi_mode = midi->midi_mode | 2U;
#line 191
  midi->substream_output = substream;
  }
#line 192
  if ((midi->midi_mode & 1U) == 0U) {
    {
#line 193
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
#line 194
    tmp___1 = snd_emu10k1_midi_cmd(emu, midi, 255, 1);
    }
#line 194
    if (tmp___1 != 0) {
#line 195
      goto error_out;
    } else {

    }
    {
#line 196
    tmp___2 = snd_emu10k1_midi_cmd(emu, midi, 63, 1);
    }
#line 196
    if (tmp___2 != 0) {
#line 197
      goto error_out;
    } else {

    }
  } else {
    {
#line 199
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
    }
  }
#line 201
  return (0);
  error_out: ;
#line 204
  return (-5);
}
}
#line 207 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static int snd_emu10k1_midi_input_close(struct snd_rawmidi_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_midi *midi ;
  unsigned long flags ;
  int err ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 210
  midi = (struct snd_emu10k1_midi *)(substream->rmidi)->private_data;
#line 212
  err = 0;
#line 214
  emu = midi->emu;
#line 215
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 215
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 215
  if (tmp != 0L) {
    {
#line 215
    warn_slowpath_fmt("sound/pci/emu10k1/emumpu401.c", 215, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 215
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 215
  if (tmp___0 != 0L) {
#line 216
    return (-6);
  } else {

  }
  {
#line 217
  ldv___ldv_spin_lock_45(& midi->open_lock);
#line 218
  snd_emu10k1_intr_disable(emu, (unsigned int )midi->rx_enable);
#line 219
  midi->midi_mode = midi->midi_mode & 4294967294U;
#line 220
  midi->substream_input = (struct snd_rawmidi_substream *)0;
  }
#line 221
  if ((midi->midi_mode & 2U) == 0U) {
    {
#line 222
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
#line 223
    err = snd_emu10k1_midi_cmd(emu, midi, 255, 0);
    }
  } else {
    {
#line 225
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
    }
  }
#line 227
  return (err);
}
}
#line 230 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static int snd_emu10k1_midi_output_close(struct snd_rawmidi_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_midi *midi ;
  unsigned long flags ;
  int err ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 233
  midi = (struct snd_emu10k1_midi *)(substream->rmidi)->private_data;
#line 235
  err = 0;
#line 237
  emu = midi->emu;
#line 238
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 238
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 238
  if (tmp != 0L) {
    {
#line 238
    warn_slowpath_fmt("sound/pci/emu10k1/emumpu401.c", 238, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 238
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 238
  if (tmp___0 != 0L) {
#line 239
    return (-6);
  } else {

  }
  {
#line 240
  ldv___ldv_spin_lock_48(& midi->open_lock);
#line 241
  snd_emu10k1_intr_disable(emu, (unsigned int )midi->tx_enable);
#line 242
  midi->midi_mode = midi->midi_mode & 4294967293U;
#line 243
  midi->substream_output = (struct snd_rawmidi_substream *)0;
  }
#line 244
  if ((midi->midi_mode & 1U) == 0U) {
    {
#line 245
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
#line 246
    err = snd_emu10k1_midi_cmd(emu, midi, 255, 0);
    }
  } else {
    {
#line 248
    ldv_spin_unlock_irqrestore_40(& midi->open_lock, flags);
    }
  }
#line 250
  return (err);
}
}
#line 253 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void snd_emu10k1_midi_input_trigger(struct snd_rawmidi_substream *substream ,
                                           int up___0 ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_midi *midi ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 256
  midi = (struct snd_emu10k1_midi *)(substream->rmidi)->private_data;
#line 257
  emu = midi->emu;
#line 258
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 258
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 258
  if (tmp != 0L) {
    {
#line 258
    warn_slowpath_fmt("sound/pci/emu10k1/emumpu401.c", 258, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 258
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 258
  if (tmp___0 != 0L) {
#line 259
    return;
  } else {

  }
#line 261
  if (up___0 != 0) {
    {
#line 262
    snd_emu10k1_intr_enable(emu, (unsigned int )midi->rx_enable);
    }
  } else {
    {
#line 264
    snd_emu10k1_intr_disable(emu, (unsigned int )midi->rx_enable);
    }
  }
#line 265
  return;
}
}
#line 267 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void snd_emu10k1_midi_output_trigger(struct snd_rawmidi_substream *substream ,
                                            int up___0 ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_midi *midi ;
  unsigned long flags ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int max ;
  unsigned char byte ;
  int tmp___1 ;
  unsigned char tmp___2 ;

  {
  {
#line 270
  midi = (struct snd_emu10k1_midi *)(substream->rmidi)->private_data;
#line 273
  emu = midi->emu;
#line 274
  __ret_warn_on = (unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0);
#line 274
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 274
  if (tmp != 0L) {
    {
#line 274
    warn_slowpath_fmt("sound/pci/emu10k1/emumpu401.c", 274, "BUG? (%s)\n", (char *)"!emu");
    }
  } else {

  }
  {
#line 274
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 274
  if (tmp___0 != 0L) {
#line 275
    return;
  } else {

  }
#line 277
  if (up___0 != 0) {
    {
#line 278
    max = 4;
#line 282
    ldv___ldv_spin_lock_51(& midi->output_lock);
    }
#line 283
    goto ldv_30431;
    ldv_30430: 
    {
#line 284
    tmp___2 = mpu401_read(emu, midi, 1);
    }
#line 284
    if (((int )tmp___2 & 64) == 0) {
#line 285
      if ((midi->midi_mode & 2U) == 0U) {
        {
#line 288
        ldv_spin_unlock_irqrestore_52(& midi->output_lock, flags);
        }
#line 289
        return;
      } else {
        {
#line 285
        tmp___1 = snd_rawmidi_transmit(substream, & byte, 1);
        }
#line 285
        if (tmp___1 != 1) {
          {
#line 288
          ldv_spin_unlock_irqrestore_52(& midi->output_lock, flags);
          }
#line 289
          return;
        } else {

        }
      }
      {
#line 291
      mpu401_write(emu, midi, (int )byte, 0);
#line 292
      max = max - 1;
      }
    } else {
#line 294
      goto ldv_30429;
    }
    ldv_30431: ;
#line 283
    if (max > 0) {
#line 285
      goto ldv_30430;
    } else {

    }
    ldv_30429: 
    {
#line 297
    ldv_spin_unlock_irqrestore_52(& midi->output_lock, flags);
#line 298
    snd_emu10k1_intr_enable(emu, (unsigned int )midi->tx_enable);
    }
  } else {
    {
#line 300
    snd_emu10k1_intr_disable(emu, (unsigned int )midi->tx_enable);
    }
  }
#line 301
  return;
}
}
#line 308 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static struct snd_rawmidi_ops snd_emu10k1_midi_output  =    {& snd_emu10k1_midi_output_open, & snd_emu10k1_midi_output_close, & snd_emu10k1_midi_output_trigger,
    0};
#line 315 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static struct snd_rawmidi_ops snd_emu10k1_midi_input  =    {& snd_emu10k1_midi_input_open, & snd_emu10k1_midi_input_close, & snd_emu10k1_midi_input_trigger,
    0};
#line 322 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static void snd_emu10k1_midi_free(struct snd_rawmidi *rmidi ) 
{ 
  struct snd_emu10k1_midi *midi ;

  {
#line 324
  midi = (struct snd_emu10k1_midi *)rmidi->private_data;
#line 325
  midi->interrupt = (void (*)(struct snd_emu10k1 * , unsigned int  ))0;
#line 326
  midi->rmidi = (struct snd_rawmidi *)0;
#line 327
  return;
}
}
#line 329 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
static int emu10k1_midi_init(struct snd_emu10k1 *emu , struct snd_emu10k1_midi *midi ,
                             int device , char *name ) 
{ 
  struct snd_rawmidi *rmidi ;
  int err ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
  {
#line 334
  err = snd_rawmidi_new(emu->card, name, device, 1, 1, & rmidi);
  }
#line 334
  if (err < 0) {
#line 335
    return (err);
  } else {

  }
  {
#line 336
  midi->emu = emu;
#line 337
  spinlock_check(& midi->open_lock);
#line 337
  __raw_spin_lock_init(& midi->open_lock.__annonCompField19.rlock, "&(&midi->open_lock)->rlock",
                       & __key);
#line 338
  spinlock_check(& midi->input_lock);
#line 338
  __raw_spin_lock_init(& midi->input_lock.__annonCompField19.rlock, "&(&midi->input_lock)->rlock",
                       & __key___0);
#line 339
  spinlock_check(& midi->output_lock);
#line 339
  __raw_spin_lock_init(& midi->output_lock.__annonCompField19.rlock, "&(&midi->output_lock)->rlock",
                       & __key___1);
#line 340
  strcpy((char *)(& rmidi->name), (char const   *)name);
#line 341
  snd_rawmidi_set_ops(rmidi, 0, & snd_emu10k1_midi_output);
#line 342
  snd_rawmidi_set_ops(rmidi, 1, & snd_emu10k1_midi_input);
#line 343
  rmidi->info_flags = rmidi->info_flags | 7U;
#line 346
  rmidi->private_data = (void *)midi;
#line 347
  rmidi->private_free = & snd_emu10k1_midi_free;
#line 348
  midi->rmidi = rmidi;
  }
#line 349
  return (0);
}
}
#line 352 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
int snd_emu10k1_midi(struct snd_emu10k1 *emu ) 
{ 
  struct snd_emu10k1_midi *midi ;
  int err ;

  {
  {
#line 354
  midi = & emu->midi;
#line 357
  err = emu10k1_midi_init(emu, midi, 0, (char *)"EMU10K1 MPU-401 (UART)");
  }
#line 357
  if (err < 0) {
#line 358
    return (err);
  } else {

  }
#line 360
  midi->tx_enable = 2;
#line 361
  midi->rx_enable = 1;
#line 362
  midi->port = 24;
#line 363
  midi->ipr_tx = 256;
#line 364
  midi->ipr_rx = 128;
#line 365
  midi->interrupt = & snd_emu10k1_midi_interrupt;
#line 366
  return (0);
}
}
#line 369 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumpu401.c"
int snd_emu10k1_audigy_midi(struct snd_emu10k1 *emu ) 
{ 
  struct snd_emu10k1_midi *midi ;
  int err ;

  {
  {
#line 374
  midi = & emu->midi;
#line 375
  err = emu10k1_midi_init(emu, midi, 0, (char *)"Audigy MPU-401 (UART)");
  }
#line 375
  if (err < 0) {
#line 376
    return (err);
  } else {

  }
  {
#line 378
  midi->tx_enable = 2;
#line 379
  midi->rx_enable = 1;
#line 380
  midi->port = 112;
#line 381
  midi->ipr_tx = 256;
#line 382
  midi->ipr_rx = 128;
#line 383
  midi->interrupt = & snd_emu10k1_midi_interrupt;
#line 385
  midi = & emu->midi2;
#line 386
  err = emu10k1_midi_init(emu, midi, 1, (char *)"Audigy MPU-401 #2");
  }
#line 386
  if (err < 0) {
#line 387
    return (err);
  } else {

  }
#line 389
  midi->tx_enable = 131072;
#line 390
  midi->rx_enable = 65536;
#line 391
  midi->port = 114;
#line 392
  midi->ipr_tx = 268435456;
#line 393
  midi->ipr_rx = 134217728;
#line 394
  midi->interrupt = & snd_emu10k1_midi_interrupt2;
#line 395
  return (0);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_lock_33(spinlock_t *lock ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_input_lock_of_snd_emu10k1_midi();
#line 484
  spin_lock(lock);
  }
#line 485
  return;
}
}
#line 488 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_unlock_34(spinlock_t *lock ) 
{ 


  {
  {
#line 491
  ldv_spin_unlock_input_lock_of_snd_emu10k1_midi();
#line 493
  spin_unlock(lock);
  }
#line 494
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_lock_35(spinlock_t *lock ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_output_lock_of_snd_emu10k1_midi();
#line 502
  spin_lock(lock);
  }
#line 503
  return;
}
}
#line 506 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_unlock_36(spinlock_t *lock ) 
{ 


  {
  {
#line 509
  ldv_spin_unlock_output_lock_of_snd_emu10k1_midi();
#line 511
  spin_unlock(lock);
  }
#line 512
  return;
}
}
#line 515 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_37(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 518
  ldv_spin_lock_input_lock_of_snd_emu10k1_midi();
#line 520
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 521
  return;
}
}
#line 524 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_unlock_irqrestore_38(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 527
  ldv_spin_unlock_input_lock_of_snd_emu10k1_midi();
#line 529
  spin_unlock_irqrestore(lock, flags);
  }
#line 530
  return;
}
}
#line 533 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_39(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 536
  ldv_spin_lock_open_lock_of_snd_emu10k1_midi();
#line 538
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 539
  return;
}
}
#line 542 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_unlock_irqrestore_40(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 545
  ldv_spin_unlock_open_lock_of_snd_emu10k1_midi();
#line 547
  spin_unlock_irqrestore(lock, flags);
  }
#line 548
  return;
}
}
#line 560 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_42(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 563
  ldv_spin_lock_open_lock_of_snd_emu10k1_midi();
#line 565
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 566
  return;
}
}
#line 587 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_45(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 590
  ldv_spin_lock_open_lock_of_snd_emu10k1_midi();
#line 592
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 593
  return;
}
}
#line 614 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_48(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 617
  ldv_spin_lock_open_lock_of_snd_emu10k1_midi();
#line 619
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 620
  return;
}
}
#line 641 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
static void ldv___ldv_spin_lock_51(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 644
  ldv_spin_lock_output_lock_of_snd_emu10k1_midi();
#line 646
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 647
  return;
}
}
#line 650 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumpu401.c.aux"
__inline static void ldv_spin_unlock_irqrestore_52(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 653
  ldv_spin_unlock_output_lock_of_snd_emu10k1_midi();
#line 655
  spin_unlock_irqrestore(lock, flags);
  }
#line 656
  return;
}
}
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
static void ldv___ldv_spin_lock_33___3(spinlock_t *ldv_func_arg1 ) ;
#line 137
void ldv_spin_lock_reg_lock_of_snd_emu10k1(void) ;
#line 138
void ldv_spin_unlock_reg_lock_of_snd_emu10k1(void) ;
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 323 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_35___0(spinlock_t *lock ) ;
#line 327
__inline static void ldv_spin_lock_35___0(spinlock_t *lock ) ;
#line 331
__inline static void ldv_spin_lock_35___0(spinlock_t *lock ) ;
#line 335
__inline static void ldv_spin_lock_35___0(spinlock_t *lock ) ;
#line 312 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
  {
#line 314
  _raw_spin_lock_irq(& lock->__annonCompField19.rlock);
  }
#line 315
  return;
}
}
#line 326
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 330
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 334
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 338
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 342
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 383
__inline static void ldv_spin_unlock_36___0(spinlock_t *lock ) ;
#line 387
__inline static void ldv_spin_unlock_36___0(spinlock_t *lock ) ;
#line 391
__inline static void ldv_spin_unlock_36___0(spinlock_t *lock ) ;
#line 395
__inline static void ldv_spin_unlock_36___0(spinlock_t *lock ) ;
#line 401 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
  {
#line 403
  _raw_spin_unlock_irq(& lock->__annonCompField19.rlock);
  }
#line 404
  return;
}
}
#line 409
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 413
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 417
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 421
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 425
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 429
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 450
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 349 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 475 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
extern int snd_pcm_new(struct snd_card * , char const   * , int  , int  , int  , struct snd_pcm ** ) ;
#line 582 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static snd_pcm_sframes_t bytes_to_frames(struct snd_pcm_runtime *runtime ,
                                                  ssize_t size ) 
{ 


  {
#line 584
  return ((size * 8L) / (ssize_t )runtime->frame_bits);
}
}
#line 592 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static ssize_t frames_to_bytes(struct snd_pcm_runtime *runtime , snd_pcm_sframes_t size ) 
{ 


  {
#line 594
  return ((size * (snd_pcm_sframes_t )runtime->frame_bits) / 8L);
}
}
#line 602 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static size_t snd_pcm_lib_buffer_bytes(struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  ssize_t tmp ;

  {
  {
#line 604
  runtime = substream->runtime;
#line 605
  tmp = frames_to_bytes(runtime, (snd_pcm_sframes_t )runtime->buffer_size);
  }
#line 605
  return ((size_t )tmp);
}
}
#line 608 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static size_t snd_pcm_lib_period_bytes(struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  ssize_t tmp ;

  {
  {
#line 610
  runtime = substream->runtime;
#line 611
  tmp = frames_to_bytes(runtime, (snd_pcm_sframes_t )runtime->period_size);
  }
#line 611
  return ((size_t )tmp);
}
}
#line 758 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static struct snd_interval  const  *hw_param_interval_c(struct snd_pcm_hw_params  const  *params ,
                                                                 snd_pcm_hw_param_t var ) 
{ 


  {
#line 761
  return ((struct snd_interval  const  *)(& params->intervals) + ((unsigned long )var + 0xfffffffffffffff8UL));
}
}
#line 802
extern int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime * , snd_pcm_hw_param_t  ,
                                        unsigned int  , unsigned int  ) ;
#line 804
extern int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime * , snd_pcm_hw_param_t  ) ;
#line 805
extern int snd_pcm_hw_constraint_list(struct snd_pcm_runtime * , unsigned int  , snd_pcm_hw_param_t  ,
                                      struct snd_pcm_hw_constraint_list * ) ;
#line 828
extern int snd_pcm_hw_rule_noresample(struct snd_pcm_runtime * , unsigned int  ) ;
#line 856
extern int snd_pcm_format_width(snd_pcm_format_t  ) ;
#line 863
extern void snd_pcm_set_ops(struct snd_pcm * , int  , struct snd_pcm_ops * ) ;
#line 866
extern int snd_pcm_lib_ioctl(struct snd_pcm_substream * , unsigned int  , void * ) ;
#line 932
extern int snd_pcm_lib_preallocate_pages(struct snd_pcm_substream * , int  , struct device * ,
                                         size_t  , size_t  ) ;
#line 935
extern int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm * , int  , void * ,
                                                 size_t  , size_t  ) ;
#line 938
extern int snd_pcm_lib_malloc_pages(struct snd_pcm_substream * , size_t  ) ;
#line 939
extern int snd_pcm_lib_free_pages(struct snd_pcm_substream * ) ;
#line 1000
extern struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream * , unsigned long  ) ;
#line 110 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
extern void snd_ctl_notify(struct snd_card * , unsigned int  , struct snd_ctl_elem_id * ) ;
#line 112
extern struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  * , void * ) ;
#line 114
extern int snd_ctl_add(struct snd_card * , struct snd_kcontrol * ) ;
#line 155 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
__inline static struct snd_ctl_elem_id *snd_ctl_build_ioff(struct snd_ctl_elem_id *dst_id ,
                                                           struct snd_kcontrol *src_kctl ,
                                                           unsigned int offset ) 
{ 


  {
#line 159
  *dst_id = src_kctl->id;
#line 160
  dst_id->index = dst_id->index + offset;
#line 161
  dst_id->numid = dst_id->numid + offset;
#line 162
  return (dst_id);
}
}
#line 47 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm-indirect.h"
__inline static void snd_pcm_indirect_playback_transfer(struct snd_pcm_substream *substream ,
                                                        struct snd_pcm_indirect *rec ,
                                                        void (*copy)(struct snd_pcm_substream * ,
                                                                     struct snd_pcm_indirect * ,
                                                                     size_t  ) ) 
{ 
  struct snd_pcm_runtime *runtime ;
  snd_pcm_uframes_t appl_ptr ;
  snd_pcm_sframes_t diff ;
  int qsize ;
  ssize_t tmp ;
  unsigned int hw_to_end ;
  unsigned int sw_to_end ;
  unsigned int bytes ;

  {
#line 51
  runtime = substream->runtime;
#line 52
  appl_ptr = (runtime->control)->appl_ptr;
#line 53
  diff = (snd_pcm_sframes_t )(appl_ptr - rec->appl_ptr);
#line 56
  if (diff != 0L) {
#line 57
    if (diff < - ((long )(runtime->boundary / 2UL))) {
#line 58
      diff = (snd_pcm_sframes_t )((unsigned long )diff + runtime->boundary);
    } else {

    }
    {
#line 59
    tmp = frames_to_bytes(runtime, diff);
#line 59
    rec->sw_ready = rec->sw_ready + (int )tmp;
#line 60
    rec->appl_ptr = appl_ptr;
    }
  } else {

  }
#line 62
  qsize = (int )(rec->hw_queue_size != 0U ? rec->hw_queue_size : rec->hw_buffer_size);
#line 63
  goto ldv_29642;
  ldv_29641: 
#line 64
  hw_to_end = rec->hw_buffer_size - rec->hw_data;
#line 65
  sw_to_end = rec->sw_buffer_size - rec->sw_data;
#line 66
  bytes = (unsigned int )(qsize - rec->hw_ready);
#line 67
  if (rec->sw_ready < (int )bytes) {
#line 68
    bytes = (unsigned int )rec->sw_ready;
  } else {

  }
#line 69
  if (hw_to_end < bytes) {
#line 70
    bytes = hw_to_end;
  } else {

  }
#line 71
  if (sw_to_end < bytes) {
#line 72
    bytes = sw_to_end;
  } else {

  }
#line 73
  if (bytes == 0U) {
#line 74
    goto ldv_29640;
  } else {

  }
  {
#line 75
  (*copy)(substream, rec, (size_t )bytes);
#line 76
  rec->hw_data = rec->hw_data + bytes;
  }
#line 77
  if (rec->hw_data == rec->hw_buffer_size) {
#line 78
    rec->hw_data = 0U;
  } else {

  }
#line 79
  rec->sw_data = rec->sw_data + bytes;
#line 80
  if (rec->sw_data == rec->sw_buffer_size) {
#line 81
    rec->sw_data = 0U;
  } else {

  }
#line 82
  rec->hw_ready = (int )((unsigned int )rec->hw_ready + bytes);
#line 83
  rec->sw_ready = (int )((unsigned int )rec->sw_ready - bytes);
  ldv_29642: ;
#line 63
  if (rec->hw_ready < qsize && rec->sw_ready > 0) {
#line 65
    goto ldv_29641;
  } else {

  }
  ldv_29640: ;
#line 70
  return;
}
}
#line 92 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm-indirect.h"
__inline static snd_pcm_uframes_t snd_pcm_indirect_playback_pointer(struct snd_pcm_substream *substream ,
                                                                    struct snd_pcm_indirect *rec ,
                                                                    unsigned int ptr ) 
{ 
  int bytes ;
  snd_pcm_sframes_t tmp ;

  {
#line 95
  bytes = (int )(ptr - rec->hw_io);
#line 96
  if (bytes < 0) {
#line 97
    bytes = (int )((unsigned int )bytes + rec->hw_buffer_size);
  } else {

  }
#line 98
  rec->hw_io = ptr;
#line 99
  rec->hw_ready = rec->hw_ready - bytes;
#line 100
  rec->sw_io = rec->sw_io + (unsigned int )bytes;
#line 101
  if (rec->sw_io >= rec->sw_buffer_size) {
#line 102
    rec->sw_io = rec->sw_io - rec->sw_buffer_size;
  } else {

  }
#line 103
  if ((unsigned long )(substream->ops)->ack != (unsigned long )((int (*)(struct snd_pcm_substream * ))0)) {
    {
#line 104
    (*((substream->ops)->ack))(substream);
    }
  } else {

  }
  {
#line 105
  tmp = bytes_to_frames(substream->runtime, (ssize_t )rec->sw_io);
  }
#line 105
  return ((snd_pcm_uframes_t )tmp);
}
}
#line 1845 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
void snd_emu10k1_voice_intr_enable(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1852
void snd_emu10k1_voice_clear_loop_stop(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1857
unsigned int snd_emu10k1_rate_to_pitch(unsigned int rate ) ;
#line 1894
int snd_emu10k1_fx8010_register_irq_handler(struct snd_emu10k1 *emu , snd_fx8010_irq_handler_t *handler ,
                                            unsigned char gpr_running , void *private_data ,
                                            struct snd_emu10k1_fx8010_irq **r_irq ) ;
#line 1899
int snd_emu10k1_fx8010_unregister_irq_handler(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_irq *irq ) ;
#line 37 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_interrupt(struct snd_emu10k1 *emu , struct snd_emu10k1_voice *voice ) 
{ 
  struct snd_emu10k1_pcm *epcm ;

  {
#line 42
  epcm = voice->epcm;
#line 42
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 43
    return;
  } else {

  }
#line 44
  if ((unsigned long )epcm->substream == (unsigned long )((struct snd_pcm_substream *)0)) {
#line 45
    return;
  } else {

  }
  {
#line 52
  snd_pcm_period_elapsed(epcm->substream);
  }
#line 53
  return;
}
}
#line 55 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_ac97adc_interrupt(struct snd_emu10k1 *emu , unsigned int status ) 
{ 


  {
  {
#line 64
  snd_pcm_period_elapsed(emu->pcm_capture_substream);
  }
#line 65
  return;
}
}
#line 67 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_ac97mic_interrupt(struct snd_emu10k1 *emu , unsigned int status ) 
{ 


  {
  {
#line 76
  snd_pcm_period_elapsed(emu->pcm_capture_mic_substream);
  }
#line 77
  return;
}
}
#line 79 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_efx_interrupt(struct snd_emu10k1 *emu , unsigned int status ) 
{ 


  {
  {
#line 88
  snd_pcm_period_elapsed(emu->pcm_capture_efx_substream);
  }
#line 89
  return;
}
}
#line 91 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static snd_pcm_uframes_t snd_emu10k1_efx_playback_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  unsigned int ptr ;
  unsigned int tmp ;

  {
#line 93
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 94
  runtime = substream->runtime;
#line 95
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 98
  if ((unsigned int )epcm->running == 0U) {
#line 99
    return (0UL);
  } else {

  }
  {
#line 100
  tmp = snd_emu10k1_ptr_read(emu, 8U, (unsigned int )(epcm->voices[0])->number);
#line 100
  ptr = tmp & 16777215U;
#line 101
  ptr = ptr + (unsigned int )runtime->buffer_size;
#line 102
  ptr = ptr - epcm->ccca_start_addr;
#line 103
  ptr = (unsigned int )((snd_pcm_uframes_t )ptr % runtime->buffer_size);
  }
#line 105
  return ((snd_pcm_uframes_t )ptr);
}
}
#line 108 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_pcm_channel_alloc(struct snd_emu10k1_pcm *epcm , int voices ) 
{ 
  int err ;
  int i ;

  {
#line 112
  if ((unsigned long )epcm->voices[1] != (unsigned long )((struct snd_emu10k1_voice *)0) && voices <= 1) {
    {
#line 113
    snd_emu10k1_voice_free(epcm->emu, epcm->voices[1]);
#line 114
    epcm->voices[1] = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 116
  i = 0;
#line 116
  goto ldv_30364;
  ldv_30363: ;
#line 117
  if ((unsigned long )epcm->voices[i] == (unsigned long )((struct snd_emu10k1_voice *)0)) {
#line 118
    goto ldv_30362;
  } else {

  }
#line 116
  i = i + 1;
  ldv_30364: ;
#line 116
  if (i < voices) {
#line 118
    goto ldv_30363;
  } else {

  }
  ldv_30362: ;
#line 120
  if (i == voices) {
#line 121
    return (0);
  } else {

  }
#line 123
  i = 0;
#line 123
  goto ldv_30368;
  ldv_30367: ;
#line 124
  if ((unsigned long )epcm->voices[i] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 125
    snd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);
#line 126
    epcm->voices[i] = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 123
  i = i + 1;
  ldv_30368: ;
#line 123
  if ((unsigned int )i <= 15U) {
#line 125
    goto ldv_30367;
  } else {

  }
  {
#line 129
  err = snd_emu10k1_voice_alloc(epcm->emu, epcm->type == 0, voices, (struct snd_emu10k1_voice **)(& epcm->voices));
  }
#line 134
  if (err < 0) {
#line 135
    return (err);
  } else {

  }
#line 136
  (epcm->voices[0])->epcm = epcm;
#line 137
  if (voices > 1) {
#line 138
    i = 1;
#line 138
    goto ldv_30371;
    ldv_30370: 
#line 139
    epcm->voices[i] = (struct snd_emu10k1_voice *)(& (epcm->emu)->voices) + (unsigned long )((epcm->voices[0])->number + i);
#line 140
    (epcm->voices[i])->epcm = epcm;
#line 138
    i = i + 1;
    ldv_30371: ;
#line 138
    if (i < voices) {
#line 140
      goto ldv_30370;
    } else {

    }

  } else {

  }
#line 143
  if ((unsigned long )epcm->extra == (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 144
    err = snd_emu10k1_voice_alloc(epcm->emu, epcm->type == 0, 1, & epcm->extra);
    }
#line 148
    if (err < 0) {
#line 154
      i = 0;
#line 154
      goto ldv_30374;
      ldv_30373: 
      {
#line 155
      snd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);
#line 156
      epcm->voices[i] = (struct snd_emu10k1_voice *)0;
#line 154
      i = i + 1;
      }
      ldv_30374: ;
#line 154
      if (i < voices) {
#line 156
        goto ldv_30373;
      } else {

      }

#line 158
      return (err);
    } else {

    }
#line 160
    (epcm->extra)->epcm = epcm;
#line 161
    (epcm->extra)->interrupt = & snd_emu10k1_pcm_interrupt;
  } else {

  }
#line 163
  return (0);
}
}
#line 166 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static unsigned int capture_period_sizes[31U]  = 
#line 166
  {      384U,      448U,      512U,      640U, 
        768U,      896U,      1024U,      1280U, 
        1536U,      1792U,      2048U,      2560U, 
        3072U,      3584U,      4096U,      5120U, 
        6144U,      7168U,      8192U,      10240U, 
        12288U,      14336U,      16384U,      20480U, 
        24576U,      28672U,      32768U,      40960U, 
        49152U,      57344U,      65536U};
#line 177 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hw_constraint_list hw_constraints_capture_period_sizes  =    {31U, (unsigned int *)(& capture_period_sizes), 0U};
#line 183 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static unsigned int capture_rates[8U]  = 
#line 183
  {      8000U,      11025U,      16000U,      22050U, 
        24000U,      32000U,      44100U,      48000U};
#line 187 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hw_constraint_list hw_constraints_capture_rates  =    {8U, (unsigned int *)(& capture_rates), 0U};
#line 193 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static unsigned int snd_emu10k1_capture_rate_reg(unsigned int rate ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 196
  if (rate == 8000U) {
#line 196
    goto case_8000;
  } else {

  }
#line 197
  if (rate == 11025U) {
#line 197
    goto case_11025;
  } else {

  }
#line 198
  if (rate == 16000U) {
#line 198
    goto case_16000;
  } else {

  }
#line 199
  if (rate == 22050U) {
#line 199
    goto case_22050;
  } else {

  }
#line 200
  if (rate == 24000U) {
#line 200
    goto case_24000;
  } else {

  }
#line 201
  if (rate == 32000U) {
#line 201
    goto case_32000;
  } else {

  }
#line 202
  if (rate == 44100U) {
#line 202
    goto case_44100;
  } else {

  }
#line 203
  if (rate == 48000U) {
#line 203
    goto case_48000;
  } else {

  }
#line 204
  goto switch_default;
  case_8000: /* CIL Label */ ;
#line 196
  return (7U);
  case_11025: /* CIL Label */ ;
#line 197
  return (6U);
  case_16000: /* CIL Label */ ;
#line 198
  return (5U);
  case_22050: /* CIL Label */ ;
#line 199
  return (4U);
  case_24000: /* CIL Label */ ;
#line 200
  return (3U);
  case_32000: /* CIL Label */ ;
#line 201
  return (2U);
  case_44100: /* CIL Label */ ;
#line 202
  return (1U);
  case_48000: /* CIL Label */ ;
#line 203
  return (0U);
  switch_default: /* CIL Label */ 
  {
#line 205
  __ret_warn_on = 1;
#line 205
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 205
  if (tmp != 0L) {
    {
#line 205
    warn_slowpath_fmt("sound/pci/emu10k1/emupcm.c", 205, "BUG?\n");
    }
  } else {

  }
  {
#line 205
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 206
  return (7U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 210 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static unsigned int snd_emu10k1_audigy_capture_rate_reg(unsigned int rate ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 213
  if (rate == 8000U) {
#line 213
    goto case_8000;
  } else {

  }
#line 214
  if (rate == 11025U) {
#line 214
    goto case_11025;
  } else {

  }
#line 215
  if (rate == 12000U) {
#line 215
    goto case_12000;
  } else {

  }
#line 216
  if (rate == 16000U) {
#line 216
    goto case_16000;
  } else {

  }
#line 217
  if (rate == 22050U) {
#line 217
    goto case_22050;
  } else {

  }
#line 218
  if (rate == 24000U) {
#line 218
    goto case_24000;
  } else {

  }
#line 219
  if (rate == 32000U) {
#line 219
    goto case_32000;
  } else {

  }
#line 220
  if (rate == 44100U) {
#line 220
    goto case_44100;
  } else {

  }
#line 221
  if (rate == 48000U) {
#line 221
    goto case_48000;
  } else {

  }
#line 222
  goto switch_default;
  case_8000: /* CIL Label */ ;
#line 213
  return (8U);
  case_11025: /* CIL Label */ ;
#line 214
  return (7U);
  case_12000: /* CIL Label */ ;
#line 215
  return (6U);
  case_16000: /* CIL Label */ ;
#line 216
  return (5U);
  case_22050: /* CIL Label */ ;
#line 217
  return (4U);
  case_24000: /* CIL Label */ ;
#line 218
  return (3U);
  case_32000: /* CIL Label */ ;
#line 219
  return (2U);
  case_44100: /* CIL Label */ ;
#line 220
  return (1U);
  case_48000: /* CIL Label */ ;
#line 221
  return (0U);
  switch_default: /* CIL Label */ 
  {
#line 223
  __ret_warn_on = 1;
#line 223
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 223
  if (tmp != 0L) {
    {
#line 223
    warn_slowpath_fmt("sound/pci/emu10k1/emupcm.c", 223, "BUG?\n");
    }
  } else {

  }
  {
#line 223
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 224
  return (8U);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 228 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static unsigned int emu10k1_calc_pitch_target(unsigned int rate ) 
{ 
  unsigned int pitch_target ;

  {
#line 232
  pitch_target = (rate << 8) / 375U;
#line 233
  pitch_target = (pitch_target >> 1) + (pitch_target & 1U);
#line 234
  return (pitch_target);
}
}
#line 244 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static unsigned int emu10k1_select_interprom(unsigned int pitch_target ) 
{ 


  {
#line 246
  if (pitch_target == 16384U) {
#line 247
    return (0U);
  } else
#line 248
  if (pitch_target <= 16383U) {
#line 249
    return (33554432U);
  } else
#line 250
  if (pitch_target > 32767U) {
#line 251
    return (0U);
  } else
#line 252
  if (pitch_target > 29012U) {
#line 253
    return (201326592U);
  } else
#line 254
  if (pitch_target > 27553U) {
#line 255
    return (167772160U);
  } else
#line 256
  if (pitch_target > 23169U) {
#line 257
    return (134217728U);
  } else
#line 258
  if (pitch_target > 19483U) {
#line 259
    return (100663296U);
  } else {
#line 261
    return (67108864U);
  }
}
}
#line 272 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
__inline static int emu10k1_ccis(int stereo , int w_16 ) 
{ 


  {
#line 274
  if (w_16 != 0) {
#line 275
    return (stereo != 0 ? 24 : 26);
  } else {
#line 277
    return (stereo != 0 ? 48 : 52);
  }
}
}
#line 281 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu , int master , int extra ,
                                       struct snd_emu10k1_voice *evoice , unsigned int start_addr ,
                                       unsigned int end_addr , struct snd_emu10k1_pcm_mixer *mix ) 
{ 
  struct snd_pcm_substream *substream ;
  struct snd_pcm_runtime *runtime ;
  unsigned int silent_page ;
  unsigned int tmp ;
  int voice ;
  int stereo ;
  int w_16 ;
  unsigned char attn ;
  unsigned char send_amount[8U] ;
  unsigned char send_routing[8U] ;
  unsigned long flags ;
  unsigned int pitch_target ;
  unsigned int ccis ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 288
  substream = (evoice->epcm)->substream;
#line 289
  runtime = substream->runtime;
#line 298
  voice = evoice->number;
#line 299
  stereo = runtime->channels == 2U;
#line 300
  tmp___0 = snd_pcm_format_width(runtime->format);
#line 300
  w_16 = tmp___0 == 16;
  }
#line 302
  if (extra == 0 && stereo != 0) {
#line 303
    start_addr = start_addr >> 1;
#line 304
    end_addr = end_addr >> 1;
  } else {

  }
#line 306
  if (w_16 != 0) {
#line 307
    start_addr = start_addr >> 1;
#line 308
    end_addr = end_addr >> 1;
  } else {

  }
  {
#line 311
  ldv___ldv_spin_lock_33___3(& emu->reg_lock);
  }
#line 314
  if (extra != 0) {
    {
#line 315
    attn = 0U;
#line 316
    memset((void *)(& send_routing), 0, 8UL);
#line 317
    send_routing[0] = 0U;
#line 318
    send_routing[1] = 1U;
#line 319
    send_routing[2] = 2U;
#line 320
    send_routing[3] = 3U;
#line 321
    memset((void *)(& send_amount), 0, 8UL);
    }
  } else {
    {
#line 324
    tmp = stereo != 0 ? (master != 0 ? 1U : 2U) : 0U;
#line 325
    memcpy((void *)(& send_routing), (void const   *)((unsigned char (*)[8])(& mix->send_routing) + (unsigned long )tmp),
           8UL);
#line 326
    memcpy((void *)(& send_amount), (void const   *)((unsigned char (*)[8])(& mix->send_volume) + (unsigned long )tmp),
           8UL);
    }
  }
  {
#line 329
  tmp___1 = emu10k1_ccis(stereo, w_16);
#line 329
  ccis = (unsigned int )tmp___1;
  }
#line 331
  if (master != 0) {
#line 332
    (evoice->epcm)->ccca_start_addr = start_addr + ccis;
#line 333
    if (extra != 0) {
#line 334
      start_addr = start_addr + ccis;
#line 335
      end_addr = end_addr + (ccis + emu->delay_pcm_irq);
    } else {

    }
#line 337
    if (stereo != 0 && extra == 0) {
      {
#line 338
      snd_emu10k1_ptr_write(emu, 0U, (unsigned int )voice, 32768U);
#line 339
      snd_emu10k1_ptr_write(emu, 0U, (unsigned int )(voice + 1), 32768U);
      }
    } else {
      {
#line 341
      snd_emu10k1_ptr_write(emu, 0U, (unsigned int )voice, 0U);
      }
    }
  } else {

  }
#line 346
  if (emu->audigy != 0U) {
    {
#line 347
    snd_emu10k1_ptr_write(emu, 126U, (unsigned int )voice, (((unsigned int )send_routing[0] | ((unsigned int )send_routing[1] << 8)) | ((unsigned int )send_routing[2] << 16)) | ((unsigned int )send_routing[3] << 24));
#line 349
    snd_emu10k1_ptr_write(emu, 124U, (unsigned int )voice, (((unsigned int )send_routing[4] | ((unsigned int )send_routing[5] << 8)) | ((unsigned int )send_routing[6] << 16)) | ((unsigned int )send_routing[7] << 24));
#line 351
    snd_emu10k1_ptr_write(emu, 125U, (unsigned int )voice, ((((unsigned int )send_amount[4] << 24) | ((unsigned int )send_amount[5] << 16)) | ((unsigned int )send_amount[6] << 8)) | (unsigned int )send_amount[7]);
    }
  } else {
    {
#line 357
    snd_emu10k1_ptr_write(emu, 11U, (unsigned int )voice, (unsigned int )(((((int )send_routing[0] | ((int )send_routing[1] << 4)) | ((int )send_routing[2] << 8)) | ((int )send_routing[3] << 12)) << 16));
    }
  }
  {
#line 361
  snd_emu10k1_ptr_write(emu, 1U, (unsigned int )voice, (unsigned int )(((int )send_amount[0] << 8) | (int )send_amount[1]));
#line 362
  snd_emu10k1_ptr_write(emu, 7U, (unsigned int )voice, end_addr | (unsigned int )((int )send_amount[3] << 24));
#line 363
  snd_emu10k1_ptr_write(emu, 6U, (unsigned int )voice, (start_addr + (extra != 0 ? emu->delay_pcm_irq : 0U)) | (unsigned int )((int )send_amount[2] << 24));
  }
#line 366
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
#line 367
    pitch_target = 16384U;
  } else {
    {
#line 369
    pitch_target = emu10k1_calc_pitch_target(runtime->rate);
    }
  }
#line 370
  if (extra != 0) {
    {
#line 371
    tmp___2 = emu10k1_select_interprom(pitch_target);
#line 371
    snd_emu10k1_ptr_write(emu, 8U, (unsigned int )voice, (start_addr | tmp___2) | (w_16 != 0 ? 0U : 16777216U));
    }
  } else {
    {
#line 375
    tmp___3 = emu10k1_select_interprom(pitch_target);
#line 375
    snd_emu10k1_ptr_write(emu, 8U, (unsigned int )voice, ((start_addr + ccis) | tmp___3) | (w_16 != 0 ? 0U : 16777216U));
    }
  }
  {
#line 379
  snd_emu10k1_ptr_write(emu, 5U, (unsigned int )voice, 0U);
#line 380
  snd_emu10k1_ptr_write(emu, 4U, (unsigned int )voice, 0U);
#line 382
  silent_page = ((unsigned int )emu->silent_page.addr << 1) | 8191U;
#line 383
  snd_emu10k1_ptr_write(emu, 12U, (unsigned int )voice, silent_page);
#line 384
  snd_emu10k1_ptr_write(emu, 13U, (unsigned int )voice, silent_page);
#line 386
  snd_emu10k1_ptr_write(emu, 2U, (unsigned int )voice, 65535U);
#line 387
  snd_emu10k1_ptr_write(emu, 3U, (unsigned int )voice, 65535U);
#line 388
  snd_emu10k1_ptr_write(emu, 21U, (unsigned int )voice, 0U);
#line 389
  snd_emu10k1_ptr_write(emu, 22U, (unsigned int )voice, 127U);
#line 390
  snd_emu10k1_ptr_write(emu, 19U, (unsigned int )voice, 32768U);
#line 391
  snd_emu10k1_ptr_write(emu, 23U, (unsigned int )voice, 32768U);
#line 392
  snd_emu10k1_ptr_write(emu, 27U, (unsigned int )voice, 0U);
#line 393
  snd_emu10k1_ptr_write(emu, 28U, (unsigned int )voice, 0U);
#line 394
  snd_emu10k1_ptr_write(emu, 29U, (unsigned int )voice, 0U);
#line 395
  snd_emu10k1_ptr_write(emu, 20U, (unsigned int )voice, 32768U);
#line 397
  snd_emu10k1_ptr_write(emu, 17U, (unsigned int )voice, 32639U);
#line 398
  snd_emu10k1_ptr_write(emu, 16U, (unsigned int )voice, 0U);
#line 400
  snd_emu10k1_ptr_write(emu, 134217754U, (unsigned int )voice, 127U);
#line 402
  snd_emu10k1_ptr_write(emu, 134742042U, (unsigned int )voice, 0U);
#line 404
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 405
  return;
}
}
#line 407 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_playback_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int err ;
  struct snd_interval  const  *tmp ;
  struct snd_interval  const  *tmp___0 ;
  int mapped ;

  {
  {
#line 410
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 411
  runtime = substream->runtime;
#line 412
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 415
  tmp = hw_param_interval_c((struct snd_pcm_hw_params  const  *)hw_params, 10);
#line 415
  err = snd_emu10k1_pcm_channel_alloc(epcm, (int )tmp->min);
  }
#line 415
  if (err < 0) {
#line 416
    return (err);
  } else {

  }
  {
#line 417
  tmp___0 = hw_param_interval_c((struct snd_pcm_hw_params  const  *)hw_params, 18);
#line 417
  err = snd_pcm_lib_malloc_pages(substream, (size_t )tmp___0->min);
  }
#line 417
  if (err < 0) {
#line 418
    return (err);
  } else {

  }
#line 419
  if (err > 0) {
#line 421
    if ((unsigned long )epcm->memblk != (unsigned long )((struct snd_util_memblk *)0)) {
      {
#line 422
      snd_emu10k1_free_pages(emu, epcm->memblk);
      }
    } else {

    }
    {
#line 423
    epcm->memblk = snd_emu10k1_alloc_pages(emu, substream);
#line 424
    epcm->start_addr = 0U;
    }
#line 425
    if ((unsigned long )epcm->memblk == (unsigned long )((struct snd_util_memblk *)0)) {
#line 426
      return (-12);
    } else {

    }
#line 427
    mapped = ((struct snd_emu10k1_memblk *)epcm->memblk)->mapped_page;
#line 428
    if (mapped < 0) {
#line 429
      return (-12);
    } else {

    }
#line 430
    epcm->start_addr = (unsigned int )(mapped << 12);
  } else {

  }
#line 432
  return (0);
}
}
#line 435 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_playback_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;

  {
#line 437
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 438
  runtime = substream->runtime;
#line 441
  if ((unsigned long )runtime->private_data == (unsigned long )((void *)0)) {
#line 442
    return (0);
  } else {

  }
#line 443
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 444
  if ((unsigned long )epcm->extra != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 445
    snd_emu10k1_voice_free(epcm->emu, epcm->extra);
#line 446
    epcm->extra = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 448
  if ((unsigned long )epcm->voices[1] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 449
    snd_emu10k1_voice_free(epcm->emu, epcm->voices[1]);
#line 450
    epcm->voices[1] = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 452
  if ((unsigned long )epcm->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 453
    snd_emu10k1_voice_free(epcm->emu, epcm->voices[0]);
#line 454
    epcm->voices[0] = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 456
  if ((unsigned long )epcm->memblk != (unsigned long )((struct snd_util_memblk *)0)) {
    {
#line 457
    snd_emu10k1_free_pages(emu, epcm->memblk);
#line 458
    epcm->memblk = (struct snd_util_memblk *)0;
#line 459
    epcm->start_addr = 0U;
    }
  } else {

  }
  {
#line 461
  snd_pcm_lib_free_pages(substream);
  }
#line 462
  return (0);
}
}
#line 465 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_efx_playback_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int i ;

  {
#line 467
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 468
  runtime = substream->runtime;
#line 472
  if ((unsigned long )runtime->private_data == (unsigned long )((void *)0)) {
#line 473
    return (0);
  } else {

  }
#line 474
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 475
  if ((unsigned long )epcm->extra != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 476
    snd_emu10k1_voice_free(epcm->emu, epcm->extra);
#line 477
    epcm->extra = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 479
  i = 0;
#line 479
  goto ldv_30465;
  ldv_30464: ;
#line 480
  if ((unsigned long )epcm->voices[i] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 481
    snd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);
#line 482
    epcm->voices[i] = (struct snd_emu10k1_voice *)0;
    }
  } else {

  }
#line 479
  i = i + 1;
  ldv_30465: ;
#line 479
  if (i <= 15) {
#line 481
    goto ldv_30464;
  } else {

  }

#line 485
  if ((unsigned long )epcm->memblk != (unsigned long )((struct snd_util_memblk *)0)) {
    {
#line 486
    snd_emu10k1_free_pages(emu, epcm->memblk);
#line 487
    epcm->memblk = (struct snd_util_memblk *)0;
#line 488
    epcm->start_addr = 0U;
    }
  } else {

  }
  {
#line 490
  snd_pcm_lib_free_pages(substream);
  }
#line 491
  return (0);
}
}
#line 494 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_playback_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  unsigned int start_addr ;
  unsigned int end_addr ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 496
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 497
  runtime = substream->runtime;
#line 498
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 501
  start_addr = epcm->start_addr;
#line 502
  tmp = snd_pcm_lib_period_bytes(substream);
#line 502
  end_addr = (unsigned int )tmp;
  }
#line 503
  if (runtime->channels == 2U) {
#line 504
    start_addr = start_addr >> 1;
#line 505
    end_addr = end_addr >> 1;
  } else {

  }
  {
#line 507
  end_addr = end_addr + start_addr;
#line 508
  snd_emu10k1_pcm_init_voice(emu, 1, 1, epcm->extra, start_addr, end_addr, (struct snd_emu10k1_pcm_mixer *)0);
#line 510
  start_addr = epcm->start_addr;
#line 511
  tmp___0 = snd_pcm_lib_buffer_bytes(substream);
#line 511
  end_addr = epcm->start_addr + (unsigned int )tmp___0;
#line 512
  snd_emu10k1_pcm_init_voice(emu, 1, 0, epcm->voices[0], start_addr, end_addr, (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )substream->number);
  }
#line 515
  if ((unsigned long )epcm->voices[1] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
    {
#line 516
    snd_emu10k1_pcm_init_voice(emu, 0, 0, epcm->voices[1], start_addr, end_addr, (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )substream->number);
    }
  } else {

  }
#line 519
  return (0);
}
}
#line 522 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_efx_playback_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  unsigned int start_addr ;
  unsigned int end_addr ;
  unsigned int channel_size ;
  int i ;
  size_t tmp ;

  {
  {
#line 524
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 525
  runtime = substream->runtime;
#line 526
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 531
  start_addr = epcm->start_addr;
#line 532
  tmp = snd_pcm_lib_buffer_bytes(substream);
#line 532
  end_addr = epcm->start_addr + (unsigned int )tmp;
#line 537
  channel_size = (end_addr - start_addr) / 16U;
#line 539
  snd_emu10k1_pcm_init_voice(emu, 1, 1, epcm->extra, start_addr, start_addr + channel_size / 2U,
                             (struct snd_emu10k1_pcm_mixer *)0);
#line 543
  snd_emu10k1_pcm_init_voice(emu, 1, 0, epcm->voices[0], start_addr, start_addr + channel_size,
                             (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer));
#line 547
  start_addr = start_addr + channel_size;
#line 548
  i = 1;
  }
#line 548
  goto ldv_30486;
  ldv_30485: 
  {
#line 549
  snd_emu10k1_pcm_init_voice(emu, 0, 0, epcm->voices[i], start_addr, start_addr + channel_size,
                             (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )i);
#line 552
  start_addr = start_addr + channel_size;
#line 548
  i = i + 1;
  }
  ldv_30486: ;
#line 548
  if (i <= 15) {
#line 550
    goto ldv_30485;
  } else {

  }

#line 555
  return (0);
}
}
#line 558 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hardware snd_emu10k1_efx_playback  = 
#line 558
     {852483U, 4ULL, 128U, 48000U, 48000U, 16U, 16U, 65536UL, 64UL, 65536UL, 2U, 2U,
    0UL};
#line 578 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_interval  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 581
  tmp = hw_param_interval_c((struct snd_pcm_hw_params  const  *)hw_params, 18);
#line 581
  tmp___0 = snd_pcm_lib_malloc_pages(substream, (size_t )tmp->min);
  }
#line 581
  return (tmp___0);
}
}
#line 584 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_hw_free(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  {
#line 586
  tmp = snd_pcm_lib_free_pages(substream);
  }
#line 586
  return (tmp);
}
}
#line 589 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int idx ;
  size_t tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 591
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 592
  runtime = substream->runtime;
#line 593
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 597
  snd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0U, 0U);
  }
  {
#line 599
  if (epcm->type == 2) {
#line 599
    goto case_2;
  } else {

  }
#line 602
  if (epcm->type == 4) {
#line 602
    goto case_4;
  } else {

  }
#line 609
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 600
  snd_emu10k1_ptr_write(emu, 66U, 0U, 0U);
  }
#line 601
  goto ldv_30504;
  case_4: /* CIL Label */ ;
#line 603
  if (emu->audigy != 0U) {
    {
#line 604
    snd_emu10k1_ptr_write(emu, 116U, 0U, 0U);
#line 605
    snd_emu10k1_ptr_write(emu, 117U, 0U, 0U);
    }
  } else {
    {
#line 607
    snd_emu10k1_ptr_write(emu, 67U, 0U, 0U);
    }
  }
#line 608
  goto ldv_30504;
  switch_default: /* CIL Label */ ;
#line 610
  goto ldv_30504;
  switch_break: /* CIL Label */ ;
  }
  ldv_30504: 
  {
#line 612
  snd_emu10k1_ptr_write(emu, epcm->capture_ba_reg, 0U, (unsigned int )runtime->dma_addr);
#line 613
  tmp = snd_pcm_lib_buffer_bytes(substream);
#line 613
  epcm->capture_bufsize = (unsigned int )tmp;
#line 614
  epcm->capture_bs_val = 0U;
#line 615
  idx = 0;
  }
#line 615
  goto ldv_30509;
  ldv_30508: ;
#line 616
  if (capture_period_sizes[idx] == epcm->capture_bufsize) {
#line 617
    epcm->capture_bs_val = (unsigned int )(idx + 1);
#line 618
    goto ldv_30507;
  } else {

  }
#line 615
  idx = idx + 1;
  ldv_30509: ;
#line 615
  if (idx <= 30) {
#line 617
    goto ldv_30508;
  } else {

  }
  ldv_30507: ;
#line 621
  if (epcm->capture_bs_val == 0U) {
    {
#line 622
    __ret_warn_on = 1;
#line 622
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 622
    if (tmp___0 != 0L) {
      {
#line 622
      warn_slowpath_fmt("sound/pci/emu10k1/emupcm.c", 622, "BUG?\n");
      }
    } else {

    }
    {
#line 622
    __builtin_expect(__ret_warn_on != 0, 0L);
#line 623
    epcm->capture_bs_val = epcm->capture_bs_val + 1U;
    }
  } else {

  }
#line 625
  if (epcm->type == 2) {
#line 626
    epcm->capture_cr_val = emu->audigy != 0U ? 16U : 8U;
#line 627
    if (runtime->channels > 1U) {
#line 628
      epcm->capture_cr_val = epcm->capture_cr_val | (emu->audigy != 0U ? 32U : 16U);
    } else {

    }
#line 629
    if (emu->audigy != 0U) {
      {
#line 629
      tmp___1 = snd_emu10k1_audigy_capture_rate_reg(runtime->rate);
#line 629
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 629
      tmp___2 = snd_emu10k1_capture_rate_reg(runtime->rate);
#line 629
      tmp___3 = tmp___2;
      }
    }
#line 629
    epcm->capture_cr_val = epcm->capture_cr_val | tmp___3;
  } else {

  }
#line 633
  return (0);
}
}
#line 636 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_playback_invalidate_cache(struct snd_emu10k1 *emu , int extra ,
                                                  struct snd_emu10k1_voice *evoice ) 
{ 
  struct snd_pcm_runtime *runtime ;
  unsigned int voice ;
  unsigned int stereo ;
  unsigned int i ;
  unsigned int ccis ;
  unsigned int cra ;
  unsigned int cs ;
  unsigned int sample ;
  int tmp ;
  int tmp___0 ;

  {
#line 639
  cra = 64U;
#line 641
  if ((unsigned long )evoice == (unsigned long )((struct snd_emu10k1_voice *)0)) {
#line 642
    return;
  } else {

  }
  {
#line 643
  runtime = ((evoice->epcm)->substream)->runtime;
#line 644
  voice = (unsigned int )evoice->number;
#line 645
  stereo = (unsigned int )(extra == 0 && runtime->channels == 2U);
#line 646
  tmp = snd_pcm_format_width(runtime->format);
#line 646
  sample = tmp == 16 ? 0U : 2155905152U;
#line 647
  tmp___0 = emu10k1_ccis((int )stereo, sample == 0U);
#line 647
  ccis = (unsigned int )tmp___0;
#line 649
  cs = sample == 0U ? 32U - ccis : (65U - ccis) >> 1;
  }
#line 650
  if (cs > 16U) {
#line 650
    cs = 16U;
  } else {

  }
#line 651
  i = 0U;
#line 651
  goto ldv_30526;
  ldv_30525: 
  {
#line 652
  snd_emu10k1_ptr_write(emu, i + 32U, voice, sample);
  }
#line 653
  if (stereo != 0U) {
    {
#line 654
    snd_emu10k1_ptr_write(emu, i + 32U, voice + 1U, sample);
    }
  } else {

  }
#line 651
  i = i + 1U;
  ldv_30526: ;
#line 651
  if (i < cs) {
#line 653
    goto ldv_30525;
  } else {

  }
  {
#line 658
  snd_emu10k1_ptr_write(emu, 119078921U, voice, 0U);
#line 659
  snd_emu10k1_ptr_write(emu, 101711881U, voice, cra);
  }
#line 660
  if (stereo != 0U) {
    {
#line 661
    snd_emu10k1_ptr_write(emu, 119078921U, voice + 1U, 0U);
#line 662
    snd_emu10k1_ptr_write(emu, 101711881U, voice + 1U, cra);
    }
  } else {

  }
  {
#line 665
  snd_emu10k1_ptr_write(emu, 119078921U, voice, ccis);
  }
#line 666
  if (stereo != 0U) {
    {
#line 667
    snd_emu10k1_ptr_write(emu, 119078921U, voice + 1U, ccis);
    }
  } else {

  }
#line 668
  return;
}
}
#line 671 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_playback_prepare_voice(struct snd_emu10k1 *emu , struct snd_emu10k1_voice *evoice ,
                                               int master , int extra , struct snd_emu10k1_pcm_mixer *mix ) 
{ 
  struct snd_pcm_substream *substream ;
  struct snd_pcm_runtime *runtime ;
  unsigned int attn ;
  unsigned int vattn ;
  unsigned int voice ;
  unsigned int tmp ;

  {
#line 680
  if ((unsigned long )evoice == (unsigned long )((struct snd_emu10k1_voice *)0)) {
#line 681
    return;
  } else {

  }
  {
#line 682
  substream = (evoice->epcm)->substream;
#line 683
  runtime = substream->runtime;
#line 684
  voice = (unsigned int )evoice->number;
#line 686
  attn = extra != 0 ? 0U : 255U;
#line 687
  tmp = runtime->channels == 2U ? (master != 0 ? 1U : 2U) : 0U;
#line 688
  vattn = (unsigned long )mix != (unsigned long )((struct snd_emu10k1_pcm_mixer *)0) ? (unsigned int )((int )mix->attn[tmp] << 16) : 0U;
#line 689
  snd_emu10k1_ptr_write(emu, 25U, voice, attn);
#line 690
  snd_emu10k1_ptr_write(emu, 3U, voice, vattn | 65535U);
#line 691
  snd_emu10k1_ptr_write(emu, 2U, voice, vattn | 65535U);
#line 692
  snd_emu10k1_ptr_write(emu, 18U, voice, 32639U);
#line 693
  snd_emu10k1_voice_clear_loop_stop(emu, voice);
  }
#line 694
  return;
}
}
#line 696 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_playback_trigger_voice(struct snd_emu10k1 *emu , struct snd_emu10k1_voice *evoice ,
                                               int master , int extra ) 
{ 
  struct snd_pcm_substream *substream ;
  struct snd_pcm_runtime *runtime ;
  unsigned int voice ;
  unsigned int pitch ;
  unsigned int pitch_target ;
  unsigned int tmp ;

  {
#line 702
  if ((unsigned long )evoice == (unsigned long )((struct snd_emu10k1_voice *)0)) {
#line 703
    return;
  } else {

  }
  {
#line 704
  substream = (evoice->epcm)->substream;
#line 705
  runtime = substream->runtime;
#line 706
  voice = (unsigned int )evoice->number;
#line 708
  tmp = snd_emu10k1_rate_to_pitch(runtime->rate);
#line 708
  pitch = tmp >> 8;
  }
#line 709
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
#line 710
    pitch_target = 16384U;
  } else {
    {
#line 712
    pitch_target = emu10k1_calc_pitch_target(runtime->rate);
    }
  }
  {
#line 713
  snd_emu10k1_ptr_write(emu, 269484033U, voice, pitch_target);
  }
#line 714
  if (master != 0 || (evoice->epcm)->type == 1) {
    {
#line 715
    snd_emu10k1_ptr_write(emu, 269484032U, voice, pitch_target);
    }
  } else {

  }
  {
#line 716
  snd_emu10k1_ptr_write(emu, 24U, voice, pitch);
  }
#line 717
  if (extra != 0) {
    {
#line 718
    snd_emu10k1_voice_intr_enable(emu, voice);
    }
  } else {

  }
#line 719
  return;
}
}
#line 721 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_playback_stop_voice(struct snd_emu10k1 *emu , struct snd_emu10k1_voice *evoice ) 
{ 
  unsigned int voice ;

  {
#line 725
  if ((unsigned long )evoice == (unsigned long )((struct snd_emu10k1_voice *)0)) {
#line 726
    return;
  } else {

  }
  {
#line 727
  voice = (unsigned int )evoice->number;
#line 728
  snd_emu10k1_voice_intr_disable(emu, voice);
#line 729
  snd_emu10k1_ptr_write(emu, 269484033U, voice, 0U);
#line 730
  snd_emu10k1_ptr_write(emu, 269484032U, voice, 0U);
#line 731
  snd_emu10k1_ptr_write(emu, 25U, voice, 65535U);
#line 732
  snd_emu10k1_ptr_write(emu, 3U, voice, 65535U);
#line 733
  snd_emu10k1_ptr_write(emu, 2U, voice, 65535U);
#line 734
  snd_emu10k1_ptr_write(emu, 24U, voice, 0U);
  }
#line 735
  return;
}
}
#line 737 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
__inline static void snd_emu10k1_playback_mangle_extra(struct snd_emu10k1 *emu , struct snd_emu10k1_pcm *epcm ,
                                                       struct snd_pcm_substream *substream ,
                                                       struct snd_pcm_runtime *runtime ) 
{ 
  unsigned int ptr ;
  unsigned int period_pos ;

  {
  {
#line 746
  period_pos = (unsigned int )(runtime->status)->hw_ptr - (unsigned int )runtime->hw_ptr_interrupt;
#line 747
  period_pos = (unsigned int )((snd_pcm_uframes_t )period_pos % runtime->period_size);
#line 748
  ptr = snd_emu10k1_ptr_read(emu, 8U, (unsigned int )(epcm->extra)->number);
#line 749
  ptr = ptr & 4278190080U;
#line 750
  ptr = ptr | (epcm->ccca_start_addr + period_pos);
#line 751
  snd_emu10k1_ptr_write(emu, 8U, (unsigned int )(epcm->extra)->number, ptr);
  }
#line 752
  return;
}
}
#line 754 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_playback_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_emu10k1_pcm_mixer *mix ;
  int result ;

  {
  {
#line 757
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 758
  runtime = substream->runtime;
#line 759
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 761
  result = 0;
#line 767
  ldv_spin_lock_35___0(& emu->reg_lock);
  }
  {
#line 769
  if (cmd == 1) {
#line 769
    goto case_1;
  } else {

  }
#line 773
  if (cmd == 4) {
#line 773
    goto case_4;
  } else {

  }
#line 774
  if (cmd == 6) {
#line 774
    goto case_6;
  } else {

  }
#line 786
  if (cmd == 0) {
#line 786
    goto case_0;
  } else {

  }
#line 787
  if (cmd == 3) {
#line 787
    goto case_3;
  } else {

  }
#line 788
  if (cmd == 5) {
#line 788
    goto case_5;
  } else {

  }
#line 794
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 770
  snd_emu10k1_playback_invalidate_cache(emu, 1, epcm->extra);
#line 771
  snd_emu10k1_playback_invalidate_cache(emu, 0, epcm->voices[0]);
  }
  case_4: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
#line 775
  if (cmd == 4) {
    {
#line 776
    snd_emu10k1_playback_mangle_extra(emu, epcm, substream, runtime);
    }
  } else {

  }
  {
#line 777
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )substream->number;
#line 778
  snd_emu10k1_playback_prepare_voice(emu, epcm->voices[0], 1, 0, mix);
#line 779
  snd_emu10k1_playback_prepare_voice(emu, epcm->voices[1], 0, 0, mix);
#line 780
  snd_emu10k1_playback_prepare_voice(emu, epcm->extra, 1, 1, (struct snd_emu10k1_pcm_mixer *)0);
#line 781
  snd_emu10k1_playback_trigger_voice(emu, epcm->voices[0], 1, 0);
#line 782
  snd_emu10k1_playback_trigger_voice(emu, epcm->voices[1], 0, 0);
#line 783
  snd_emu10k1_playback_trigger_voice(emu, epcm->extra, 1, 1);
#line 784
  epcm->running = 1U;
  }
#line 785
  goto ldv_30577;
  case_0: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_5: /* CIL Label */ 
  {
#line 789
  epcm->running = 0U;
#line 790
  snd_emu10k1_playback_stop_voice(emu, epcm->voices[0]);
#line 791
  snd_emu10k1_playback_stop_voice(emu, epcm->voices[1]);
#line 792
  snd_emu10k1_playback_stop_voice(emu, epcm->extra);
  }
#line 793
  goto ldv_30577;
  switch_default: /* CIL Label */ 
#line 795
  result = -22;
#line 796
  goto ldv_30577;
  switch_break: /* CIL Label */ ;
  }
  ldv_30577: 
  {
#line 798
  ldv_spin_unlock_36___0(& emu->reg_lock);
  }
#line 799
  return (result);
}
}
#line 802 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int result ;

  {
  {
#line 805
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 806
  runtime = substream->runtime;
#line 807
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 808
  result = 0;
#line 810
  ldv_spin_lock_35___0(& emu->reg_lock);
  }
  {
#line 812
  if (cmd == 1) {
#line 812
    goto case_1;
  } else {

  }
#line 813
  if (cmd == 6) {
#line 813
    goto case_6;
  } else {

  }
#line 840
  if (cmd == 0) {
#line 840
    goto case_0;
  } else {

  }
#line 841
  if (cmd == 5) {
#line 841
    goto case_5;
  } else {

  }
#line 861
  goto switch_default___1;
  case_1: /* CIL Label */ ;
  case_6: /* CIL Label */ 
  {
#line 815
  outl(epcm->capture_ipr, (int )((unsigned int )emu->port + 8U));
#line 816
  snd_emu10k1_intr_enable(emu, epcm->capture_inte);
  }
  {
#line 822
  if (epcm->type == 2) {
#line 822
    goto case_2;
  } else {

  }
#line 825
  if (epcm->type == 4) {
#line 825
    goto case_4;
  } else {

  }
#line 833
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 823
  snd_emu10k1_ptr_write(emu, 66U, 0U, epcm->capture_cr_val);
  }
#line 824
  goto ldv_30593;
  case_4: /* CIL Label */ ;
#line 826
  if (emu->audigy != 0U) {
    {
#line 827
    snd_emu10k1_ptr_write(emu, 116U, 0U, epcm->capture_cr_val);
#line 828
    snd_emu10k1_ptr_write(emu, 117U, 0U, epcm->capture_cr_val2);
#line 829
    __snd_printk(2U, "sound/pci/emu10k1/emupcm.c", 829, "cr_val=0x%x, cr_val2=0x%x\n",
                 epcm->capture_cr_val, epcm->capture_cr_val2);
    }
  } else {
    {
#line 831
    snd_emu10k1_ptr_write(emu, 67U, 0U, epcm->capture_cr_val);
    }
  }
#line 832
  goto ldv_30593;
  switch_default: /* CIL Label */ ;
#line 834
  goto ldv_30593;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_30593: 
  {
#line 836
  snd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0U, epcm->capture_bs_val);
#line 837
  epcm->running = 1U;
#line 838
  epcm->first_ptr = 1U;
  }
#line 839
  goto ldv_30596;
  case_0: /* CIL Label */ ;
  case_5: /* CIL Label */ 
  {
#line 842
  epcm->running = 0U;
#line 843
  snd_emu10k1_intr_disable(emu, epcm->capture_inte);
#line 844
  outl(epcm->capture_ipr, (int )((unsigned int )emu->port + 8U));
#line 845
  snd_emu10k1_ptr_write(emu, epcm->capture_bs_reg, 0U, 0U);
  }
  {
#line 847
  if (epcm->type == 2) {
#line 847
    goto case_2___0;
  } else {

  }
#line 850
  if (epcm->type == 4) {
#line 850
    goto case_4___0;
  } else {

  }
#line 857
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  {
#line 848
  snd_emu10k1_ptr_write(emu, 66U, 0U, 0U);
  }
#line 849
  goto ldv_30600;
  case_4___0: /* CIL Label */ ;
#line 851
  if (emu->audigy != 0U) {
    {
#line 852
    snd_emu10k1_ptr_write(emu, 116U, 0U, 0U);
#line 853
    snd_emu10k1_ptr_write(emu, 117U, 0U, 0U);
    }
  } else {
    {
#line 855
    snd_emu10k1_ptr_write(emu, 67U, 0U, 0U);
    }
  }
#line 856
  goto ldv_30600;
  switch_default___0: /* CIL Label */ ;
#line 858
  goto ldv_30600;
  switch_break___1: /* CIL Label */ ;
  }
  ldv_30600: ;
#line 860
  goto ldv_30596;
  switch_default___1: /* CIL Label */ 
#line 862
  result = -22;
  switch_break: /* CIL Label */ ;
  }
  ldv_30596: 
  {
#line 864
  ldv_spin_unlock_36___0(& emu->reg_lock);
  }
#line 865
  return (result);
}
}
#line 868 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static snd_pcm_uframes_t snd_emu10k1_playback_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  unsigned int ptr ;
  unsigned int tmp ;

  {
#line 870
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 871
  runtime = substream->runtime;
#line 872
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 875
  if ((unsigned int )epcm->running == 0U) {
#line 876
    return (0UL);
  } else {

  }
  {
#line 877
  tmp = snd_emu10k1_ptr_read(emu, 8U, (unsigned int )(epcm->voices[0])->number);
#line 877
  ptr = tmp & 16777215U;
  }
#line 883
  if (ptr < epcm->ccca_start_addr) {
#line 884
    ptr = ptr + ((unsigned int )runtime->buffer_size - epcm->ccca_start_addr);
  } else {
#line 886
    ptr = ptr - epcm->ccca_start_addr;
#line 887
    if ((snd_pcm_uframes_t )ptr >= runtime->buffer_size) {
#line 888
      ptr = ptr - (unsigned int )runtime->buffer_size;
    } else {

    }
  }
#line 897
  return ((snd_pcm_uframes_t )ptr);
}
}
#line 901 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_efx_playback_trigger(struct snd_pcm_substream *substream ,
                                            int cmd ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int i ;
  int result ;

  {
  {
#line 904
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 905
  runtime = substream->runtime;
#line 906
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 908
  result = 0;
#line 910
  ldv_spin_lock_35___0(& emu->reg_lock);
  }
  {
#line 912
  if (cmd == 1) {
#line 912
    goto case_1;
  } else {

  }
#line 920
  if (cmd == 4) {
#line 920
    goto case_4;
  } else {

  }
#line 921
  if (cmd == 6) {
#line 921
    goto case_6;
  } else {

  }
#line 934
  if (cmd == 5) {
#line 934
    goto case_5;
  } else {

  }
#line 935
  if (cmd == 0) {
#line 935
    goto case_0;
  } else {

  }
#line 936
  if (cmd == 3) {
#line 936
    goto case_3;
  } else {

  }
#line 943
  goto switch_default;
  case_1: /* CIL Label */ 
#line 914
  i = 0;
#line 914
  goto ldv_30622;
  ldv_30621: 
  {
#line 915
  snd_emu10k1_playback_invalidate_cache(emu, 0, epcm->voices[i]);
#line 914
  i = i + 1;
  }
  ldv_30622: ;
#line 914
  if (i <= 15) {
#line 916
    goto ldv_30621;
  } else {

  }
  {
#line 917
  snd_emu10k1_playback_invalidate_cache(emu, 1, epcm->extra);
  }
  case_4: /* CIL Label */ ;
  case_6: /* CIL Label */ 
  {
#line 922
  snd_emu10k1_playback_prepare_voice(emu, epcm->extra, 1, 1, (struct snd_emu10k1_pcm_mixer *)0);
#line 923
  snd_emu10k1_playback_prepare_voice(emu, epcm->voices[0], 0, 0, (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer));
#line 925
  i = 1;
  }
#line 925
  goto ldv_30627;
  ldv_30626: 
  {
#line 926
  snd_emu10k1_playback_prepare_voice(emu, epcm->voices[i], 0, 0, (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )i);
#line 925
  i = i + 1;
  }
  ldv_30627: ;
#line 925
  if (i <= 15) {
#line 927
    goto ldv_30626;
  } else {

  }
  {
#line 928
  snd_emu10k1_playback_trigger_voice(emu, epcm->voices[0], 0, 0);
#line 929
  snd_emu10k1_playback_trigger_voice(emu, epcm->extra, 1, 1);
#line 930
  i = 1;
  }
#line 930
  goto ldv_30630;
  ldv_30629: 
  {
#line 931
  snd_emu10k1_playback_trigger_voice(emu, epcm->voices[i], 0, 0);
#line 930
  i = i + 1;
  }
  ldv_30630: ;
#line 930
  if (i <= 15) {
#line 932
    goto ldv_30629;
  } else {

  }
#line 932
  epcm->running = 1U;
#line 933
  goto ldv_30632;
  case_5: /* CIL Label */ ;
  case_0: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 937
  epcm->running = 0U;
#line 938
  i = 0;
#line 938
  goto ldv_30637;
  ldv_30636: 
  {
#line 939
  snd_emu10k1_playback_stop_voice(emu, epcm->voices[i]);
#line 938
  i = i + 1;
  }
  ldv_30637: ;
#line 938
  if (i <= 15) {
#line 940
    goto ldv_30636;
  } else {

  }
  {
#line 941
  snd_emu10k1_playback_stop_voice(emu, epcm->extra);
  }
#line 942
  goto ldv_30632;
  switch_default: /* CIL Label */ 
#line 944
  result = -22;
#line 945
  goto ldv_30632;
  switch_break: /* CIL Label */ ;
  }
  ldv_30632: 
  {
#line 947
  ldv_spin_unlock_36___0(& emu->reg_lock);
  }
#line 948
  return (result);
}
}
#line 952 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static snd_pcm_uframes_t snd_emu10k1_capture_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  unsigned int ptr ;
  unsigned int tmp ;
  snd_pcm_sframes_t tmp___0 ;

  {
#line 954
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 955
  runtime = substream->runtime;
#line 956
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 959
  if ((unsigned int )epcm->running == 0U) {
#line 960
    return (0UL);
  } else {

  }
#line 961
  if ((unsigned int )epcm->first_ptr != 0U) {
    {
#line 962
    __const_udelay(214750UL);
#line 963
    epcm->first_ptr = 0U;
    }
  } else {

  }
  {
#line 965
  tmp = snd_emu10k1_ptr_read(emu, epcm->capture_idx_reg, 0U);
#line 965
  ptr = tmp & 65535U;
#line 966
  tmp___0 = bytes_to_frames(runtime, (ssize_t )ptr);
  }
#line 966
  return ((snd_pcm_uframes_t )tmp___0);
}
}
#line 973 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hardware snd_emu10k1_playback  = 
#line 973
     {852227U, 6ULL, 1073743870U, 4000U, 96000U, 1U, 2U, 131072UL, 64UL, 131072UL, 1U,
    1024U, 0UL};
#line 997 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hardware snd_emu10k1_capture  = 
#line 997
     {327939U, 4ULL, 254U, 8000U, 48000U, 1U, 2U, 65536UL, 384UL, 65536UL, 2U, 2U, 0UL};
#line 1017 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hardware snd_emu10k1_capture_efx  = 
#line 1017
     {327939U, 4ULL, 7872U, 44100U, 192000U, 8U, 8U, 65536UL, 384UL, 65536UL, 2U, 2U,
    0UL};
#line 1043 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_mixer_notify1(struct snd_emu10k1 *emu , struct snd_kcontrol *kctl ,
                                          int idx , int activate ) 
{ 
  struct snd_ctl_elem_id id___0 ;
  struct snd_ctl_elem_id *tmp ;

  {
#line 1047
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1048
    return;
  } else {

  }
#line 1049
  if (activate != 0) {
#line 1050
    kctl->vd[idx].access = kctl->vd[idx].access & 4294967039U;
  } else {
#line 1052
    kctl->vd[idx].access = kctl->vd[idx].access | 256U;
  }
  {
#line 1053
  tmp = snd_ctl_build_ioff(& id___0, kctl, (unsigned int )idx);
#line 1053
  snd_ctl_notify(emu->card, 3U, tmp);
  }
#line 1056
  return;
}
}
#line 1058 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_mixer_notify(struct snd_emu10k1 *emu , int idx , int activate ) 
{ 


  {
  {
#line 1060
  snd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_send_routing, idx, activate);
#line 1061
  snd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_send_volume, idx, activate);
#line 1062
  snd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_attn, idx, activate);
  }
#line 1063
  return;
}
}
#line 1065 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_efx_mixer_notify(struct snd_emu10k1 *emu , int idx , int activate ) 
{ 


  {
  {
#line 1067
  snd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_send_routing, idx, activate);
#line 1068
  snd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_send_volume, idx, activate);
#line 1069
  snd_emu10k1_pcm_mixer_notify1(emu, emu->ctl_efx_attn, idx, activate);
  }
#line 1070
  return;
}
}
#line 1072 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_pcm_free_substream(struct snd_pcm_runtime *runtime ) 
{ 


  {
  {
#line 1074
  kfree((void const   *)runtime->private_data);
  }
#line 1075
  return;
}
}
#line 1077 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_efx_playback_close(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  int i ;

  {
#line 1079
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1083
  i = 0;
#line 1083
  goto ldv_30677;
  ldv_30676: 
  {
#line 1084
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )i;
#line 1085
  mix->epcm = (struct snd_emu10k1_pcm *)0;
#line 1086
  snd_emu10k1_pcm_efx_mixer_notify(emu, i, 0);
#line 1083
  i = i + 1;
  }
  ldv_30677: ;
#line 1083
  if (i <= 15) {
#line 1085
    goto ldv_30676;
  } else {

  }

#line 1088
  return (0);
}
}
#line 1091 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_efx_playback_open(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_emu10k1_pcm_mixer *mix ;
  struct snd_pcm_runtime *runtime ;
  int i ;
  void *tmp ;

  {
  {
#line 1093
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1096
  runtime = substream->runtime;
#line 1099
  tmp = kzalloc(224UL, 208U);
#line 1099
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 1100
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1101
    return (-12);
  } else {

  }
#line 1102
  epcm->emu = emu;
#line 1103
  epcm->type = 1;
#line 1104
  epcm->substream = substream;
#line 1106
  emu->pcm_playback_efx_substream = substream;
#line 1108
  runtime->private_data = (void *)epcm;
#line 1109
  runtime->private_free = & snd_emu10k1_pcm_free_substream;
#line 1110
  runtime->hw = snd_emu10k1_efx_playback;
#line 1112
  i = 0;
#line 1112
  goto ldv_30688;
  ldv_30687: 
  {
#line 1113
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )i;
#line 1114
  mix->send_routing[0][0] = (unsigned char )i;
#line 1115
  memset((void *)(& mix->send_volume), 0, 24UL);
#line 1116
  mix->send_volume[0][0] = 255U;
#line 1117
  mix->attn[0] = 65535U;
#line 1118
  mix->epcm = epcm;
#line 1119
  snd_emu10k1_pcm_efx_mixer_notify(emu, i, 1);
#line 1112
  i = i + 1;
  }
  ldv_30688: ;
#line 1112
  if (i <= 15) {
#line 1114
    goto ldv_30687;
  } else {

  }

#line 1121
  return (0);
}
}
#line 1124 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_playback_open(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_emu10k1_pcm_mixer *mix ;
  struct snd_pcm_runtime *runtime ;
  int i ;
  int err ;
  void *tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;

  {
  {
#line 1126
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1129
  runtime = substream->runtime;
#line 1132
  tmp = kzalloc(224UL, 208U);
#line 1132
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 1133
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1134
    return (-12);
  } else {

  }
  {
#line 1135
  epcm->emu = emu;
#line 1136
  epcm->type = 0;
#line 1137
  epcm->substream = substream;
#line 1138
  runtime->private_data = (void *)epcm;
#line 1139
  runtime->private_free = & snd_emu10k1_pcm_free_substream;
#line 1140
  runtime->hw = snd_emu10k1_playback;
#line 1141
  err = snd_pcm_hw_constraint_integer(runtime, 15);
  }
#line 1141
  if (err < 0) {
    {
#line 1142
    kfree((void const   *)epcm);
    }
#line 1143
    return (err);
  } else {

  }
  {
#line 1145
  err = snd_pcm_hw_constraint_minmax(runtime, 18, 256U, 4294967295U);
  }
#line 1145
  if (err < 0) {
    {
#line 1146
    kfree((void const   *)epcm);
    }
#line 1147
    return (err);
  } else {

  }
  {
#line 1149
  err = snd_pcm_hw_rule_noresample(runtime, 48000U);
  }
#line 1150
  if (err < 0) {
    {
#line 1151
    kfree((void const   *)epcm);
    }
#line 1152
    return (err);
  } else {

  }
#line 1154
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )substream->number;
#line 1155
  i = 0;
#line 1155
  goto ldv_30700;
  ldv_30699: 
#line 1156
  tmp___1 = (unsigned char )i;
#line 1156
  mix->send_routing[2][i] = tmp___1;
#line 1156
  tmp___0 = tmp___1;
#line 1156
  mix->send_routing[1][i] = tmp___0;
#line 1156
  mix->send_routing[0][i] = tmp___0;
#line 1155
  i = i + 1;
  ldv_30700: ;
#line 1155
  if (i <= 3) {
#line 1157
    goto ldv_30699;
  } else {

  }
  {
#line 1157
  memset((void *)(& mix->send_volume), 0, 24UL);
#line 1158
  tmp___4 = 255U;
#line 1158
  mix->send_volume[2][1] = tmp___4;
#line 1158
  tmp___3 = tmp___4;
#line 1158
  mix->send_volume[1][0] = tmp___3;
#line 1158
  tmp___2 = tmp___3;
#line 1158
  mix->send_volume[0][1] = tmp___2;
#line 1158
  mix->send_volume[0][0] = tmp___2;
#line 1160
  tmp___6 = 65535U;
#line 1160
  mix->attn[2] = tmp___6;
#line 1160
  tmp___5 = tmp___6;
#line 1160
  mix->attn[1] = tmp___5;
#line 1160
  mix->attn[0] = tmp___5;
#line 1161
  mix->epcm = epcm;
#line 1162
  snd_emu10k1_pcm_mixer_notify(emu, substream->number, 1);
  }
#line 1163
  return (0);
}
}
#line 1166 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_playback_close(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;

  {
  {
#line 1168
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1169
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )substream->number;
#line 1171
  mix->epcm = (struct snd_emu10k1_pcm *)0;
#line 1172
  snd_emu10k1_pcm_mixer_notify(emu, substream->number, 0);
  }
#line 1173
  return (0);
}
}
#line 1176 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_open(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  void *tmp ;

  {
  {
#line 1178
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1179
  runtime = substream->runtime;
#line 1182
  tmp = kzalloc(224UL, 208U);
#line 1182
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 1183
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1184
    return (-12);
  } else {

  }
  {
#line 1185
  epcm->emu = emu;
#line 1186
  epcm->type = 2;
#line 1187
  epcm->substream = substream;
#line 1188
  epcm->capture_ipr = 49152U;
#line 1189
  epcm->capture_inte = 64U;
#line 1190
  epcm->capture_ba_reg = 70U;
#line 1191
  epcm->capture_bs_reg = 74U;
#line 1192
  epcm->capture_idx_reg = emu->audigy != 0U ? 99U : 100U;
#line 1193
  runtime->private_data = (void *)epcm;
#line 1194
  runtime->private_free = & snd_emu10k1_pcm_free_substream;
#line 1195
  runtime->hw = snd_emu10k1_capture;
#line 1196
  emu->capture_interrupt = & snd_emu10k1_pcm_ac97adc_interrupt;
#line 1197
  emu->pcm_capture_substream = substream;
#line 1198
  snd_pcm_hw_constraint_list(runtime, 0U, 14, & hw_constraints_capture_period_sizes);
#line 1199
  snd_pcm_hw_constraint_list(runtime, 0U, 11, & hw_constraints_capture_rates);
  }
#line 1200
  return (0);
}
}
#line 1203 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_close(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1205
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1207
  emu->capture_interrupt = (void (*)(struct snd_emu10k1 * , unsigned int  ))0;
#line 1208
  emu->pcm_capture_substream = (struct snd_pcm_substream *)0;
#line 1209
  return (0);
}
}
#line 1212 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_mic_open(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_pcm_runtime *runtime ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 1214
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1216
  runtime = substream->runtime;
#line 1218
  tmp = kzalloc(224UL, 208U);
#line 1218
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 1219
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1220
    return (-12);
  } else {

  }
  {
#line 1221
  epcm->emu = emu;
#line 1222
  epcm->type = 3;
#line 1223
  epcm->substream = substream;
#line 1224
  epcm->capture_ipr = 196608U;
#line 1225
  epcm->capture_inte = 128U;
#line 1226
  epcm->capture_ba_reg = 69U;
#line 1227
  epcm->capture_bs_reg = 73U;
#line 1228
  epcm->capture_idx_reg = emu->audigy != 0U ? 100U : 99U;
#line 1229
  (substream->runtime)->private_data = (void *)epcm;
#line 1230
  (substream->runtime)->private_free = & snd_emu10k1_pcm_free_substream;
#line 1231
  runtime->hw = snd_emu10k1_capture;
#line 1232
  runtime->hw.rates = 2U;
#line 1233
  tmp___0 = 8000U;
#line 1233
  runtime->hw.rate_max = tmp___0;
#line 1233
  runtime->hw.rate_min = tmp___0;
#line 1234
  runtime->hw.channels_min = 1U;
#line 1235
  emu->capture_mic_interrupt = & snd_emu10k1_pcm_ac97mic_interrupt;
#line 1236
  emu->pcm_capture_mic_substream = substream;
#line 1237
  snd_pcm_hw_constraint_list(runtime, 0U, 14, & hw_constraints_capture_period_sizes);
  }
#line 1238
  return (0);
}
}
#line 1241 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_mic_close(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1243
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1245
  emu->capture_interrupt = (void (*)(struct snd_emu10k1 * , unsigned int  ))0;
#line 1246
  emu->pcm_capture_mic_substream = (struct snd_pcm_substream *)0;
#line 1247
  return (0);
}
}
#line 1250 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_efx_open(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_pcm_runtime *runtime ;
  int nefx ;
  int idx ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 1252
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1254
  runtime = substream->runtime;
#line 1255
  nefx = emu->audigy != 0U ? 64 : 32;
#line 1258
  tmp = kzalloc(224UL, 208U);
#line 1258
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 1259
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1260
    return (-12);
  } else {

  }
  {
#line 1261
  epcm->emu = emu;
#line 1262
  epcm->type = 4;
#line 1263
  epcm->substream = substream;
#line 1264
  epcm->capture_ipr = 12288U;
#line 1265
  epcm->capture_inte = 32U;
#line 1266
  epcm->capture_ba_reg = 71U;
#line 1267
  epcm->capture_bs_reg = 75U;
#line 1268
  epcm->capture_idx_reg = 101U;
#line 1269
  (substream->runtime)->private_data = (void *)epcm;
#line 1270
  (substream->runtime)->private_free = & snd_emu10k1_pcm_free_substream;
#line 1271
  runtime->hw = snd_emu10k1_capture_efx;
#line 1272
  runtime->hw.rates = 128U;
#line 1273
  tmp___0 = 48000U;
#line 1273
  runtime->hw.rate_max = tmp___0;
#line 1273
  runtime->hw.rate_min = tmp___0;
#line 1274
  ldv_spin_lock_irq_41(& emu->reg_lock);
  }
#line 1275
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 1299
    if (emu->emu1010.internal_clock == 0U) {
#line 1299
      goto case_0;
    } else {

    }
#line 1306
    if (emu->emu1010.internal_clock == 1U) {
#line 1306
      goto case_1;
    } else {

    }
#line 1298
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1301
    runtime->hw.rates = 64U;
#line 1302
    tmp___1 = 44100U;
#line 1302
    runtime->hw.rate_max = tmp___1;
#line 1302
    runtime->hw.rate_min = tmp___1;
#line 1303
    tmp___2 = 16U;
#line 1303
    runtime->hw.channels_max = tmp___2;
#line 1303
    runtime->hw.channels_min = tmp___2;
#line 1305
    goto ldv_30736;
    case_1: /* CIL Label */ 
#line 1308
    runtime->hw.rates = 128U;
#line 1309
    tmp___3 = 48000U;
#line 1309
    runtime->hw.rate_max = tmp___3;
#line 1309
    runtime->hw.rate_min = tmp___3;
#line 1310
    tmp___4 = 16U;
#line 1310
    runtime->hw.channels_max = tmp___4;
#line 1310
    runtime->hw.channels_min = tmp___4;
#line 1312
    goto ldv_30736;
    switch_break: /* CIL Label */ ;
    }
    ldv_30736: 
#line 1327
    runtime->hw.formats = 1024ULL;
  } else {
#line 1332
    tmp___5 = 0U;
#line 1332
    runtime->hw.channels_max = tmp___5;
#line 1332
    runtime->hw.channels_min = tmp___5;
#line 1333
    idx = 0;
#line 1333
    goto ldv_30739;
    ldv_30738: ;
#line 1334
    if ((emu->efx_voices_mask[idx / 32] & (unsigned int )(1 << idx % 32)) != 0U) {
#line 1335
      runtime->hw.channels_min = runtime->hw.channels_min + 1U;
#line 1336
      runtime->hw.channels_max = runtime->hw.channels_max + 1U;
    } else {

    }
#line 1333
    idx = idx + 1;
    ldv_30739: ;
#line 1333
    if (idx < nefx) {
#line 1335
      goto ldv_30738;
    } else {

    }

  }
  {
#line 1340
  epcm->capture_cr_val = emu->efx_voices_mask[0];
#line 1341
  epcm->capture_cr_val2 = emu->efx_voices_mask[1];
#line 1342
  ldv_spin_unlock_irq_42(& emu->reg_lock);
#line 1343
  emu->capture_efx_interrupt = & snd_emu10k1_pcm_efx_interrupt;
#line 1344
  emu->pcm_capture_efx_substream = substream;
#line 1345
  snd_pcm_hw_constraint_list(runtime, 0U, 14, & hw_constraints_capture_period_sizes);
  }
#line 1346
  return (0);
}
}
#line 1349 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_capture_efx_close(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1351
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1353
  emu->capture_interrupt = (void (*)(struct snd_emu10k1 * , unsigned int  ))0;
#line 1354
  emu->pcm_capture_efx_substream = (struct snd_pcm_substream *)0;
#line 1355
  return (0);
}
}
#line 1358 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_ops snd_emu10k1_playback_ops  = 
#line 1358
     {& snd_emu10k1_playback_open, & snd_emu10k1_playback_close, & snd_pcm_lib_ioctl,
    & snd_emu10k1_playback_hw_params, & snd_emu10k1_playback_hw_free, & snd_emu10k1_playback_prepare,
    & snd_emu10k1_playback_trigger, & snd_emu10k1_playback_pointer, 0, 0, & snd_pcm_sgbuf_ops_page,
    0, 0};
#line 1370 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_ops snd_emu10k1_capture_ops  = 
#line 1370
     {& snd_emu10k1_capture_open, & snd_emu10k1_capture_close, & snd_pcm_lib_ioctl,
    & snd_emu10k1_capture_hw_params, & snd_emu10k1_capture_hw_free, & snd_emu10k1_capture_prepare,
    & snd_emu10k1_capture_trigger, & snd_emu10k1_capture_pointer, 0, 0, 0, 0, 0};
#line 1382 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_ops snd_emu10k1_efx_playback_ops  = 
#line 1382
     {& snd_emu10k1_efx_playback_open, & snd_emu10k1_efx_playback_close, & snd_pcm_lib_ioctl,
    & snd_emu10k1_playback_hw_params, & snd_emu10k1_efx_playback_hw_free, & snd_emu10k1_efx_playback_prepare,
    & snd_emu10k1_efx_playback_trigger, & snd_emu10k1_efx_playback_pointer, 0, 0,
    & snd_pcm_sgbuf_ops_page, 0, 0};
#line 1394 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
int snd_emu10k1_pcm(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  struct snd_pcm_substream *substream ;
  int err ;

  {
#line 1400
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1401
    *rpcm = (struct snd_pcm *)0;
  } else {

  }
  {
#line 1403
  err = snd_pcm_new(emu->card, "emu10k1", device, 32, 1, & pcm);
  }
#line 1403
  if (err < 0) {
#line 1404
    return (err);
  } else {

  }
  {
#line 1406
  pcm->private_data = (void *)emu;
#line 1408
  snd_pcm_set_ops(pcm, 0, & snd_emu10k1_playback_ops);
#line 1409
  snd_pcm_set_ops(pcm, 1, & snd_emu10k1_capture_ops);
#line 1411
  pcm->info_flags = 0U;
#line 1412
  pcm->dev_subclass = 0U;
#line 1413
  strcpy((char *)(& pcm->name), "ADC Capture/Standard PCM Playback");
#line 1414
  emu->pcm = pcm;
#line 1416
  substream = pcm->streams[0].substream;
  }
#line 1416
  goto ldv_30757;
  ldv_30756: 
  {
#line 1417
  err = snd_pcm_lib_preallocate_pages(substream, 3, & (emu->pci)->dev, 65536UL, 65536UL);
  }
#line 1417
  if (err < 0) {
#line 1418
    return (err);
  } else {

  }
#line 1416
  substream = substream->next;
  ldv_30757: ;
#line 1416
  if ((unsigned long )substream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 1418
    goto ldv_30756;
  } else {

  }
#line 1420
  substream = pcm->streams[1].substream;
#line 1420
  goto ldv_30760;
  ldv_30759: 
  {
#line 1421
  snd_pcm_lib_preallocate_pages(substream, 2, & (emu->pci)->dev, 65536UL, 65536UL);
#line 1420
  substream = substream->next;
  }
  ldv_30760: ;
#line 1420
  if ((unsigned long )substream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 1422
    goto ldv_30759;
  } else {

  }

#line 1423
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1424
    *rpcm = pcm;
  } else {

  }
#line 1426
  return (0);
}
}
#line 1429 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
int snd_emu10k1_pcm_multi(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  struct snd_pcm_substream *substream ;
  int err ;

  {
#line 1435
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1436
    *rpcm = (struct snd_pcm *)0;
  } else {

  }
  {
#line 1438
  err = snd_pcm_new(emu->card, "emu10k1", device, 1, 0, & pcm);
  }
#line 1438
  if (err < 0) {
#line 1439
    return (err);
  } else {

  }
  {
#line 1441
  pcm->private_data = (void *)emu;
#line 1443
  snd_pcm_set_ops(pcm, 0, & snd_emu10k1_efx_playback_ops);
#line 1445
  pcm->info_flags = 0U;
#line 1446
  pcm->dev_subclass = 0U;
#line 1447
  strcpy((char *)(& pcm->name), "Multichannel Playback");
#line 1448
  emu->pcm_multi = pcm;
#line 1450
  substream = pcm->streams[0].substream;
  }
#line 1450
  goto ldv_30771;
  ldv_30770: 
  {
#line 1451
  err = snd_pcm_lib_preallocate_pages(substream, 3, & (emu->pci)->dev, 65536UL, 65536UL);
  }
#line 1451
  if (err < 0) {
#line 1452
    return (err);
  } else {

  }
#line 1450
  substream = substream->next;
  ldv_30771: ;
#line 1450
  if ((unsigned long )substream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 1452
    goto ldv_30770;
  } else {

  }

#line 1454
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1455
    *rpcm = pcm;
  } else {

  }
#line 1457
  return (0);
}
}
#line 1461 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_ops snd_emu10k1_capture_mic_ops  = 
#line 1461
     {& snd_emu10k1_capture_mic_open, & snd_emu10k1_capture_mic_close, & snd_pcm_lib_ioctl,
    & snd_emu10k1_capture_hw_params, & snd_emu10k1_capture_hw_free, & snd_emu10k1_capture_prepare,
    & snd_emu10k1_capture_trigger, & snd_emu10k1_capture_pointer, 0, 0, 0, 0, 0};
#line 1472 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
int snd_emu10k1_pcm_mic(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  int err ;

  {
#line 1477
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1478
    *rpcm = (struct snd_pcm *)0;
  } else {

  }
  {
#line 1480
  err = snd_pcm_new(emu->card, "emu10k1 mic", device, 0, 1, & pcm);
  }
#line 1480
  if (err < 0) {
#line 1481
    return (err);
  } else {

  }
  {
#line 1483
  pcm->private_data = (void *)emu;
#line 1485
  snd_pcm_set_ops(pcm, 1, & snd_emu10k1_capture_mic_ops);
#line 1487
  pcm->info_flags = 0U;
#line 1488
  strcpy((char *)(& pcm->name), "Mic Capture");
#line 1489
  emu->pcm_mic = pcm;
#line 1491
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (emu->pci)->dev), 65536UL,
                                        65536UL);
  }
#line 1493
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1494
    *rpcm = pcm;
  } else {

  }
#line 1495
  return (0);
}
}
#line 1498 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_pcm_efx_voices_mask_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1 *emu ;
  int nefx ;

  {
#line 1500
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1501
  nefx = emu->audigy != 0U ? 64 : 32;
#line 1502
  uinfo->type = 1;
#line 1503
  uinfo->count = (unsigned int )nefx;
#line 1504
  uinfo->value.integer.min = 0L;
#line 1505
  uinfo->value.integer.max = 1L;
#line 1506
  return (0);
}
}
#line 1509 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_pcm_efx_voices_mask_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  int nefx ;
  int idx ;

  {
  {
#line 1511
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1512
  nefx = emu->audigy != 0U ? 64 : 32;
#line 1515
  ldv_spin_lock_irq_41(& emu->reg_lock);
#line 1516
  idx = 0;
  }
#line 1516
  goto ldv_30795;
  ldv_30794: 
#line 1517
  ucontrol->value.integer.value[idx] = (emu->efx_voices_mask[idx / 32] & (unsigned int )(1 << idx % 32)) != 0U;
#line 1516
  idx = idx + 1;
  ldv_30795: ;
#line 1516
  if (idx < nefx) {
#line 1518
    goto ldv_30794;
  } else {

  }
  {
#line 1518
  ldv_spin_unlock_irq_42(& emu->reg_lock);
  }
#line 1519
  return (0);
}
}
#line 1522 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_pcm_efx_voices_mask_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int nval[2U] ;
  unsigned int bits ;
  int nefx ;
  int nefxb ;
  int change ;
  int idx ;

  {
#line 1524
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1526
  nefx = emu->audigy != 0U ? 64 : 32;
#line 1527
  nefxb = emu->audigy != 0U ? 7 : 6;
#line 1530
  nval[1] = 0U;
#line 1530
  nval[0] = nval[1];
#line 1531
  idx = 0;
#line 1531
  bits = 0U;
#line 1531
  goto ldv_30809;
  ldv_30808: ;
#line 1532
  if (ucontrol->value.integer.value[idx] != 0L) {
#line 1533
    nval[idx / 32] = nval[idx / 32] | (unsigned int )(1 << idx % 32);
#line 1534
    bits = bits + 1U;
  } else {

  }
#line 1531
  idx = idx + 1;
  ldv_30809: ;
#line 1531
  if (idx < nefx) {
#line 1533
    goto ldv_30808;
  } else {

  }
#line 1537
  idx = 0;
#line 1537
  goto ldv_30813;
  ldv_30812: ;
#line 1538
  if ((unsigned int )(1 << idx) == bits) {
#line 1539
    goto ldv_30811;
  } else {

  }
#line 1537
  idx = idx + 1;
  ldv_30813: ;
#line 1537
  if (idx < nefxb) {
#line 1539
    goto ldv_30812;
  } else {

  }
  ldv_30811: ;
#line 1541
  if (idx >= nefxb) {
#line 1542
    return (-22);
  } else {

  }
  {
#line 1544
  ldv_spin_lock_irq_41(& emu->reg_lock);
#line 1545
  change = nval[0] != emu->efx_voices_mask[0] || nval[1] != emu->efx_voices_mask[1];
#line 1547
  emu->efx_voices_mask[0] = nval[0];
#line 1548
  emu->efx_voices_mask[1] = nval[1];
#line 1549
  ldv_spin_unlock_irq_42(& emu->reg_lock);
  }
#line 1550
  return (change);
}
}
#line 1553 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_kcontrol_new snd_emu10k1_pcm_efx_voices_mask  = 
#line 1553
     {3, 0U, 0U, (unsigned char *)"Captured FX8010 Outputs", 0U, 0U, 0U, & snd_emu10k1_pcm_efx_voices_mask_info,
    & snd_emu10k1_pcm_efx_voices_mask_get, & snd_emu10k1_pcm_efx_voices_mask_put,
    {0}, 0UL};
#line 1561 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_ops snd_emu10k1_capture_efx_ops  = 
#line 1561
     {& snd_emu10k1_capture_efx_open, & snd_emu10k1_capture_efx_close, & snd_pcm_lib_ioctl,
    & snd_emu10k1_capture_hw_params, & snd_emu10k1_capture_hw_free, & snd_emu10k1_capture_prepare,
    & snd_emu10k1_capture_trigger, & snd_emu10k1_capture_pointer, 0, 0, 0, 0, 0};
#line 1578 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_fx8010_playback_irq(struct snd_emu10k1 *emu , void *private_data ) 
{ 
  struct snd_pcm_substream *substream ;

  {
  {
#line 1580
  substream = (struct snd_pcm_substream *)private_data;
#line 1581
  snd_pcm_period_elapsed(substream);
  }
#line 1582
  return;
}
}
#line 1584 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void snd_emu10k1_fx8010_playback_tram_poke1(unsigned short *dst_left , unsigned short *dst_right ,
                                                   unsigned short *src , unsigned int count ,
                                                   unsigned int tram_shift ) 
{ 
  unsigned short *tmp ;
  unsigned short *tmp___0 ;
  unsigned short *tmp___1 ;
  unsigned short *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned short *tmp___4 ;
  unsigned short *tmp___5 ;
  unsigned short *tmp___6 ;
  unsigned short *tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 1595
  if ((tram_shift & 1U) == 0U) {
#line 1596
    goto ldv_30829;
    ldv_30828: 
#line 1597
    tmp = dst_left;
#line 1597
    dst_left = dst_left - 1;
#line 1597
    tmp___0 = src;
#line 1597
    src = src + 1;
#line 1597
    *tmp = *tmp___0;
#line 1598
    tmp___1 = dst_right;
#line 1598
    dst_right = dst_right - 1;
#line 1598
    tmp___2 = src;
#line 1598
    src = src + 1;
#line 1598
    *tmp___1 = *tmp___2;
    ldv_30829: 
#line 1596
    tmp___3 = count;
#line 1596
    count = count - 1U;
#line 1596
    if (tmp___3 != 0U) {
#line 1598
      goto ldv_30828;
    } else {

    }

  } else {
#line 1601
    goto ldv_30832;
    ldv_30831: 
#line 1602
    tmp___4 = dst_right;
#line 1602
    dst_right = dst_right - 1;
#line 1602
    tmp___5 = src;
#line 1602
    src = src + 1;
#line 1602
    *tmp___4 = *tmp___5;
#line 1603
    tmp___6 = dst_left;
#line 1603
    dst_left = dst_left - 1;
#line 1603
    tmp___7 = src;
#line 1603
    src = src + 1;
#line 1603
    *tmp___6 = *tmp___7;
    ldv_30832: 
#line 1601
    tmp___8 = count;
#line 1601
    count = count - 1U;
#line 1601
    if (tmp___8 != 0U) {
#line 1603
      goto ldv_30831;
    } else {

    }

  }
#line 1609
  return;
}
}
#line 1608 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static void fx8010_pb_trans_copy(struct snd_pcm_substream *substream , struct snd_pcm_indirect *rec ,
                                 size_t bytes ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  unsigned int tram_size ;
  unsigned short *src ;
  unsigned int frames ;
  unsigned int count ;
  unsigned int tram_pos ;
  unsigned int tram_shift ;

  {
#line 1611
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1612
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1613
  tram_size = pcm->buffer_size;
#line 1614
  src = (unsigned short *)((substream->runtime)->dma_area + (unsigned long )rec->sw_data);
#line 1615
  frames = (unsigned int )(bytes >> 2);
#line 1616
  tram_pos = pcm->tram_pos;
#line 1617
  tram_shift = pcm->tram_shift;
#line 1619
  goto ldv_30848;
  ldv_30847: 
  {
#line 1620
  count = tram_pos + 1U;
#line 1621
  snd_emu10k1_fx8010_playback_tram_poke1((unsigned short *)emu->fx8010.etram_pages.area + (unsigned long )tram_pos,
                                         (unsigned short *)emu->fx8010.etram_pages.area + ((unsigned long )tram_pos + (unsigned long )(tram_size / 2U)),
                                         src, count, tram_shift);
#line 1624
  src = src + (unsigned long )(count * 2U);
#line 1625
  frames = frames - count;
#line 1626
  tram_pos = tram_size / 2U - 1U;
#line 1627
  tram_shift = tram_shift + 1U;
  }
  ldv_30848: ;
#line 1619
  if (frames > tram_pos) {
#line 1621
    goto ldv_30847;
  } else {

  }
  {
#line 1629
  snd_emu10k1_fx8010_playback_tram_poke1((unsigned short *)emu->fx8010.etram_pages.area + (unsigned long )tram_pos,
                                         (unsigned short *)emu->fx8010.etram_pages.area + ((unsigned long )tram_pos + (unsigned long )(tram_size / 2U)),
                                         src, frames, tram_shift);
#line 1632
  tram_pos = tram_pos - frames;
#line 1633
  pcm->tram_pos = tram_pos;
#line 1634
  pcm->tram_shift = tram_shift;
  }
#line 1635
  return;
}
}
#line 1637 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_transfer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_pcm *pcm ;

  {
  {
#line 1639
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1640
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1642
  snd_pcm_indirect_playback_transfer(substream, & pcm->pcm_rec, & fx8010_pb_trans_copy);
  }
#line 1643
  return (0);
}
}
#line 1646 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_hw_params(struct snd_pcm_substream *substream ,
                                                 struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_interval  const  *tmp ;
  int tmp___0 ;

  {
  {
#line 1649
  tmp = hw_param_interval_c((struct snd_pcm_hw_params  const  *)hw_params, 18);
#line 1649
  tmp___0 = snd_pcm_lib_malloc_pages(substream, (size_t )tmp->min);
  }
#line 1649
  return (tmp___0);
}
}
#line 1652 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  unsigned int i ;

  {
#line 1654
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1655
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1658
  i = 0U;
#line 1658
  goto ldv_30866;
  ldv_30865: 
  {
#line 1659
  snd_emu10k1_ptr_write(emu, (unsigned int )((int )pcm->etram[i] + 896), 0U, 0U);
#line 1658
  i = i + 1U;
  }
  ldv_30866: ;
#line 1658
  if (i < pcm->channels) {
#line 1660
    goto ldv_30865;
  } else {

  }
  {
#line 1660
  snd_pcm_lib_free_pages(substream);
  }
#line 1661
  return (0);
}
}
#line 1664 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  unsigned int i ;
  size_t tmp ;

  {
  {
#line 1666
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1667
  runtime = substream->runtime;
#line 1668
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1677
  memset((void *)(& pcm->pcm_rec), 0, 48UL);
#line 1678
  pcm->pcm_rec.hw_buffer_size = pcm->buffer_size * 2U;
#line 1679
  tmp = snd_pcm_lib_buffer_bytes(substream);
#line 1679
  pcm->pcm_rec.sw_buffer_size = (unsigned int )tmp;
#line 1680
  pcm->tram_pos = pcm->buffer_size / 2U - 15U;
#line 1681
  pcm->tram_shift = 0U;
#line 1682
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_running),
                        0U, 0U);
#line 1683
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_trigger),
                        0U, 0U);
#line 1684
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_size),
                        0U, (unsigned int )runtime->buffer_size);
#line 1685
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_ptr),
                        0U, 0U);
#line 1686
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_count),
                        0U, (unsigned int )runtime->period_size);
#line 1687
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_tmpcount),
                        0U, (unsigned int )runtime->period_size);
#line 1688
  i = 0U;
  }
#line 1688
  goto ldv_30876;
  ldv_30875: 
  {
#line 1689
  snd_emu10k1_ptr_write(emu, (unsigned int )((int )pcm->etram[i] + 896), 0U, i * (unsigned int )(runtime->buffer_size / (snd_pcm_uframes_t )pcm->channels) + 5242880U);
#line 1688
  i = i + 1U;
  }
  ldv_30876: ;
#line 1688
  if (i < pcm->channels) {
#line 1690
    goto ldv_30875;
  } else {

  }

#line 1690
  return (0);
}
}
#line 1693 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_trigger(struct snd_pcm_substream *substream ,
                                               int cmd ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  int result ;

  {
  {
#line 1695
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1696
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1697
  result = 0;
#line 1699
  ldv_spin_lock_35___0(& emu->reg_lock);
  }
  {
#line 1701
  if (cmd == 1) {
#line 1701
    goto case_1;
  } else {

  }
#line 1703
  if (cmd == 4) {
#line 1703
    goto case_4;
  } else {

  }
#line 1704
  if (cmd == 6) {
#line 1704
    goto case_6;
  } else {

  }
#line 1723
  if (cmd == 0) {
#line 1723
    goto case_0;
  } else {

  }
#line 1724
  if (cmd == 3) {
#line 1724
    goto case_3;
  } else {

  }
#line 1725
  if (cmd == 5) {
#line 1725
    goto case_5;
  } else {

  }
#line 1731
  goto switch_default;
  case_1: /* CIL Label */ ;
  case_4: /* CIL Label */ ;
  case_6: /* CIL Label */ 
  {
#line 1717
  result = snd_emu10k1_fx8010_register_irq_handler(emu, & snd_emu10k1_fx8010_playback_irq,
                                                   (int )((unsigned char )pcm->gpr_running),
                                                   (void *)substream, & pcm->irq);
  }
#line 1718
  if (result < 0) {
#line 1719
    goto __err;
  } else {

  }
  {
#line 1720
  snd_emu10k1_fx8010_playback_transfer(substream);
#line 1721
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_trigger),
                        0U, 1U);
  }
#line 1722
  goto ldv_30889;
  case_0: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_5: /* CIL Label */ 
  {
#line 1726
  snd_emu10k1_fx8010_unregister_irq_handler(emu, pcm->irq);
#line 1726
  pcm->irq = (struct snd_emu10k1_fx8010_irq *)0;
#line 1727
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_trigger),
                        0U, 0U);
#line 1728
  pcm->tram_pos = pcm->buffer_size / 2U - 15U;
#line 1729
  pcm->tram_shift = 0U;
  }
#line 1730
  goto ldv_30889;
  switch_default: /* CIL Label */ 
#line 1732
  result = -22;
#line 1733
  goto ldv_30889;
  switch_break: /* CIL Label */ ;
  }
  ldv_30889: ;
  __err: 
  {
#line 1736
  ldv_spin_unlock_36___0(& emu->reg_lock);
  }
#line 1737
  return (result);
}
}
#line 1740 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static snd_pcm_uframes_t snd_emu10k1_fx8010_playback_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  size_t ptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  snd_pcm_uframes_t tmp___1 ;

  {
  {
#line 1742
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1743
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1746
  tmp = snd_emu10k1_ptr_read(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_trigger),
                             0U);
  }
#line 1746
  if (tmp == 0U) {
#line 1747
    return (0UL);
  } else {

  }
  {
#line 1748
  tmp___0 = snd_emu10k1_ptr_read(emu, (unsigned int )(emu->gpr_base + (int )pcm->gpr_ptr),
                                 0U);
#line 1748
  ptr = (size_t )(tmp___0 << 2);
#line 1749
  tmp___1 = snd_pcm_indirect_playback_pointer(substream, & pcm->pcm_rec, (unsigned int )ptr);
  }
#line 1749
  return (tmp___1);
}
}
#line 1752 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_hardware snd_emu10k1_fx8010_playback  = 
#line 1752
     {786689U, 6ULL, 128U, 48000U, 48000U, 1U, 1U, 131072UL, 1024UL, 131072UL, 2U, 1024U,
    0UL};
#line 1771 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_open(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  unsigned int tmp ;

  {
  {
#line 1773
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1774
  runtime = substream->runtime;
#line 1775
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1777
  runtime->hw = snd_emu10k1_fx8010_playback;
#line 1778
  tmp = pcm->channels;
#line 1778
  runtime->hw.channels_max = tmp;
#line 1778
  runtime->hw.channels_min = tmp;
#line 1779
  runtime->hw.period_bytes_max = (size_t )((pcm->buffer_size * 2U) / 2U);
#line 1780
  ldv_spin_lock_irq_41(& emu->reg_lock);
  }
#line 1781
  if ((unsigned int )*((unsigned char *)pcm + 0UL) == 0U) {
    {
#line 1782
    ldv_spin_unlock_irq_42(& emu->reg_lock);
    }
#line 1783
    return (-19);
  } else {

  }
  {
#line 1785
  pcm->opened = 1U;
#line 1786
  ldv_spin_unlock_irq_42(& emu->reg_lock);
  }
#line 1787
  return (0);
}
}
#line 1790 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static int snd_emu10k1_fx8010_playback_close(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_pcm *pcm ;

  {
  {
#line 1792
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 1793
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )substream->number;
#line 1795
  ldv_spin_lock_irq_41(& emu->reg_lock);
#line 1796
  pcm->opened = 0U;
#line 1797
  ldv_spin_unlock_irq_42(& emu->reg_lock);
  }
#line 1798
  return (0);
}
}
#line 1801 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
static struct snd_pcm_ops snd_emu10k1_fx8010_playback_ops  = 
#line 1801
     {& snd_emu10k1_fx8010_playback_open, & snd_emu10k1_fx8010_playback_close, & snd_pcm_lib_ioctl,
    & snd_emu10k1_fx8010_playback_hw_params, & snd_emu10k1_fx8010_playback_hw_free,
    & snd_emu10k1_fx8010_playback_prepare, & snd_emu10k1_fx8010_playback_trigger,
    & snd_emu10k1_fx8010_playback_pointer, 0, 0, 0, 0, & snd_emu10k1_fx8010_playback_transfer};
#line 1813 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emupcm.c"
int snd_emu10k1_pcm_efx(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  struct snd_kcontrol *kctl ;
  int err ;

  {
#line 1819
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1820
    *rpcm = (struct snd_pcm *)0;
  } else {

  }
  {
#line 1822
  err = snd_pcm_new(emu->card, "emu10k1 efx", device, 8, 1, & pcm);
  }
#line 1822
  if (err < 0) {
#line 1823
    return (err);
  } else {

  }
  {
#line 1825
  pcm->private_data = (void *)emu;
#line 1827
  snd_pcm_set_ops(pcm, 0, & snd_emu10k1_fx8010_playback_ops);
#line 1828
  snd_pcm_set_ops(pcm, 1, & snd_emu10k1_capture_efx_ops);
#line 1830
  pcm->info_flags = 0U;
#line 1831
  strcpy((char *)(& pcm->name), "Multichannel Capture/PT Playback");
#line 1832
  emu->pcm_efx = pcm;
  }
#line 1833
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 1834
    *rpcm = pcm;
  } else {

  }
#line 1841
  if (emu->audigy != 0U) {
#line 1842
    emu->efx_voices_mask[0] = 0U;
#line 1843
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
#line 1848
      emu->efx_voices_mask[1] = 4294967295U;
    } else {
#line 1850
      emu->efx_voices_mask[1] = 65535U;
    }
  } else {
#line 1852
    emu->efx_voices_mask[0] = 4294901760U;
#line 1853
    emu->efx_voices_mask[1] = 0U;
  }
  {
#line 1861
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_pcm_efx_voices_mask),
                      (void *)emu);
  }
#line 1862
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1863
    return (-12);
  } else {

  }
  {
#line 1864
  kctl->id.device = (unsigned int )device;
#line 1865
  snd_ctl_add(emu->card, kctl);
#line 1867
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (emu->pci)->dev), 65536UL,
                                        65536UL);
  }
#line 1869
  return (0);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
static void ldv___ldv_spin_lock_33___3(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 488 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 491
  ldv_spin_unlock_reg_lock_of_snd_emu10k1();
#line 493
  spin_unlock_irqrestore(lock, flags);
  }
#line 494
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
__inline static void ldv_spin_lock_35___0(spinlock_t *lock ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 502
  spin_lock(lock);
  }
#line 503
  return;
}
}
#line 506 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
__inline static void ldv_spin_unlock_36___0(spinlock_t *lock ) 
{ 


  {
  {
#line 509
  ldv_spin_unlock_reg_lock_of_snd_emu10k1();
#line 511
  spin_unlock(lock);
  }
#line 512
  return;
}
}
#line 551 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) 
{ 


  {
  {
#line 554
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 556
  spin_lock_irq(lock);
  }
#line 557
  return;
}
}
#line 560 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emupcm.c.aux"
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) 
{ 


  {
  {
#line 563
  ldv_spin_unlock_reg_lock_of_snd_emu10k1();
#line 565
  spin_unlock_irq(lock);
  }
#line 566
  return;
}
}
#line 149 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/printk.h"
extern void dump_stack(void) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_33___4(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___1(spinlock_t *ldv_func_arg1 ) ;
#line 33
static void ldv___ldv_spin_lock_37___0(spinlock_t *ldv_func_arg1 ) ;
#line 37
static void ldv___ldv_spin_lock_39___0(spinlock_t *ldv_func_arg1 ) ;
#line 41
static void ldv___ldv_spin_lock_41(spinlock_t *ldv_func_arg1 ) ;
#line 45
static void ldv___ldv_spin_lock_43(spinlock_t *ldv_func_arg1 ) ;
#line 49
static void ldv___ldv_spin_lock_49(spinlock_t *ldv_func_arg1 ) ;
#line 53
static void ldv___ldv_spin_lock_51___0(spinlock_t *ldv_func_arg1 ) ;
#line 57
static void ldv___ldv_spin_lock_53(spinlock_t *ldv_func_arg1 ) ;
#line 61
static void ldv___ldv_spin_lock_55(spinlock_t *ldv_func_arg1 ) ;
#line 65
static void ldv___ldv_spin_lock_57(spinlock_t *ldv_func_arg1 ) ;
#line 69
static void ldv___ldv_spin_lock_59(spinlock_t *ldv_func_arg1 ) ;
#line 73
static void ldv___ldv_spin_lock_61(spinlock_t *ldv_func_arg1 ) ;
#line 77
static void ldv___ldv_spin_lock_63(spinlock_t *ldv_func_arg1 ) ;
#line 81
static void ldv___ldv_spin_lock_65(spinlock_t *ldv_func_arg1 ) ;
#line 85
static void ldv___ldv_spin_lock_67(spinlock_t *ldv_func_arg1 ) ;
#line 89
static void ldv___ldv_spin_lock_69(spinlock_t *ldv_func_arg1 ) ;
#line 93
static void ldv___ldv_spin_lock_71(spinlock_t *ldv_func_arg1 ) ;
#line 97
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1 ) ;
#line 101
static void ldv___ldv_spin_lock_75(spinlock_t *ldv_func_arg1 ) ;
#line 133
void ldv_spin_lock_i2c_lock_of_snd_emu10k1(void) ;
#line 134
void ldv_spin_unlock_i2c_lock_of_snd_emu10k1(void) ;
#line 229
void ldv_spin_lock_spi_lock_of_snd_emu10k1(void) ;
#line 230
void ldv_spin_unlock_spi_lock_of_snd_emu10k1(void) ;
#line 323 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_45(spinlock_t *lock ) ;
#line 327
__inline static void ldv_spin_lock_47___0(spinlock_t *lock ) ;
#line 363
__inline static void ldv_spin_unlock_46(spinlock_t *lock ) ;
#line 367
__inline static void ldv_spin_unlock_48___0(spinlock_t *lock ) ;
#line 398
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 402
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 406
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 410
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 414
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 418
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 422
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 426
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 430
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 434
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 438
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 442
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 446
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 450
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 454
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 458
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 462
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 466
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 470
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 474
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 309 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/io.h"
__inline static void outw(unsigned short value , int port ) 
{ 


  {
#line 309
  __asm__  volatile   ("outw %w0, %w1": : "a" (value), "Nd" (port));
#line 310
  return;
}
}
#line 309 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned short inw(int port ) 
{ 
  unsigned short value ;

  {
#line 309
  __asm__  volatile   ("inw %w1, %w0": "=a" (value): "Nd" (port));
#line 309
  return (value);
}
}
#line 1835 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
unsigned int snd_emu10k1_ptr20_read(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ) ;
#line 1848
void snd_emu10k1_voice_half_loop_intr_enable(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1851
void snd_emu10k1_voice_set_loop_stop(struct snd_emu10k1 *emu , unsigned int voicenum ) ;
#line 1855
unsigned short snd_emu10k1_ac97_read(struct snd_ac97 *ac97 , unsigned short reg ) ;
#line 1856
void snd_emu10k1_ac97_write(struct snd_ac97 *ac97 , unsigned short reg , unsigned short data ) ;
#line 35 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
unsigned int snd_emu10k1_ptr_read(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ) 
{ 
  unsigned long flags ;
  unsigned int regptr ;
  unsigned int val ;
  unsigned int mask ;
  unsigned char size ;
  unsigned char offset ;

  {
#line 41
  mask = emu->audigy != 0U ? 268369920U : 134152192U;
#line 42
  regptr = ((reg << 16) & mask) | (chn & 63U);
#line 44
  if ((reg & 4278190080U) != 0U) {
    {
#line 47
    size = (unsigned int )((unsigned char )(reg >> 24)) & 63U;
#line 48
    offset = (unsigned int )((unsigned char )(reg >> 16)) & 31U;
#line 49
    mask = (unsigned int )(((1 << (int )size) + -1) << (int )offset);
#line 51
    ldv___ldv_spin_lock_33___4(& emu->emu_lock);
#line 52
    outl(regptr, (int )emu->port);
#line 53
    val = inl((int )((unsigned int )emu->port + 4U));
#line 54
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
#line 56
    return ((val & mask) >> (int )offset);
  } else {
    {
#line 58
    ldv___ldv_spin_lock_35___1(& emu->emu_lock);
#line 59
    outl(regptr, (int )emu->port);
#line 60
    val = inl((int )((unsigned int )emu->port + 4U));
#line 61
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
#line 62
    return (val);
  }
}
}
#line 68 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_ptr_write(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ,
                           unsigned int data ) 
{ 
  unsigned int regptr ;
  unsigned long flags ;
  unsigned int mask ;
  unsigned char size ;
  unsigned char offset ;
  unsigned int tmp ;

  {
#line 74
  if ((unsigned long )emu == (unsigned long )((struct snd_emu10k1 *)0)) {
    {
#line 75
    __snd_printk(0U, "sound/pci/emu10k1/io.c", 75, "<3>ptr_write: emu is null!\n");
#line 76
    dump_stack();
    }
#line 77
    return;
  } else {

  }
#line 79
  mask = emu->audigy != 0U ? 268369920U : 134152192U;
#line 80
  regptr = ((reg << 16) & mask) | (chn & 63U);
#line 82
  if ((reg & 4278190080U) != 0U) {
    {
#line 85
    size = (unsigned int )((unsigned char )(reg >> 24)) & 63U;
#line 86
    offset = (unsigned int )((unsigned char )(reg >> 16)) & 31U;
#line 87
    mask = (unsigned int )(((1 << (int )size) + -1) << (int )offset);
#line 88
    data = (data << (int )offset) & mask;
#line 90
    ldv___ldv_spin_lock_37___0(& emu->emu_lock);
#line 91
    outl(regptr, (int )emu->port);
#line 92
    tmp = inl((int )((unsigned int )emu->port + 4U));
#line 92
    data = data | (tmp & ~ mask);
#line 93
    outl(data, (int )((unsigned int )emu->port + 4U));
#line 94
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
  } else {
    {
#line 96
    ldv___ldv_spin_lock_39___0(& emu->emu_lock);
#line 97
    outl(regptr, (int )emu->port);
#line 98
    outl(data, (int )((unsigned int )emu->port + 4U));
#line 99
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
  }
#line 101
  return;
}
}
#line 105 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
unsigned int snd_emu10k1_ptr20_read(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ) 
{ 
  unsigned long flags ;
  unsigned int regptr ;
  unsigned int val ;

  {
  {
#line 112
  regptr = (reg << 16) | chn;
#line 114
  ldv___ldv_spin_lock_41(& emu->emu_lock);
#line 115
  outl(regptr, (int )((unsigned int )emu->port + 32U));
#line 116
  val = inl((int )((unsigned int )emu->port + 36U));
#line 117
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 118
  return (val);
}
}
#line 121 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_ptr20_write(struct snd_emu10k1 *emu , unsigned int reg , unsigned int chn ,
                             unsigned int data ) 
{ 
  unsigned int regptr ;
  unsigned long flags ;

  {
  {
#line 129
  regptr = (reg << 16) | chn;
#line 131
  ldv___ldv_spin_lock_43(& emu->emu_lock);
#line 132
  outl(regptr, (int )((unsigned int )emu->port + 32U));
#line 133
  outl(data, (int )((unsigned int )emu->port + 36U));
#line 134
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 135
  return;
}
}
#line 137 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
int snd_emu10k1_spi_write(struct snd_emu10k1 *emu , unsigned int data ) 
{ 
  unsigned int reset ;
  unsigned int set ;
  unsigned int reg ;
  unsigned int tmp ;
  int n ;
  int result ;
  int err ;

  {
  {
#line 143
  err = 0;
#line 146
  ldv_spin_lock_45(& emu->spi_lock);
  }
#line 147
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0108_chip) != 0U) {
#line 148
    reg = 60U;
  } else {
#line 152
    err = 1;
#line 153
    goto spi_write_exit;
  }
#line 155
  if (data > 65535U) {
#line 157
    err = 1;
#line 158
    goto spi_write_exit;
  } else {

  }
  {
#line 161
  tmp = snd_emu10k1_ptr20_read(emu, reg, 0U);
#line 162
  reset = (tmp & 4294705152U) | 131072U;
#line 163
  set = reset | 65536U;
#line 164
  snd_emu10k1_ptr20_write(emu, reg, 0U, reset | data);
#line 165
  tmp = snd_emu10k1_ptr20_read(emu, reg, 0U);
#line 166
  snd_emu10k1_ptr20_write(emu, reg, 0U, set | data);
#line 167
  result = 1;
#line 169
  n = 0;
  }
#line 169
  goto ldv_30558;
  ldv_30557: 
  {
#line 170
  __const_udelay(42950UL);
#line 171
  tmp = snd_emu10k1_ptr20_read(emu, reg, 0U);
  }
#line 172
  if ((tmp & 65536U) == 0U) {
#line 173
    result = 0;
#line 174
    goto ldv_30556;
  } else {

  }
#line 169
  n = n + 1;
  ldv_30558: ;
#line 169
  if (n <= 99) {
#line 171
    goto ldv_30557;
  } else {

  }
  ldv_30556: ;
#line 177
  if (result != 0) {
#line 179
    err = 1;
#line 180
    goto spi_write_exit;
  } else {

  }
  {
#line 182
  snd_emu10k1_ptr20_write(emu, reg, 0U, reset | data);
#line 183
  tmp = snd_emu10k1_ptr20_read(emu, reg, 0U);
#line 184
  err = 0;
  }
  spi_write_exit: 
  {
#line 186
  ldv_spin_unlock_46(& emu->spi_lock);
  }
#line 187
  return (err);
}
}
#line 191 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
int snd_emu10k1_i2c_write(struct snd_emu10k1 *emu , u32 reg , u32 value ) 
{ 
  u32 tmp ;
  int timeout ;
  int status ;
  int retry ;
  int err ;
  unsigned long __ms ;
  unsigned long tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 196
  timeout = 0;
#line 199
  err = 0;
#line 201
  if (reg > 127U || value > 511U) {
    {
#line 202
    __snd_printk(0U, "sound/pci/emu10k1/io.c", 202, "<3>i2c_write: invalid values.\n");
    }
#line 203
    return (-22);
  } else {

  }
  {
#line 207
  ldv_spin_lock_47___0(& emu->i2c_lock);
#line 209
  tmp = (reg << 25) | (value << 16);
#line 212
  snd_emu10k1_ptr20_write(emu, 63U, 0U, tmp);
#line 213
  tmp = snd_emu10k1_ptr20_read(emu, 63U, 0U);
#line 215
  retry = 0;
  }
#line 215
  goto ldv_30577;
  ldv_30576: 
  {
#line 217
  tmp = 0U;
#line 218
  tmp = tmp | 1332U;
#line 219
  snd_emu10k1_ptr20_write(emu, 61U, 0U, tmp);
  }
  ldv_30574: ;
#line 223
  if (1) {
    {
#line 223
    __const_udelay(4295000UL);
    }
  } else {
#line 223
    __ms = 1UL;
#line 223
    goto ldv_30571;
    ldv_30570: 
    {
#line 223
    __const_udelay(4295000UL);
    }
    ldv_30571: 
#line 223
    tmp___0 = __ms;
#line 223
    __ms = __ms - 1UL;
#line 223
    if (tmp___0 != 0UL) {
#line 225
      goto ldv_30570;
    } else {

    }

  }
  {
#line 224
  tmp___1 = snd_emu10k1_ptr20_read(emu, 61U, 0U);
#line 224
  status = (int )tmp___1;
#line 225
  timeout = timeout + 1;
  }
#line 226
  if ((status & 256) == 0) {
#line 227
    goto ldv_30573;
  } else {

  }
#line 229
  if (timeout > 1000) {
    {
#line 230
    __snd_printk(0U, "sound/pci/emu10k1/io.c", 232, "<4>emu10k1:I2C:timeout status=0x%x\n",
                 status);
    }
#line 233
    goto ldv_30573;
  } else {

  }
#line 235
  goto ldv_30574;
  ldv_30573: ;
#line 237
  if ((status & 512) == 0) {
#line 238
    goto ldv_30575;
  } else {

  }
#line 215
  retry = retry + 1;
  ldv_30577: ;
#line 215
  if (retry <= 9) {
#line 217
    goto ldv_30576;
  } else {

  }
  ldv_30575: ;
#line 241
  if (retry == 10) {
    {
#line 242
    __snd_printk(0U, "sound/pci/emu10k1/io.c", 242, "<3>Writing to ADC failed!\n");
#line 243
    __snd_printk(0U, "sound/pci/emu10k1/io.c", 244, "<3>status=0x%x, reg=%d, value=%d\n",
                 status, reg, value);
#line 246
    err = -22;
    }
  } else {

  }
  {
#line 249
  ldv_spin_unlock_48___0(& emu->i2c_lock);
  }
#line 250
  return (err);
}
}
#line 253 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
int snd_emu1010_fpga_write(struct snd_emu10k1 *emu , u32 reg , u32 value ) 
{ 
  unsigned long flags ;

  {
#line 257
  if (reg > 63U) {
#line 258
    return (1);
  } else {

  }
#line 259
  reg = reg + 64U;
#line 260
  if (value > 63U) {
#line 261
    return (1);
  } else {

  }
  {
#line 262
  ldv___ldv_spin_lock_49(& emu->emu_lock);
#line 263
  outl(reg, (int )((unsigned int )emu->port + 24U));
#line 264
  __const_udelay(42950UL);
#line 265
  outl(reg | 128U, (int )((unsigned int )emu->port + 24U));
#line 266
  __const_udelay(42950UL);
#line 267
  outl(value, (int )((unsigned int )emu->port + 24U));
#line 268
  __const_udelay(42950UL);
#line 269
  outl(value | 128U, (int )((unsigned int )emu->port + 24U));
#line 270
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 272
  return (0);
}
}
#line 275 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
int snd_emu1010_fpga_read(struct snd_emu10k1 *emu , u32 reg , u32 *value ) 
{ 
  unsigned long flags ;
  unsigned int tmp ;

  {
#line 278
  if (reg > 63U) {
#line 279
    return (1);
  } else {

  }
  {
#line 280
  reg = reg + 64U;
#line 281
  ldv___ldv_spin_lock_51___0(& emu->emu_lock);
#line 282
  outl(reg, (int )((unsigned int )emu->port + 24U));
#line 283
  __const_udelay(42950UL);
#line 284
  outl(reg | 128U, (int )((unsigned int )emu->port + 24U));
#line 285
  __const_udelay(42950UL);
#line 286
  tmp = inl((int )((unsigned int )emu->port + 24U));
#line 286
  *value = (tmp >> 8) & 127U;
#line 287
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 289
  return (0);
}
}
#line 295 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
int snd_emu1010_fpga_link_dst_src_write(struct snd_emu10k1 *emu , u32 dst , u32 src ) 
{ 


  {
  {
#line 297
  snd_emu1010_fpga_write(emu, 0U, (dst >> 8) & 63U);
#line 298
  snd_emu1010_fpga_write(emu, 1U, dst & 63U);
#line 299
  snd_emu1010_fpga_write(emu, 2U, (src >> 8) & 63U);
#line 300
  snd_emu1010_fpga_write(emu, 3U, src & 63U);
  }
#line 302
  return (0);
}
}
#line 305 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_intr_enable(struct snd_emu10k1 *emu , unsigned int intrenb ) 
{ 
  unsigned long flags ;
  unsigned int enable___0 ;
  unsigned int tmp ;

  {
  {
#line 310
  ldv___ldv_spin_lock_53(& emu->emu_lock);
#line 311
  tmp = inl((int )((unsigned int )emu->port + 12U));
#line 311
  enable___0 = tmp | intrenb;
#line 312
  outl(enable___0, (int )((unsigned int )emu->port + 12U));
#line 313
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 314
  return;
}
}
#line 316 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_intr_disable(struct snd_emu10k1 *emu , unsigned int intrenb ) 
{ 
  unsigned long flags ;
  unsigned int enable___0 ;
  unsigned int tmp ;

  {
  {
#line 321
  ldv___ldv_spin_lock_55(& emu->emu_lock);
#line 322
  tmp = inl((int )((unsigned int )emu->port + 12U));
#line 322
  enable___0 = tmp & ~ intrenb;
#line 323
  outl(enable___0, (int )((unsigned int )emu->port + 12U));
#line 324
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 325
  return;
}
}
#line 327 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_intr_enable(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;
  unsigned int val ;

  {
  {
#line 332
  ldv___ldv_spin_lock_57(& emu->emu_lock);
  }
#line 334
  if (voicenum > 31U) {
    {
#line 335
    outl(5832704U, (int )emu->port);
#line 336
    val = inl((int )((unsigned int )emu->port + 4U));
#line 337
    val = val | (unsigned int )(1 << (int )(voicenum - 32U));
    }
  } else {
    {
#line 339
    outl(5767168U, (int )emu->port);
#line 340
    val = inl((int )((unsigned int )emu->port + 4U));
#line 341
    val = val | (unsigned int )(1 << (int )voicenum);
    }
  }
  {
#line 343
  outl(val, (int )((unsigned int )emu->port + 4U));
#line 344
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 345
  return;
}
}
#line 347 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_intr_disable(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;
  unsigned int val ;

  {
  {
#line 352
  ldv___ldv_spin_lock_59(& emu->emu_lock);
  }
#line 354
  if (voicenum > 31U) {
    {
#line 355
    outl(5832704U, (int )emu->port);
#line 356
    val = inl((int )((unsigned int )emu->port + 4U));
#line 357
    val = val & (unsigned int )(~ (1 << (int )(voicenum - 32U)));
    }
  } else {
    {
#line 359
    outl(5767168U, (int )emu->port);
#line 360
    val = inl((int )((unsigned int )emu->port + 4U));
#line 361
    val = val & (unsigned int )(~ (1 << (int )voicenum));
    }
  }
  {
#line 363
  outl(val, (int )((unsigned int )emu->port + 4U));
#line 364
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 365
  return;
}
}
#line 367 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_intr_ack(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;

  {
  {
#line 371
  ldv___ldv_spin_lock_61(& emu->emu_lock);
  }
#line 373
  if (voicenum > 31U) {
    {
#line 374
    outl(5963776U, (int )emu->port);
#line 375
    voicenum = (unsigned int )(1 << (int )(voicenum - 32U));
    }
  } else {
    {
#line 377
    outl(5898240U, (int )emu->port);
#line 378
    voicenum = (unsigned int )(1 << (int )voicenum);
    }
  }
  {
#line 380
  outl(voicenum, (int )((unsigned int )emu->port + 4U));
#line 381
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 382
  return;
}
}
#line 384 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_half_loop_intr_enable(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;
  unsigned int val ;

  {
  {
#line 389
  ldv___ldv_spin_lock_63(& emu->emu_lock);
  }
#line 391
  if (voicenum > 31U) {
    {
#line 392
    outl(6750208U, (int )emu->port);
#line 393
    val = inl((int )((unsigned int )emu->port + 4U));
#line 394
    val = val | (unsigned int )(1 << (int )(voicenum - 32U));
    }
  } else {
    {
#line 396
    outl(6684672U, (int )emu->port);
#line 397
    val = inl((int )((unsigned int )emu->port + 4U));
#line 398
    val = val | (unsigned int )(1 << (int )voicenum);
    }
  }
  {
#line 400
  outl(val, (int )((unsigned int )emu->port + 4U));
#line 401
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 402
  return;
}
}
#line 404 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_half_loop_intr_disable(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;
  unsigned int val ;

  {
  {
#line 409
  ldv___ldv_spin_lock_65(& emu->emu_lock);
  }
#line 411
  if (voicenum > 31U) {
    {
#line 412
    outl(6750208U, (int )emu->port);
#line 413
    val = inl((int )((unsigned int )emu->port + 4U));
#line 414
    val = val & (unsigned int )(~ (1 << (int )(voicenum - 32U)));
    }
  } else {
    {
#line 416
    outl(6684672U, (int )emu->port);
#line 417
    val = inl((int )((unsigned int )emu->port + 4U));
#line 418
    val = val & (unsigned int )(~ (1 << (int )voicenum));
    }
  }
  {
#line 420
  outl(val, (int )((unsigned int )emu->port + 4U));
#line 421
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 422
  return;
}
}
#line 424 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_half_loop_intr_ack(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;

  {
  {
#line 428
  ldv___ldv_spin_lock_67(& emu->emu_lock);
  }
#line 430
  if (voicenum > 31U) {
    {
#line 431
    outl(6881280U, (int )emu->port);
#line 432
    voicenum = (unsigned int )(1 << (int )(voicenum - 32U));
    }
  } else {
    {
#line 434
    outl(6815744U, (int )emu->port);
#line 435
    voicenum = (unsigned int )(1 << (int )voicenum);
    }
  }
  {
#line 437
  outl(voicenum, (int )((unsigned int )emu->port + 4U));
#line 438
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 439
  return;
}
}
#line 441 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_set_loop_stop(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;
  unsigned int sol ;

  {
  {
#line 446
  ldv___ldv_spin_lock_69(& emu->emu_lock);
  }
#line 448
  if (voicenum > 31U) {
    {
#line 449
    outl(6094848U, (int )emu->port);
#line 450
    sol = inl((int )((unsigned int )emu->port + 4U));
#line 451
    sol = sol | (unsigned int )(1 << (int )(voicenum - 32U));
    }
  } else {
    {
#line 453
    outl(6029312U, (int )emu->port);
#line 454
    sol = inl((int )((unsigned int )emu->port + 4U));
#line 455
    sol = sol | (unsigned int )(1 << (int )voicenum);
    }
  }
  {
#line 457
  outl(sol, (int )((unsigned int )emu->port + 4U));
#line 458
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 459
  return;
}
}
#line 461 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_voice_clear_loop_stop(struct snd_emu10k1 *emu , unsigned int voicenum ) 
{ 
  unsigned long flags ;
  unsigned int sol ;

  {
  {
#line 466
  ldv___ldv_spin_lock_71(& emu->emu_lock);
  }
#line 468
  if (voicenum > 31U) {
    {
#line 469
    outl(6094848U, (int )emu->port);
#line 470
    sol = inl((int )((unsigned int )emu->port + 4U));
#line 471
    sol = sol & (unsigned int )(~ (1 << (int )(voicenum - 32U)));
    }
  } else {
    {
#line 473
    outl(6029312U, (int )emu->port);
#line 474
    sol = inl((int )((unsigned int )emu->port + 4U));
#line 475
    sol = sol & (unsigned int )(~ (1 << (int )voicenum));
    }
  }
  {
#line 477
  outl(sol, (int )((unsigned int )emu->port + 4U));
#line 478
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 479
  return;
}
}
#line 481 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_wait(struct snd_emu10k1 *emu , unsigned int wait ) 
{ 
  unsigned int volatile   count ;
  unsigned int newtime ;
  unsigned int curtime ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int volatile   tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 484
  newtime = 0U;
#line 486
  tmp = inl((int )((unsigned int )emu->port + 16U));
#line 486
  curtime = tmp >> 6;
  }
#line 487
  goto ldv_30665;
  ldv_30664: 
#line 488
  count = 0U;
#line 489
  goto ldv_30662;
  ldv_30661: 
  {
#line 490
  tmp___0 = inl((int )((unsigned int )emu->port + 16U));
#line 490
  newtime = tmp___0 >> 6;
  }
#line 491
  if (newtime != curtime) {
#line 492
    goto ldv_30660;
  } else {

  }
  ldv_30662: 
#line 489
  tmp___1 = count;
#line 489
  count = count + (unsigned int volatile   )1;
#line 489
  if ((unsigned int )tmp___1 <= 16383U) {
#line 491
    goto ldv_30661;
  } else {

  }
  ldv_30660: ;
#line 494
  if ((unsigned int )count > 16384U) {
#line 495
    goto ldv_30663;
  } else {

  }
#line 496
  curtime = newtime;
  ldv_30665: 
#line 487
  tmp___2 = wait;
#line 487
  wait = wait - 1U;
#line 487
  if (tmp___2 != 0U) {
#line 489
    goto ldv_30664;
  } else {

  }
  ldv_30663: ;
#line 494
  return;
}
}
#line 500 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
unsigned short snd_emu10k1_ac97_read(struct snd_ac97 *ac97 , unsigned short reg ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long flags ;
  unsigned short val ;

  {
  {
#line 502
  emu = (struct snd_emu10k1 *)ac97->private_data;
#line 506
  ldv___ldv_spin_lock_73(& emu->emu_lock);
#line 507
  outb((int )((unsigned char )reg), (int )((unsigned int )emu->port + 30U));
#line 508
  val = inw((int )((unsigned int )emu->port + 28U));
#line 509
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 510
  return (val);
}
}
#line 513 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
void snd_emu10k1_ac97_write(struct snd_ac97 *ac97 , unsigned short reg , unsigned short data ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long flags ;

  {
  {
#line 515
  emu = (struct snd_emu10k1 *)ac97->private_data;
#line 518
  ldv___ldv_spin_lock_75(& emu->emu_lock);
#line 519
  outb((int )((unsigned char )reg), (int )((unsigned int )emu->port + 30U));
#line 520
  outw((int )data, (int )((unsigned int )emu->port + 28U));
#line 521
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 522
  return;
}
}
#line 528 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/io.c"
unsigned int snd_emu10k1_rate_to_pitch(unsigned int rate ) 
{ 
  u32 logMagTable[128U] ;
  char logSlopeTable[128U] ;
  int i ;

  {
#line 530
  logMagTable[0] = 0U;
#line 530
  logMagTable[1] = 11772U;
#line 530
  logMagTable[2] = 23454U;
#line 530
  logMagTable[3] = 35046U;
#line 530
  logMagTable[4] = 46550U;
#line 530
  logMagTable[5] = 57967U;
#line 530
  logMagTable[6] = 69299U;
#line 530
  logMagTable[7] = 80546U;
#line 530
  logMagTable[8] = 91711U;
#line 530
  logMagTable[9] = 102794U;
#line 530
  logMagTable[10] = 113796U;
#line 530
  logMagTable[11] = 124718U;
#line 530
  logMagTable[12] = 135563U;
#line 530
  logMagTable[13] = 146330U;
#line 530
  logMagTable[14] = 157021U;
#line 530
  logMagTable[15] = 167637U;
#line 530
  logMagTable[16] = 178179U;
#line 530
  logMagTable[17] = 188648U;
#line 530
  logMagTable[18] = 199045U;
#line 530
  logMagTable[19] = 209371U;
#line 530
  logMagTable[20] = 219627U;
#line 530
  logMagTable[21] = 229814U;
#line 530
  logMagTable[22] = 239933U;
#line 530
  logMagTable[23] = 249985U;
#line 530
  logMagTable[24] = 259970U;
#line 530
  logMagTable[25] = 269890U;
#line 530
  logMagTable[26] = 279745U;
#line 530
  logMagTable[27] = 289537U;
#line 530
  logMagTable[28] = 299265U;
#line 530
  logMagTable[29] = 308932U;
#line 530
  logMagTable[30] = 318537U;
#line 530
  logMagTable[31] = 328081U;
#line 530
  logMagTable[32] = 337566U;
#line 530
  logMagTable[33] = 346991U;
#line 530
  logMagTable[34] = 356358U;
#line 530
  logMagTable[35] = 365667U;
#line 530
  logMagTable[36] = 374920U;
#line 530
  logMagTable[37] = 384116U;
#line 530
  logMagTable[38] = 393257U;
#line 530
  logMagTable[39] = 402343U;
#line 530
  logMagTable[40] = 411374U;
#line 530
  logMagTable[41] = 420352U;
#line 530
  logMagTable[42] = 429277U;
#line 530
  logMagTable[43] = 438150U;
#line 530
  logMagTable[44] = 446970U;
#line 530
  logMagTable[45] = 455740U;
#line 530
  logMagTable[46] = 464459U;
#line 530
  logMagTable[47] = 473129U;
#line 530
  logMagTable[48] = 481748U;
#line 530
  logMagTable[49] = 490319U;
#line 530
  logMagTable[50] = 498842U;
#line 530
  logMagTable[51] = 507317U;
#line 530
  logMagTable[52] = 515745U;
#line 530
  logMagTable[53] = 524126U;
#line 530
  logMagTable[54] = 532461U;
#line 530
  logMagTable[55] = 540750U;
#line 530
  logMagTable[56] = 548994U;
#line 530
  logMagTable[57] = 557193U;
#line 530
  logMagTable[58] = 565348U;
#line 530
  logMagTable[59] = 573460U;
#line 530
  logMagTable[60] = 581528U;
#line 530
  logMagTable[61] = 589553U;
#line 530
  logMagTable[62] = 597536U;
#line 530
  logMagTable[63] = 605478U;
#line 530
  logMagTable[64] = 613377U;
#line 530
  logMagTable[65] = 621236U;
#line 530
  logMagTable[66] = 629054U;
#line 530
  logMagTable[67] = 636831U;
#line 530
  logMagTable[68] = 644569U;
#line 530
  logMagTable[69] = 652268U;
#line 530
  logMagTable[70] = 659928U;
#line 530
  logMagTable[71] = 667549U;
#line 530
  logMagTable[72] = 675132U;
#line 530
  logMagTable[73] = 682677U;
#line 530
  logMagTable[74] = 690184U;
#line 530
  logMagTable[75] = 697655U;
#line 530
  logMagTable[76] = 705089U;
#line 530
  logMagTable[77] = 712486U;
#line 530
  logMagTable[78] = 719847U;
#line 530
  logMagTable[79] = 727173U;
#line 530
  logMagTable[80] = 734464U;
#line 530
  logMagTable[81] = 741719U;
#line 530
  logMagTable[82] = 748940U;
#line 530
  logMagTable[83] = 756127U;
#line 530
  logMagTable[84] = 763279U;
#line 530
  logMagTable[85] = 770398U;
#line 530
  logMagTable[86] = 777484U;
#line 530
  logMagTable[87] = 784537U;
#line 530
  logMagTable[88] = 791556U;
#line 530
  logMagTable[89] = 798544U;
#line 530
  logMagTable[90] = 805499U;
#line 530
  logMagTable[91] = 812423U;
#line 530
  logMagTable[92] = 819315U;
#line 530
  logMagTable[93] = 826175U;
#line 530
  logMagTable[94] = 833005U;
#line 530
  logMagTable[95] = 839804U;
#line 530
  logMagTable[96] = 846572U;
#line 530
  logMagTable[97] = 853311U;
#line 530
  logMagTable[98] = 860019U;
#line 530
  logMagTable[99] = 866698U;
#line 530
  logMagTable[100] = 873348U;
#line 530
  logMagTable[101] = 879968U;
#line 530
  logMagTable[102] = 886560U;
#line 530
  logMagTable[103] = 893123U;
#line 530
  logMagTable[104] = 899658U;
#line 530
  logMagTable[105] = 906164U;
#line 530
  logMagTable[106] = 912643U;
#line 530
  logMagTable[107] = 919094U;
#line 530
  logMagTable[108] = 925518U;
#line 530
  logMagTable[109] = 931914U;
#line 530
  logMagTable[110] = 938284U;
#line 530
  logMagTable[111] = 944627U;
#line 530
  logMagTable[112] = 950943U;
#line 530
  logMagTable[113] = 957233U;
#line 530
  logMagTable[114] = 963497U;
#line 530
  logMagTable[115] = 969736U;
#line 530
  logMagTable[116] = 975948U;
#line 530
  logMagTable[117] = 982136U;
#line 530
  logMagTable[118] = 988298U;
#line 530
  logMagTable[119] = 994435U;
#line 530
  logMagTable[120] = 1000547U;
#line 530
  logMagTable[121] = 1006634U;
#line 530
  logMagTable[122] = 1012698U;
#line 530
  logMagTable[123] = 1018737U;
#line 530
  logMagTable[124] = 1024752U;
#line 530
  logMagTable[125] = 1030743U;
#line 530
  logMagTable[126] = 1036711U;
#line 530
  logMagTable[127] = 1042655U;
#line 548
  logSlopeTable[0] = 92;
#line 548
  logSlopeTable[1] = 92;
#line 548
  logSlopeTable[2] = 91;
#line 548
  logSlopeTable[3] = 90;
#line 548
  logSlopeTable[4] = 90;
#line 548
  logSlopeTable[5] = 89;
#line 548
  logSlopeTable[6] = 88;
#line 548
  logSlopeTable[7] = 88;
#line 548
  logSlopeTable[8] = 87;
#line 548
  logSlopeTable[9] = 86;
#line 548
  logSlopeTable[10] = 86;
#line 548
  logSlopeTable[11] = 85;
#line 548
  logSlopeTable[12] = 85;
#line 548
  logSlopeTable[13] = 84;
#line 548
  logSlopeTable[14] = 83;
#line 548
  logSlopeTable[15] = 83;
#line 548
  logSlopeTable[16] = 82;
#line 548
  logSlopeTable[17] = 82;
#line 548
  logSlopeTable[18] = 81;
#line 548
  logSlopeTable[19] = 81;
#line 548
  logSlopeTable[20] = 80;
#line 548
  logSlopeTable[21] = 80;
#line 548
  logSlopeTable[22] = 79;
#line 548
  logSlopeTable[23] = 79;
#line 548
  logSlopeTable[24] = 78;
#line 548
  logSlopeTable[25] = 77;
#line 548
  logSlopeTable[26] = 77;
#line 548
  logSlopeTable[27] = 77;
#line 548
  logSlopeTable[28] = 76;
#line 548
  logSlopeTable[29] = 76;
#line 548
  logSlopeTable[30] = 75;
#line 548
  logSlopeTable[31] = 75;
#line 548
  logSlopeTable[32] = 74;
#line 548
  logSlopeTable[33] = 74;
#line 548
  logSlopeTable[34] = 73;
#line 548
  logSlopeTable[35] = 73;
#line 548
  logSlopeTable[36] = 72;
#line 548
  logSlopeTable[37] = 72;
#line 548
  logSlopeTable[38] = 71;
#line 548
  logSlopeTable[39] = 71;
#line 548
  logSlopeTable[40] = 71;
#line 548
  logSlopeTable[41] = 70;
#line 548
  logSlopeTable[42] = 70;
#line 548
  logSlopeTable[43] = 69;
#line 548
  logSlopeTable[44] = 69;
#line 548
  logSlopeTable[45] = 69;
#line 548
  logSlopeTable[46] = 68;
#line 548
  logSlopeTable[47] = 68;
#line 548
  logSlopeTable[48] = 67;
#line 548
  logSlopeTable[49] = 67;
#line 548
  logSlopeTable[50] = 67;
#line 548
  logSlopeTable[51] = 66;
#line 548
  logSlopeTable[52] = 66;
#line 548
  logSlopeTable[53] = 66;
#line 548
  logSlopeTable[54] = 65;
#line 548
  logSlopeTable[55] = 65;
#line 548
  logSlopeTable[56] = 65;
#line 548
  logSlopeTable[57] = 64;
#line 548
  logSlopeTable[58] = 64;
#line 548
  logSlopeTable[59] = 64;
#line 548
  logSlopeTable[60] = 63;
#line 548
  logSlopeTable[61] = 63;
#line 548
  logSlopeTable[62] = 63;
#line 548
  logSlopeTable[63] = 62;
#line 548
  logSlopeTable[64] = 62;
#line 548
  logSlopeTable[65] = 62;
#line 548
  logSlopeTable[66] = 61;
#line 548
  logSlopeTable[67] = 61;
#line 548
  logSlopeTable[68] = 61;
#line 548
  logSlopeTable[69] = 60;
#line 548
  logSlopeTable[70] = 60;
#line 548
  logSlopeTable[71] = 60;
#line 548
  logSlopeTable[72] = 59;
#line 548
  logSlopeTable[73] = 59;
#line 548
  logSlopeTable[74] = 59;
#line 548
  logSlopeTable[75] = 59;
#line 548
  logSlopeTable[76] = 58;
#line 548
  logSlopeTable[77] = 58;
#line 548
  logSlopeTable[78] = 58;
#line 548
  logSlopeTable[79] = 57;
#line 548
  logSlopeTable[80] = 57;
#line 548
  logSlopeTable[81] = 57;
#line 548
  logSlopeTable[82] = 57;
#line 548
  logSlopeTable[83] = 56;
#line 548
  logSlopeTable[84] = 56;
#line 548
  logSlopeTable[85] = 56;
#line 548
  logSlopeTable[86] = 56;
#line 548
  logSlopeTable[87] = 55;
#line 548
  logSlopeTable[88] = 55;
#line 548
  logSlopeTable[89] = 55;
#line 548
  logSlopeTable[90] = 55;
#line 548
  logSlopeTable[91] = 54;
#line 548
  logSlopeTable[92] = 54;
#line 548
  logSlopeTable[93] = 54;
#line 548
  logSlopeTable[94] = 54;
#line 548
  logSlopeTable[95] = 53;
#line 548
  logSlopeTable[96] = 53;
#line 548
  logSlopeTable[97] = 53;
#line 548
  logSlopeTable[98] = 53;
#line 548
  logSlopeTable[99] = 52;
#line 548
  logSlopeTable[100] = 52;
#line 548
  logSlopeTable[101] = 52;
#line 548
  logSlopeTable[102] = 52;
#line 548
  logSlopeTable[103] = 52;
#line 548
  logSlopeTable[104] = 51;
#line 548
  logSlopeTable[105] = 51;
#line 548
  logSlopeTable[106] = 51;
#line 548
  logSlopeTable[107] = 51;
#line 548
  logSlopeTable[108] = 50;
#line 548
  logSlopeTable[109] = 50;
#line 548
  logSlopeTable[110] = 50;
#line 548
  logSlopeTable[111] = 50;
#line 548
  logSlopeTable[112] = 50;
#line 548
  logSlopeTable[113] = 49;
#line 548
  logSlopeTable[114] = 49;
#line 548
  logSlopeTable[115] = 49;
#line 548
  logSlopeTable[116] = 49;
#line 548
  logSlopeTable[117] = 49;
#line 548
  logSlopeTable[118] = 48;
#line 548
  logSlopeTable[119] = 48;
#line 548
  logSlopeTable[120] = 48;
#line 548
  logSlopeTable[121] = 48;
#line 548
  logSlopeTable[122] = 48;
#line 548
  logSlopeTable[123] = 47;
#line 548
  logSlopeTable[124] = 47;
#line 548
  logSlopeTable[125] = 47;
#line 548
  logSlopeTable[126] = 47;
#line 548
  logSlopeTable[127] = 47;
#line 568
  if (rate == 0U) {
#line 569
    return (0U);
  } else {

  }
#line 570
  rate = rate * 11185U;
#line 571
  i = 31;
#line 571
  goto ldv_30687;
  ldv_30686: ;
#line 572
  if ((int )rate < 0) {
#line 573
    return ((((unsigned int )(i + -15) << 20) + logMagTable[(rate >> 24) & 127U]) + ((rate >> 17) & 127U) * (unsigned int )logSlopeTable[(rate >> 24) & 127U]);
  } else {

  }
#line 578
  rate = rate << 1;
#line 571
  i = i - 1;
  ldv_30687: ;
#line 571
  if (i > 0) {
#line 573
    goto ldv_30686;
  } else {

  }

#line 581
  return (0U);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_33___4(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_35___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 515 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_37___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 518
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 520
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 521
  return;
}
}
#line 533 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_39___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 536
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 538
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 539
  return;
}
}
#line 551 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_41(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 554
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 556
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 557
  return;
}
}
#line 569 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_43(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 572
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 574
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 575
  return;
}
}
#line 587 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
__inline static void ldv_spin_lock_45(spinlock_t *lock ) 
{ 


  {
  {
#line 590
  ldv_spin_lock_spi_lock_of_snd_emu10k1();
#line 592
  spin_lock(lock);
  }
#line 593
  return;
}
}
#line 596 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
__inline static void ldv_spin_unlock_46(spinlock_t *lock ) 
{ 


  {
  {
#line 599
  ldv_spin_unlock_spi_lock_of_snd_emu10k1();
#line 601
  spin_unlock(lock);
  }
#line 602
  return;
}
}
#line 605 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
__inline static void ldv_spin_lock_47___0(spinlock_t *lock ) 
{ 


  {
  {
#line 608
  ldv_spin_lock_i2c_lock_of_snd_emu10k1();
#line 610
  spin_lock(lock);
  }
#line 611
  return;
}
}
#line 614 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
__inline static void ldv_spin_unlock_48___0(spinlock_t *lock ) 
{ 


  {
  {
#line 617
  ldv_spin_unlock_i2c_lock_of_snd_emu10k1();
#line 619
  spin_unlock(lock);
  }
#line 620
  return;
}
}
#line 623 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_49(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 626
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 628
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 629
  return;
}
}
#line 641 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_51___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 644
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 646
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 647
  return;
}
}
#line 659 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_53(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 662
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 664
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 665
  return;
}
}
#line 677 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_55(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 680
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 682
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 683
  return;
}
}
#line 695 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_57(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 698
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 700
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 701
  return;
}
}
#line 713 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_59(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 716
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 718
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 719
  return;
}
}
#line 731 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_61(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 734
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 736
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 737
  return;
}
}
#line 749 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_63(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 752
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 754
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 755
  return;
}
}
#line 767 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_65(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 770
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 772
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 773
  return;
}
}
#line 785 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_67(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 788
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 790
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 791
  return;
}
}
#line 803 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_69(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 806
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 808
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 809
  return;
}
}
#line 821 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_71(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 824
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 826
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 827
  return;
}
}
#line 839 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_73(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 842
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 844
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 845
  return;
}
}
#line 857 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_io.c.aux"
static void ldv___ldv_spin_lock_75(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 860
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 862
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 863
  return;
}
}
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/slab.h"
void *ldv_kmalloc(size_t size , gfp_t flags ) ;
#line 331 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kernel.h"
extern int sscanf(char const   * , char const   *  , ...) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_33___5(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___2(spinlock_t *ldv_func_arg1 ) ;
#line 33
static void ldv___ldv_spin_lock_37___1(spinlock_t *ldv_func_arg1 ) ;
#line 37
static void ldv___ldv_spin_lock_39___1(spinlock_t *ldv_func_arg1 ) ;
#line 41
static void ldv___ldv_spin_lock_41___0(spinlock_t *ldv_func_arg1 ) ;
#line 45
static void ldv___ldv_spin_lock_43___0(spinlock_t *ldv_func_arg1 ) ;
#line 49
static void ldv___ldv_spin_lock_45___0(spinlock_t *ldv_func_arg1 ) ;
#line 53
static void ldv___ldv_spin_lock_47(spinlock_t *ldv_func_arg1 ) ;
#line 57
static void ldv___ldv_spin_lock_49___0(spinlock_t *ldv_func_arg1 ) ;
#line 390 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 398
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 402
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 406
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 410
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 414
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 418
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 422
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 265 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 40 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 63 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 65
  might_fault();
#line 67
  tmp = _copy_to_user(dst, src, size);
  }
#line 67
  return ((int )tmp);
}
}
#line 114 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
extern int snd_iprintf(struct snd_info_buffer * , char const   *  , ...) ;
#line 118
extern int snd_info_get_line(struct snd_info_buffer * , char * , int  ) ;
#line 138
extern int snd_card_proc_new(struct snd_card * , char const   * , struct snd_info_entry ** ) ;
#line 141 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/info.h"
__inline static void snd_info_set_text_ops(struct snd_info_entry *entry , void *private_data ,
                                           void (*read)(struct snd_info_entry * ,
                                                        struct snd_info_buffer * ) ) 
{ 


  {
#line 145
  entry->private_data = private_data;
#line 146
  entry->c.text.read = read;
#line 147
  return;
}
}
#line 1842 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
unsigned int snd_emu10k1_efx_read(struct snd_emu10k1 *emu , unsigned int pc ) ;
#line 38 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu10k1_proc_spdif_status(struct snd_emu10k1 *emu , struct snd_info_buffer *buffer ,
                                          char *title , int status_reg , int rate_reg ) 
{ 
  char *clkaccy[4U] ;
  int samplerate[16U] ;
  char *channel[16U] ;
  char *emphasis[8U] ;
  unsigned int status ;
  unsigned int rate ;

  {
  {
#line 44
  clkaccy[0] = (char *)"1000ppm";
#line 44
  clkaccy[1] = (char *)"50ppm";
#line 44
  clkaccy[2] = (char *)"variable";
#line 44
  clkaccy[3] = (char *)"unknown";
#line 45
  samplerate[0] = 44100;
#line 45
  samplerate[1] = 1;
#line 45
  samplerate[2] = 48000;
#line 45
  samplerate[3] = 32000;
#line 45
  samplerate[4] = 4;
#line 45
  samplerate[5] = 5;
#line 45
  samplerate[6] = 6;
#line 45
  samplerate[7] = 7;
#line 45
  samplerate[8] = 8;
#line 45
  samplerate[9] = 9;
#line 45
  samplerate[10] = 10;
#line 45
  samplerate[11] = 11;
#line 45
  samplerate[12] = 12;
#line 45
  samplerate[13] = 13;
#line 45
  samplerate[14] = 14;
#line 45
  samplerate[15] = 15;
#line 46
  channel[0] = (char *)"unspec";
#line 46
  channel[1] = (char *)"left";
#line 46
  channel[2] = (char *)"right";
#line 46
  channel[3] = (char *)"3";
#line 46
  channel[4] = (char *)"4";
#line 46
  channel[5] = (char *)"5";
#line 46
  channel[6] = (char *)"6";
#line 46
  channel[7] = (char *)"7";
#line 46
  channel[8] = (char *)"8";
#line 46
  channel[9] = (char *)"9";
#line 46
  channel[10] = (char *)"10";
#line 46
  channel[11] = (char *)"11";
#line 46
  channel[12] = (char *)"12";
#line 46
  channel[13] = (char *)"13";
#line 46
  channel[14] = (char *)"14";
#line 46
  channel[15] = (char *)"15";
#line 47
  emphasis[0] = (char *)"none";
#line 47
  emphasis[1] = (char *)"50/15 usec 2 channel";
#line 47
  emphasis[2] = (char *)"2";
#line 47
  emphasis[3] = (char *)"3";
#line 47
  emphasis[4] = (char *)"4";
#line 47
  emphasis[5] = (char *)"5";
#line 47
  emphasis[6] = (char *)"6";
#line 47
  emphasis[7] = (char *)"7";
#line 48
  rate = 0U;
#line 50
  status = snd_emu10k1_ptr_read(emu, (unsigned int )status_reg, 0U);
#line 52
  snd_iprintf(buffer, "\n%s\n", title);
  }
#line 54
  if (status != 4294967295U) {
    {
#line 55
    snd_iprintf(buffer, "Professional Mode     : %s\n", (int )status & 1 ? (char *)"yes" : (char *)"no");
#line 56
    snd_iprintf(buffer, "Not Audio Data        : %s\n", (status & 2U) != 0U ? (char *)"yes" : (char *)"no");
#line 57
    snd_iprintf(buffer, "Copyright             : %s\n", (status & 4U) != 0U ? (char *)"yes" : (char *)"no");
#line 58
    snd_iprintf(buffer, "Emphasis              : %s\n", emphasis[(status & 56U) >> 3]);
#line 59
    snd_iprintf(buffer, "Mode                  : %i\n", (status & 192U) >> 6);
#line 60
    snd_iprintf(buffer, "Category Code         : 0x%x\n", (status & 32512U) >> 8);
#line 61
    snd_iprintf(buffer, "Generation Status     : %s\n", (status & 32768U) != 0U ? (char *)"original" : (char *)"copy");
#line 62
    snd_iprintf(buffer, "Source Mask           : %i\n", (status & 983040U) >> 16);
#line 63
    snd_iprintf(buffer, "Channel Number        : %s\n", channel[(status & 15728640U) >> 20]);
#line 64
    snd_iprintf(buffer, "Sample Rate           : %iHz\n", samplerate[(status & 251658240U) >> 24]);
#line 65
    snd_iprintf(buffer, "Clock Accuracy        : %s\n", clkaccy[(status & 805306368U) >> 28]);
    }
#line 67
    if (rate_reg > 0) {
      {
#line 68
      rate = snd_emu10k1_ptr_read(emu, (unsigned int )rate_reg, 0U);
#line 69
      snd_iprintf(buffer, "S/PDIF Valid          : %s\n", (rate & 67108864U) != 0U ? (char *)"on" : (char *)"off");
#line 70
      snd_iprintf(buffer, "S/PDIF Locked         : %s\n", (rate & 33554432U) != 0U ? (char *)"on" : (char *)"off");
#line 71
      snd_iprintf(buffer, "Rate Locked           : %s\n", (rate & 16777216U) != 0U ? (char *)"on" : (char *)"off");
#line 73
      snd_iprintf(buffer, "Estimated Sample Rate : %d\n", (rate & 1048575U) * 375U >> 11);
      }
    } else {

    }
  } else {
    {
#line 76
    snd_iprintf(buffer, "No signal detected.\n");
    }
  }
#line 77
  return;
}
}
#line 81 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu10k1_proc_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  char *creative_outs___0[32U] ;
  char *audigy_outs___0[64U] ;
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  unsigned int val1 ;
  int nefx ;
  char **outputs ;
  int idx ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 85
  creative_outs___0[0] = (char *)"AC97 Left";
#line 85
  creative_outs___0[1] = (char *)"AC97 Right";
#line 85
  creative_outs___0[2] = (char *)"Optical IEC958 Left";
#line 85
  creative_outs___0[3] = (char *)"Optical IEC958 Right";
#line 85
  creative_outs___0[4] = (char *)"Center";
#line 85
  creative_outs___0[5] = (char *)"LFE";
#line 85
  creative_outs___0[6] = (char *)"Headphone Left";
#line 85
  creative_outs___0[7] = (char *)"Headphone Right";
#line 85
  creative_outs___0[8] = (char *)"Surround Left";
#line 85
  creative_outs___0[9] = (char *)"Surround Right";
#line 85
  creative_outs___0[10] = (char *)"PCM Capture Left";
#line 85
  creative_outs___0[11] = (char *)"PCM Capture Right";
#line 85
  creative_outs___0[12] = (char *)"MIC Capture";
#line 85
  creative_outs___0[13] = (char *)"AC97 Surround Left";
#line 85
  creative_outs___0[14] = (char *)"AC97 Surround Right";
#line 85
  creative_outs___0[15] = (char *)"???";
#line 85
  creative_outs___0[16] = (char *)"???";
#line 85
  creative_outs___0[17] = (char *)"Analog Center";
#line 85
  creative_outs___0[18] = (char *)"Analog LFE";
#line 85
  creative_outs___0[19] = (char *)"???";
#line 85
  creative_outs___0[20] = (char *)"???";
#line 85
  creative_outs___0[21] = (char *)"???";
#line 85
  creative_outs___0[22] = (char *)"???";
#line 85
  creative_outs___0[23] = (char *)"???";
#line 85
  creative_outs___0[24] = (char *)"???";
#line 85
  creative_outs___0[25] = (char *)"???";
#line 85
  creative_outs___0[26] = (char *)"???";
#line 85
  creative_outs___0[27] = (char *)"???";
#line 85
  creative_outs___0[28] = (char *)"???";
#line 85
  creative_outs___0[29] = (char *)"???";
#line 85
  creative_outs___0[30] = (char *)"???";
#line 85
  creative_outs___0[31] = (char *)"???";
#line 120
  audigy_outs___0[0] = (char *)"Digital Front Left";
#line 120
  audigy_outs___0[1] = (char *)"Digital Front Right";
#line 120
  audigy_outs___0[2] = (char *)"Digital Center";
#line 120
  audigy_outs___0[3] = (char *)"Digital LEF";
#line 120
  audigy_outs___0[4] = (char *)"Headphone Left";
#line 120
  audigy_outs___0[5] = (char *)"Headphone Right";
#line 120
  audigy_outs___0[6] = (char *)"Digital Rear Left";
#line 120
  audigy_outs___0[7] = (char *)"Digital Rear Right";
#line 120
  audigy_outs___0[8] = (char *)"Front Left";
#line 120
  audigy_outs___0[9] = (char *)"Front Right";
#line 120
  audigy_outs___0[10] = (char *)"Center";
#line 120
  audigy_outs___0[11] = (char *)"LFE";
#line 120
  audigy_outs___0[12] = (char *)"???";
#line 120
  audigy_outs___0[13] = (char *)"???";
#line 120
  audigy_outs___0[14] = (char *)"Rear Left";
#line 120
  audigy_outs___0[15] = (char *)"Rear Right";
#line 120
  audigy_outs___0[16] = (char *)"AC97 Front Left";
#line 120
  audigy_outs___0[17] = (char *)"AC97 Front Right";
#line 120
  audigy_outs___0[18] = (char *)"ADC Caputre Left";
#line 120
  audigy_outs___0[19] = (char *)"ADC Capture Right";
#line 120
  audigy_outs___0[20] = (char *)"???";
#line 120
  audigy_outs___0[21] = (char *)"???";
#line 120
  audigy_outs___0[22] = (char *)"???";
#line 120
  audigy_outs___0[23] = (char *)"???";
#line 120
  audigy_outs___0[24] = (char *)"???";
#line 120
  audigy_outs___0[25] = (char *)"???";
#line 120
  audigy_outs___0[26] = (char *)"???";
#line 120
  audigy_outs___0[27] = (char *)"???";
#line 120
  audigy_outs___0[28] = (char *)"???";
#line 120
  audigy_outs___0[29] = (char *)"???";
#line 120
  audigy_outs___0[30] = (char *)"???";
#line 120
  audigy_outs___0[31] = (char *)"???";
#line 120
  audigy_outs___0[32] = (char *)"FXBUS2_0";
#line 120
  audigy_outs___0[33] = (char *)"FXBUS2_1";
#line 120
  audigy_outs___0[34] = (char *)"FXBUS2_2";
#line 120
  audigy_outs___0[35] = (char *)"FXBUS2_3";
#line 120
  audigy_outs___0[36] = (char *)"FXBUS2_4";
#line 120
  audigy_outs___0[37] = (char *)"FXBUS2_5";
#line 120
  audigy_outs___0[38] = (char *)"FXBUS2_6";
#line 120
  audigy_outs___0[39] = (char *)"FXBUS2_7";
#line 120
  audigy_outs___0[40] = (char *)"FXBUS2_8";
#line 120
  audigy_outs___0[41] = (char *)"FXBUS2_9";
#line 120
  audigy_outs___0[42] = (char *)"FXBUS2_10";
#line 120
  audigy_outs___0[43] = (char *)"FXBUS2_11";
#line 120
  audigy_outs___0[44] = (char *)"FXBUS2_12";
#line 120
  audigy_outs___0[45] = (char *)"FXBUS2_13";
#line 120
  audigy_outs___0[46] = (char *)"FXBUS2_14";
#line 120
  audigy_outs___0[47] = (char *)"FXBUS2_15";
#line 120
  audigy_outs___0[48] = (char *)"FXBUS2_16";
#line 120
  audigy_outs___0[49] = (char *)"FXBUS2_17";
#line 120
  audigy_outs___0[50] = (char *)"FXBUS2_18";
#line 120
  audigy_outs___0[51] = (char *)"FXBUS2_19";
#line 120
  audigy_outs___0[52] = (char *)"FXBUS2_20";
#line 120
  audigy_outs___0[53] = (char *)"FXBUS2_21";
#line 120
  audigy_outs___0[54] = (char *)"FXBUS2_22";
#line 120
  audigy_outs___0[55] = (char *)"FXBUS2_23";
#line 120
  audigy_outs___0[56] = (char *)"FXBUS2_24";
#line 120
  audigy_outs___0[57] = (char *)"FXBUS2_25";
#line 120
  audigy_outs___0[58] = (char *)"FXBUS2_26";
#line 120
  audigy_outs___0[59] = (char *)"FXBUS2_27";
#line 120
  audigy_outs___0[60] = (char *)"FXBUS2_28";
#line 120
  audigy_outs___0[61] = (char *)"FXBUS2_29";
#line 120
  audigy_outs___0[62] = (char *)"FXBUS2_30";
#line 120
  audigy_outs___0[63] = (char *)"FXBUS2_31";
#line 187
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 189
  nefx = emu->audigy != 0U ? 64 : 32;
#line 190
  outputs = emu->audigy != 0U ? (char **)(& audigy_outs___0) : (char **)(& creative_outs___0);
#line 193
  snd_iprintf(buffer, "EMU10K1\n\n");
#line 194
  snd_iprintf(buffer, "Card                  : %s\n", emu->audigy == 0U ? ((unsigned int )((unsigned char )(emu->card_capabilities)->ecard) != 0U ? (char *)"EMU APS" : (char *)"Creative") : (char *)"Audigy");
#line 196
  snd_iprintf(buffer, "Internal TRAM (words) : 0x%x\n", emu->fx8010.itram_size);
#line 197
  snd_iprintf(buffer, "External TRAM (words) : 0x%x\n", (int )emu->fx8010.etram_pages.bytes / 2);
#line 198
  snd_iprintf(buffer, "\n");
#line 199
  snd_iprintf(buffer, "Effect Send Routing   :\n");
#line 200
  idx = 0;
  }
#line 200
  goto ldv_30331;
  ldv_30330: ;
#line 201
  if (emu->audigy != 0U) {
    {
#line 201
    tmp = snd_emu10k1_ptr_read(emu, 126U, (unsigned int )idx);
#line 201
    val = tmp;
    }
  } else {
    {
#line 201
    tmp___0 = snd_emu10k1_ptr_read(emu, 11U, (unsigned int )idx);
#line 201
    val = tmp___0;
    }
  }
#line 204
  if (emu->audigy != 0U) {
    {
#line 204
    tmp___1 = snd_emu10k1_ptr_read(emu, 124U, (unsigned int )idx);
#line 204
    val1 = tmp___1;
    }
  } else {
#line 204
    val1 = 0U;
  }
#line 207
  if (emu->audigy != 0U) {
    {
#line 208
    snd_iprintf(buffer, "Ch%i: A=%i, B=%i, C=%i, D=%i, ", idx, val & 63U, (val >> 8) & 63U,
                (val >> 16) & 63U, (val >> 24) & 63U);
#line 214
    snd_iprintf(buffer, "E=%i, F=%i, G=%i, H=%i\n", val1 & 63U, (val1 >> 8) & 63U,
                (val1 >> 16) & 63U, (val1 >> 24) & 63U);
    }
  } else {
    {
#line 220
    snd_iprintf(buffer, "Ch%i: A=%i, B=%i, C=%i, D=%i\n", idx, (val >> 16) & 15U,
                (val >> 20) & 15U, (val >> 24) & 15U, val >> 28);
    }
  }
#line 200
  idx = idx + 1;
  ldv_30331: ;
#line 200
  if (idx <= 63) {
#line 202
    goto ldv_30330;
  } else {

  }
  {
#line 228
  snd_iprintf(buffer, "\nCaptured FX Outputs   :\n");
#line 229
  idx = 0;
  }
#line 229
  goto ldv_30334;
  ldv_30333: ;
#line 230
  if ((emu->efx_voices_mask[idx / 32] & (unsigned int )(1 << idx % 32)) != 0U) {
    {
#line 231
    snd_iprintf(buffer, "  Output %02i [%s]\n", idx, *(outputs + (unsigned long )idx));
    }
  } else {

  }
#line 229
  idx = idx + 1;
  ldv_30334: ;
#line 229
  if (idx < nefx) {
#line 231
    goto ldv_30333;
  } else {

  }
  {
#line 233
  snd_iprintf(buffer, "\nAll FX Outputs        :\n");
#line 234
  idx = 0;
  }
#line 234
  goto ldv_30337;
  ldv_30336: 
  {
#line 235
  snd_iprintf(buffer, "  Output %02i [%s]\n", idx, *(outputs + (unsigned long )idx));
#line 234
  idx = idx + 1;
  }
  ldv_30337: ;
#line 234
  if (idx < (emu->audigy != 0U ? 64 : 32)) {
#line 236
    goto ldv_30336;
  } else {

  }

#line 241
  return;
}
}
#line 238 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_emu10k1 *emu ;
  u32 value ;
  u32 value2 ;
  unsigned long flags ;
  u32 rate ;

  {
#line 241
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 247
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 248
    ldv___ldv_spin_lock_33___5(& emu->emu_lock);
#line 249
    snd_emu1010_fpga_read(emu, 56U, & value);
#line 250
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
#line 251
    if ((value & 1U) == 0U) {
      {
#line 252
      ldv___ldv_spin_lock_35___2(& emu->emu_lock);
#line 253
      snd_emu1010_fpga_read(emu, 42U, & value);
#line 254
      snd_emu1010_fpga_read(emu, 43U, & value2);
#line 255
      ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
#line 256
      rate = 24576000U / (((value << 5) | value2) + 1U);
#line 257
      snd_iprintf(buffer, "ADAT Locked : %u\n", rate);
      }
    } else {
      {
#line 259
      snd_iprintf(buffer, "ADAT Unlocked\n");
      }
    }
    {
#line 261
    ldv___ldv_spin_lock_37___1(& emu->emu_lock);
#line 262
    snd_emu1010_fpga_read(emu, 32U, & value);
#line 263
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
#line 264
    if ((value & 4U) == 0U) {
      {
#line 265
      ldv___ldv_spin_lock_39___1(& emu->emu_lock);
#line 266
      snd_emu1010_fpga_read(emu, 40U, & value);
#line 267
      snd_emu1010_fpga_read(emu, 41U, & value2);
#line 268
      ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
#line 269
      rate = 24576000U / (((value << 5) | value2) + 1U);
#line 270
      snd_iprintf(buffer, "SPDIF Locked : %d\n", rate);
      }
    } else {
      {
#line 272
      snd_iprintf(buffer, "SPDIF Unlocked\n");
      }
    }
  } else {
    {
#line 275
    snd_emu10k1_proc_spdif_status(emu, buffer, (char *)"CD-ROM S/PDIF In", 80, 96);
#line 276
    snd_emu10k1_proc_spdif_status(emu, buffer, (char *)"Optical or Coax S/PDIF In",
                                  81, 97);
    }
  }
#line 278
  return;
}
}
#line 286 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu10k1_proc_rates_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  int samplerate[8U] ;
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  unsigned int tmp ;
  unsigned int n ;

  {
  {
#line 289
  samplerate[0] = 44100;
#line 289
  samplerate[1] = 48000;
#line 289
  samplerate[2] = 96000;
#line 289
  samplerate[3] = 192000;
#line 289
  samplerate[4] = 4;
#line 289
  samplerate[5] = 5;
#line 289
  samplerate[6] = 6;
#line 289
  samplerate[7] = 7;
#line 290
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 292
  val = snd_emu10k1_ptr20_read(emu, 23U, 0U);
#line 293
  tmp = (val >> 16) & 8U;
#line 294
  n = 0U;
  }
#line 294
  goto ldv_30358;
  ldv_30357: 
#line 295
  tmp = val >> (int )((n + 4U) * 4U);
#line 296
  if ((tmp & 8U) != 0U) {
    {
#line 296
    snd_iprintf(buffer, "Channel %d: Rate=%d\n", n, samplerate[tmp & 7U]);
    }
  } else {
    {
#line 297
    snd_iprintf(buffer, "Channel %d: No input\n", n);
    }
  }
#line 294
  n = n + 1U;
  ldv_30358: ;
#line 294
  if (n <= 3U) {
#line 296
    goto ldv_30357;
  } else {

  }

#line 301
  return;
}
}
#line 301 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu10k1_proc_acode_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  u32 pc ;
  struct snd_emu10k1 *emu ;
  u32 low ;
  u32 high ;

  {
  {
#line 305
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 307
  snd_iprintf(buffer, "FX8010 Instruction List \'%s\'\n", (unsigned char *)(& emu->fx8010.name));
#line 308
  snd_iprintf(buffer, "  Code dump      :\n");
#line 309
  pc = 0U;
  }
#line 309
  goto ldv_30369;
  ldv_30368: 
  {
#line 312
  low = snd_emu10k1_efx_read(emu, pc * 2U);
#line 313
  high = snd_emu10k1_efx_read(emu, pc * 2U + 1U);
  }
#line 314
  if (emu->audigy != 0U) {
    {
#line 315
    snd_iprintf(buffer, "    OP(0x%02x, 0x%03x, 0x%03x, 0x%03x, 0x%03x) /* 0x%04x: 0x%08x%08x */\n",
                (high >> 24) & 15U, (high >> 12) & 2047U, high & 2047U, (low >> 12) & 2047U,
                low & 2047U, pc, high, low);
    }
  } else {
    {
#line 324
    snd_iprintf(buffer, "    OP(0x%02x, 0x%03x, 0x%03x, 0x%03x, 0x%03x) /* 0x%04x: 0x%08x%08x */\n",
                (high >> 20) & 15U, (high >> 10) & 1023U, high & 1023U, (low >> 10) & 1023U,
                low & 1023U, pc, high, low);
    }
  }
#line 309
  pc = pc + 1U;
  ldv_30369: ;
#line 309
  if (pc < (emu->audigy != 0U ? 1024U : 512U)) {
#line 311
    goto ldv_30368;
  } else {

  }

#line 316
  return;
}
}
#line 344 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static ssize_t snd_emu10k1_fx8010_read(struct snd_info_entry *entry , void *file_private_data ,
                                       struct file *file , char *buf , size_t count ,
                                       loff_t pos ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int offset ;
  int tram_addr ;
  unsigned int *tmp ;
  long res ;
  unsigned int idx ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned int val ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 349
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 351
  tram_addr = 0;
#line 356
  tmp___2 = strcmp(entry->name, "fx8010_tram_addr");
  }
#line 356
  if (tmp___2 == 0) {
#line 357
    offset = 768U;
#line 358
    tram_addr = 1;
  } else {
    {
#line 359
    tmp___1 = strcmp(entry->name, "fx8010_tram_data");
    }
#line 359
    if (tmp___1 == 0) {
#line 360
      offset = 512U;
    } else {
      {
#line 361
      tmp___0 = strcmp(entry->name, "fx8010_code");
      }
#line 361
      if (tmp___0 == 0) {
#line 362
        offset = emu->audigy != 0U ? 1536U : 1024U;
      } else {
#line 364
        offset = emu->audigy != 0U ? 1024U : 256U;
      }
    }
  }
  {
#line 367
  tmp___3 = kmalloc(count + 8UL, 208U);
#line 367
  tmp = (unsigned int *)tmp___3;
  }
#line 368
  if ((unsigned long )tmp == (unsigned long )((unsigned int *)0U)) {
#line 369
    return (-12L);
  } else {

  }
#line 370
  idx = 0U;
#line 370
  goto ldv_30387;
  ldv_30386: 
  {
#line 372
  val = snd_emu10k1_ptr_read(emu, (offset + idx) + (unsigned int )(pos >> 2), 0U);
  }
#line 373
  if (tram_addr != 0 && emu->audigy != 0U) {
    {
#line 374
    val = val >> 11;
#line 375
    tmp___4 = snd_emu10k1_ptr_read(emu, (idx + (unsigned int )(pos >> 2)) + 256U,
                                   0U);
#line 375
    val = val | (tmp___4 << 20);
    }
  } else {

  }
#line 377
  *(tmp + (unsigned long )idx) = val;
#line 370
  idx = idx + 1U;
  ldv_30387: ;
#line 370
  if ((unsigned long long )idx < ((((unsigned long long )pos & 3ULL) + (unsigned long long )count) + 3ULL) >> 2) {
#line 372
    goto ldv_30386;
  } else {

  }
  {
#line 379
  tmp___5 = copy_to_user((void *)buf, (void const   *)((char *)tmp + ((unsigned long )pos & 3UL)),
                         (unsigned int )count);
  }
#line 379
  if (tmp___5 != 0) {
#line 380
    res = -14L;
  } else {
#line 382
    res = (long )count;
  }
  {
#line 383
  kfree((void const   *)tmp);
  }
#line 384
  return (res);
}
}
#line 387 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu10k1_proc_voices_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_voice *voice ;
  int idx ;

  {
  {
#line 390
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 394
  snd_iprintf(buffer, "ch\tuse\tpcm\tefx\tsynth\tmidi\n");
#line 395
  idx = 0;
  }
#line 395
  goto ldv_30397;
  ldv_30396: 
  {
#line 396
  voice = (struct snd_emu10k1_voice *)(& emu->voices) + (unsigned long )idx;
#line 397
  snd_iprintf(buffer, "%i\t%i\t%i\t%i\t%i\t%i\n", idx, (int )voice->use, (int )voice->pcm,
              (int )voice->efx, (int )voice->synth, (int )voice->midi);
#line 395
  idx = idx + 1;
  }
  ldv_30397: ;
#line 395
  if (idx <= 63) {
#line 397
    goto ldv_30396;
  } else {

  }

#line 402
  return;
}
}
#line 408 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_emu10k1 *emu ;
  u32 value ;
  unsigned long flags ;
  int i ;

  {
  {
#line 411
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 415
  snd_iprintf(buffer, "EMU1010 Registers:\n\n");
#line 417
  i = 0;
  }
#line 417
  goto ldv_30408;
  ldv_30407: 
  {
#line 418
  ldv___ldv_spin_lock_41___0(& emu->emu_lock);
#line 419
  snd_emu1010_fpga_read(emu, (u32 )i, & value);
#line 420
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
#line 421
  snd_iprintf(buffer, "%02X: %08X, %02X\n", i, value, (value >> 8) & 127U);
#line 417
  i = i + 1;
  }
  ldv_30408: ;
#line 417
  if (i <= 63) {
#line 419
    goto ldv_30407;
  } else {

  }

#line 424
  return;
}
}
#line 425 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_io_reg_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long value ;
  unsigned long flags ;
  int i ;
  unsigned int tmp ;

  {
  {
#line 428
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 432
  snd_iprintf(buffer, "IO Registers:\n\n");
#line 433
  i = 0;
  }
#line 433
  goto ldv_30419;
  ldv_30418: 
  {
#line 434
  ldv___ldv_spin_lock_43___0(& emu->emu_lock);
#line 435
  tmp = inl((int )((unsigned int )emu->port + (unsigned int )i));
#line 435
  value = (unsigned long )tmp;
#line 436
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
#line 437
  snd_iprintf(buffer, "%02X: %08lX\n", i, value);
#line 433
  i = i + 4;
  }
  ldv_30419: ;
#line 433
  if (i <= 63) {
#line 435
    goto ldv_30418;
  } else {

  }

#line 440
  return;
}
}
#line 441 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_io_reg_write(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long flags ;
  char line[64U] ;
  u32 reg ;
  u32 val ;
  int tmp ;
  int tmp___0 ;

  {
#line 444
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 448
  goto ldv_30430;
  ldv_30431: 
  {
#line 449
  tmp = sscanf((char const   *)(& line), "%x %x", & reg, & val);
  }
#line 449
  if (tmp != 2) {
#line 450
    goto ldv_30430;
  } else {

  }
#line 451
  if (reg <= 63U) {
    {
#line 452
    ldv___ldv_spin_lock_45___0(& emu->emu_lock);
#line 453
    outl(val, (int )((unsigned int )emu->port + (reg & 4294967292U)));
#line 454
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
    }
  } else {

  }
  ldv_30430: 
  {
#line 448
  tmp___0 = snd_info_get_line(buffer, (char *)(& line), 64);
  }
#line 448
  if (tmp___0 == 0) {
#line 450
    goto ldv_30431;
  } else {

  }

#line 455
  return;
}
}
#line 459 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static unsigned int snd_ptr_read(struct snd_emu10k1 *emu , unsigned int iobase , unsigned int reg ,
                                 unsigned int chn ) 
{ 
  unsigned long flags ;
  unsigned int regptr ;
  unsigned int val ;

  {
  {
#line 467
  regptr = (reg << 16) | chn;
#line 469
  ldv___ldv_spin_lock_47(& emu->emu_lock);
#line 470
  outl(regptr, (int )((unsigned int )emu->port + iobase));
#line 471
  val = inl((int )(((unsigned int )emu->port + iobase) + 4U));
#line 472
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 473
  return (val);
}
}
#line 476 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_ptr_write(struct snd_emu10k1 *emu , unsigned int iobase , unsigned int reg ,
                          unsigned int chn , unsigned int data ) 
{ 
  unsigned int regptr ;
  unsigned long flags ;

  {
  {
#line 485
  regptr = (reg << 16) | chn;
#line 487
  ldv___ldv_spin_lock_49___0(& emu->emu_lock);
#line 488
  outl(regptr, (int )((unsigned int )emu->port + iobase));
#line 489
  outl(data, (int )(((unsigned int )emu->port + iobase) + 4U));
#line 490
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 491
  return;
}
}
#line 494 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ,
                                      int iobase , int offset , int length , int voices ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long value ;
  int i ;
  int j ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 497
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 500
  if (offset + length > 160) {
    {
#line 501
    snd_iprintf(buffer, "Input values out of range\n");
    }
#line 502
    return;
  } else {

  }
  {
#line 504
  snd_iprintf(buffer, "Registers 0x%x\n", iobase);
#line 505
  i = offset;
  }
#line 505
  goto ldv_30467;
  ldv_30466: 
  {
#line 506
  snd_iprintf(buffer, "%02X: ", i);
#line 507
  j = 0;
  }
#line 507
  goto ldv_30464;
  ldv_30463: ;
#line 508
  if (iobase == 0) {
    {
#line 509
    tmp = snd_ptr_read(emu, 0U, (unsigned int )i, (unsigned int )j);
#line 509
    value = (unsigned long )tmp;
    }
  } else {
    {
#line 511
    tmp___0 = snd_ptr_read(emu, 32U, (unsigned int )i, (unsigned int )j);
#line 511
    value = (unsigned long )tmp___0;
    }
  }
  {
#line 512
  snd_iprintf(buffer, "%08lX ", value);
#line 507
  j = j + 1;
  }
  ldv_30464: ;
#line 507
  if (j < voices) {
#line 509
    goto ldv_30463;
  } else {

  }
  {
#line 514
  snd_iprintf(buffer, "\n");
#line 505
  i = i + 1;
  }
  ldv_30467: ;
#line 505
  if (i < offset + length) {
#line 507
    goto ldv_30466;
  } else {

  }

#line 512
  return;
}
}
#line 518 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_write(struct snd_info_entry *entry , struct snd_info_buffer *buffer ,
                                       int iobase ) 
{ 
  struct snd_emu10k1 *emu ;
  char line[64U] ;
  unsigned int reg ;
  unsigned int channel_id ;
  unsigned int val ;
  int tmp ;
  int tmp___0 ;

  {
#line 521
  emu = (struct snd_emu10k1 *)entry->private_data;
#line 524
  goto ldv_30479;
  ldv_30480: 
  {
#line 525
  tmp = sscanf((char const   *)(& line), "%x %x %x", & reg, & channel_id, & val);
  }
#line 525
  if (tmp != 3) {
#line 526
    goto ldv_30479;
  } else {

  }
#line 527
  if (reg <= 159U && channel_id <= 3U) {
    {
#line 528
    snd_ptr_write(emu, (unsigned int )iobase, reg, channel_id, val);
    }
  } else {

  }
  ldv_30479: 
  {
#line 524
  tmp___0 = snd_info_get_line(buffer, (char *)(& line), 64);
  }
#line 524
  if (tmp___0 == 0) {
#line 526
    goto ldv_30480;
  } else {

  }

#line 531
  return;
}
}
#line 532 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_write00(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 535
  snd_emu_proc_ptr_reg_write(entry, buffer, 0);
  }
#line 536
  return;
}
}
#line 538 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_write20(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 541
  snd_emu_proc_ptr_reg_write(entry, buffer, 32);
  }
#line 542
  return;
}
}
#line 545 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_read00a(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 548
  snd_emu_proc_ptr_reg_read(entry, buffer, 0, 0, 64, 64);
  }
#line 549
  return;
}
}
#line 551 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_read00b(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 554
  snd_emu_proc_ptr_reg_read(entry, buffer, 0, 64, 64, 64);
  }
#line 555
  return;
}
}
#line 557 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_read20a(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 560
  snd_emu_proc_ptr_reg_read(entry, buffer, 32, 0, 64, 4);
  }
#line 561
  return;
}
}
#line 563 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_read20b(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 566
  snd_emu_proc_ptr_reg_read(entry, buffer, 32, 64, 64, 4);
  }
#line 567
  return;
}
}
#line 569 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static void snd_emu_proc_ptr_reg_read20c(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 


  {
  {
#line 572
  snd_emu_proc_ptr_reg_read(entry, buffer, 32, 128, 32, 4);
  }
#line 573
  return;
}
}
#line 576 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
static struct snd_info_entry_ops snd_emu10k1_proc_ops_fx8010  = 
#line 576
     {0, 0, & snd_emu10k1_fx8010_read, 0, 0, 0, 0, 0};
#line 580 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emuproc.c"
int snd_emu10k1_proc_init(struct snd_emu10k1 *emu ) 
{ 
  struct snd_info_entry *entry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 584
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 585
    tmp = snd_card_proc_new(emu->card, "emu1010_regs", & entry);
    }
#line 585
    if (tmp == 0) {
      {
#line 586
      snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_emu1010_reg_read);
      }
    } else {

    }
  } else {

  }
  {
#line 588
  tmp___0 = snd_card_proc_new(emu->card, "io_regs", & entry);
  }
#line 588
  if (tmp___0 == 0) {
    {
#line 589
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_io_reg_read);
#line 590
    entry->c.text.write = & snd_emu_proc_io_reg_write;
#line 591
    entry->mode = entry->mode | 128U;
    }
  } else {

  }
  {
#line 593
  tmp___1 = snd_card_proc_new(emu->card, "ptr_regs00a", & entry);
  }
#line 593
  if (tmp___1 == 0) {
    {
#line 594
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_ptr_reg_read00a);
#line 595
    entry->c.text.write = & snd_emu_proc_ptr_reg_write00;
#line 596
    entry->mode = entry->mode | 128U;
    }
  } else {

  }
  {
#line 598
  tmp___2 = snd_card_proc_new(emu->card, "ptr_regs00b", & entry);
  }
#line 598
  if (tmp___2 == 0) {
    {
#line 599
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_ptr_reg_read00b);
#line 600
    entry->c.text.write = & snd_emu_proc_ptr_reg_write00;
#line 601
    entry->mode = entry->mode | 128U;
    }
  } else {

  }
  {
#line 603
  tmp___3 = snd_card_proc_new(emu->card, "ptr_regs20a", & entry);
  }
#line 603
  if (tmp___3 == 0) {
    {
#line 604
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_ptr_reg_read20a);
#line 605
    entry->c.text.write = & snd_emu_proc_ptr_reg_write20;
#line 606
    entry->mode = entry->mode | 128U;
    }
  } else {

  }
  {
#line 608
  tmp___4 = snd_card_proc_new(emu->card, "ptr_regs20b", & entry);
  }
#line 608
  if (tmp___4 == 0) {
    {
#line 609
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_ptr_reg_read20b);
#line 610
    entry->c.text.write = & snd_emu_proc_ptr_reg_write20;
#line 611
    entry->mode = entry->mode | 128U;
    }
  } else {

  }
  {
#line 613
  tmp___5 = snd_card_proc_new(emu->card, "ptr_regs20c", & entry);
  }
#line 613
  if (tmp___5 == 0) {
    {
#line 614
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu_proc_ptr_reg_read20c);
#line 615
    entry->c.text.write = & snd_emu_proc_ptr_reg_write20;
#line 616
    entry->mode = entry->mode | 128U;
    }
  } else {

  }
  {
#line 620
  tmp___6 = snd_card_proc_new(emu->card, "emu10k1", & entry);
  }
#line 620
  if (tmp___6 == 0) {
    {
#line 621
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu10k1_proc_read);
    }
  } else {

  }
#line 623
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu10k2_chip) != 0U) {
    {
#line 624
    tmp___7 = snd_card_proc_new(emu->card, "spdif-in", & entry);
    }
#line 624
    if (tmp___7 == 0) {
      {
#line 625
      snd_info_set_text_ops(entry, (void *)emu, & snd_emu10k1_proc_spdif_read);
      }
    } else {

    }
  } else {

  }
#line 627
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 628
    tmp___8 = snd_card_proc_new(emu->card, "capture-rates", & entry);
    }
#line 628
    if (tmp___8 == 0) {
      {
#line 629
      snd_info_set_text_ops(entry, (void *)emu, & snd_emu10k1_proc_rates_read);
      }
    } else {

    }
  } else {

  }
  {
#line 632
  tmp___9 = snd_card_proc_new(emu->card, "voices", & entry);
  }
#line 632
  if (tmp___9 == 0) {
    {
#line 633
    snd_info_set_text_ops(entry, (void *)emu, & snd_emu10k1_proc_voices_read);
    }
  } else {

  }
  {
#line 635
  tmp___10 = snd_card_proc_new(emu->card, "fx8010_gpr", & entry);
  }
#line 635
  if (tmp___10 == 0) {
#line 636
    entry->content = 1U;
#line 637
    entry->private_data = (void *)emu;
#line 638
    entry->mode = 33060U;
#line 639
    entry->size = emu->audigy != 0U ? 2048L : 1024L;
#line 640
    entry->c.ops = & snd_emu10k1_proc_ops_fx8010;
  } else {

  }
  {
#line 642
  tmp___11 = snd_card_proc_new(emu->card, "fx8010_tram_data", & entry);
  }
#line 642
  if (tmp___11 == 0) {
#line 643
    entry->content = 1U;
#line 644
    entry->private_data = (void *)emu;
#line 645
    entry->mode = 33060U;
#line 646
    entry->size = emu->audigy != 0U ? 1024L : 640L;
#line 647
    entry->c.ops = & snd_emu10k1_proc_ops_fx8010;
  } else {

  }
  {
#line 649
  tmp___12 = snd_card_proc_new(emu->card, "fx8010_tram_addr", & entry);
  }
#line 649
  if (tmp___12 == 0) {
#line 650
    entry->content = 1U;
#line 651
    entry->private_data = (void *)emu;
#line 652
    entry->mode = 33060U;
#line 653
    entry->size = emu->audigy != 0U ? 1024L : 640L;
#line 654
    entry->c.ops = & snd_emu10k1_proc_ops_fx8010;
  } else {

  }
  {
#line 656
  tmp___13 = snd_card_proc_new(emu->card, "fx8010_code", & entry);
  }
#line 656
  if (tmp___13 == 0) {
#line 657
    entry->content = 1U;
#line 658
    entry->private_data = (void *)emu;
#line 659
    entry->mode = 33060U;
#line 660
    entry->size = emu->audigy != 0U ? 8192L : 4096L;
#line 661
    entry->c.ops = & snd_emu10k1_proc_ops_fx8010;
  } else {

  }
  {
#line 663
  tmp___14 = snd_card_proc_new(emu->card, "fx8010_acode", & entry);
  }
#line 663
  if (tmp___14 == 0) {
#line 664
    entry->content = 0U;
#line 665
    entry->private_data = (void *)emu;
#line 666
    entry->mode = 33060U;
#line 667
    entry->c.text.read = & snd_emu10k1_proc_acode_read;
  } else {

  }
#line 669
  return (0);
}
}
#line 284 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 287
  tmp = ldv_kmalloc(size, flags);
  }
#line 287
  return (tmp);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_33___5(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_35___2(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 515 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_37___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 518
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 520
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 521
  return;
}
}
#line 533 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_39___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 536
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 538
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 539
  return;
}
}
#line 551 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_41___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 554
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 556
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 557
  return;
}
}
#line 569 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_43___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 572
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 574
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 575
  return;
}
}
#line 587 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_45___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 590
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 592
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 593
  return;
}
}
#line 605 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_47(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 608
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 610
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 611
  return;
}
}
#line 623 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emuproc.c.aux"
static void ldv___ldv_spin_lock_49___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 626
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 628
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 629
  return;
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_33___6(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___3(spinlock_t *ldv_func_arg1 ) ;
#line 33
static void ldv___ldv_spin_lock_37___2(spinlock_t *ldv_func_arg1 ) ;
#line 37
static void ldv___ldv_spin_lock_39___2(spinlock_t *ldv_func_arg1 ) ;
#line 41
static void ldv___ldv_spin_lock_41___1(spinlock_t *ldv_func_arg1 ) ;
#line 45
static void ldv___ldv_spin_lock_43___1(spinlock_t *ldv_func_arg1 ) ;
#line 49
static void ldv___ldv_spin_lock_45___1(spinlock_t *ldv_func_arg1 ) ;
#line 53
static void ldv___ldv_spin_lock_47___0(spinlock_t *ldv_func_arg1 ) ;
#line 57
static void ldv___ldv_spin_lock_49___1(spinlock_t *ldv_func_arg1 ) ;
#line 61
static void ldv___ldv_spin_lock_51___1(spinlock_t *ldv_func_arg1 ) ;
#line 65
static void ldv___ldv_spin_lock_53___0(spinlock_t *ldv_func_arg1 ) ;
#line 69
static void ldv___ldv_spin_lock_55___0(spinlock_t *ldv_func_arg1 ) ;
#line 73
static void ldv___ldv_spin_lock_57___0(spinlock_t *ldv_func_arg1 ) ;
#line 77
static void ldv___ldv_spin_lock_59___0(spinlock_t *ldv_func_arg1 ) ;
#line 81
static void ldv___ldv_spin_lock_61___0(spinlock_t *ldv_func_arg1 ) ;
#line 85
static void ldv___ldv_spin_lock_63___0(spinlock_t *ldv_func_arg1 ) ;
#line 390 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 398
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 402
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 406
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 410
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 414
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 418
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 422
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 426
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 430
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 434
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 438
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 442
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 446
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 450
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 314 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/core.h"
extern int snd_device_free(struct snd_card * , void * ) ;
#line 117 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
extern int snd_ctl_remove_id(struct snd_card * , struct snd_ctl_elem_id * ) ;
#line 122
extern struct snd_kcontrol *snd_ctl_find_id(struct snd_card * , struct snd_ctl_elem_id * ) ;
#line 141 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
__inline static unsigned int snd_ctl_get_ioffidx(struct snd_kcontrol *kctl , struct snd_ctl_elem_id *id___0 ) 
{ 


  {
#line 143
  return (id___0->index - kctl->id.index);
}
}
#line 168
extern int snd_ctl_boolean_mono_info(struct snd_kcontrol * , struct snd_ctl_elem_info * ) ;
#line 559 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/ac97_codec.h"
extern int snd_ac97_bus(struct snd_card * , int  , struct snd_ac97_bus_ops * , void * ,
                        struct snd_ac97_bus ** ) ;
#line 562
extern int snd_ac97_mixer(struct snd_ac97_bus * , struct snd_ac97_template * , struct snd_ac97 ** ) ;
#line 567
extern unsigned short snd_ac97_read(struct snd_ac97 * , unsigned short  ) ;
#line 568
extern void snd_ac97_write_cache(struct snd_ac97 * , unsigned short  , unsigned short  ) ;
#line 569
extern int snd_ac97_update(struct snd_ac97 * , unsigned short  , unsigned short  ) ;
#line 1817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/emu10k1.h"
int snd_p16v_mixer(struct snd_emu10k1 *emu ) ;
#line 44 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static unsigned int const   snd_audigy_db_scale2[4U]  = {      1U,      8U,      4294956946U,      65586U};
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_spdif_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
#line 48
  uinfo->type = 5;
#line 49
  uinfo->count = 1U;
#line 50
  return (0);
}
}
#line 53 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_spdif_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int idx ;
  unsigned int tmp ;
  unsigned long flags ;

  {
  {
#line 56
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 57
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 57
  idx = tmp;
  }
#line 61
  if (idx > 2U) {
#line 62
    return (-22);
  } else {

  }
  {
#line 63
  ldv___ldv_spin_lock_33___6(& emu->reg_lock);
#line 64
  ucontrol->value.iec958.status[0] = (unsigned char )emu->spdif_bits[idx];
#line 65
  ucontrol->value.iec958.status[1] = (unsigned char )(emu->spdif_bits[idx] >> 8);
#line 66
  ucontrol->value.iec958.status[2] = (unsigned char )(emu->spdif_bits[idx] >> 16);
#line 67
  ucontrol->value.iec958.status[3] = (unsigned char )(emu->spdif_bits[idx] >> 24);
#line 68
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 69
  return (0);
}
}
#line 72 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_spdif_get_mask(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 


  {
#line 75
  ucontrol->value.iec958.status[0] = 255U;
#line 76
  ucontrol->value.iec958.status[1] = 255U;
#line 77
  ucontrol->value.iec958.status[2] = 255U;
#line 78
  ucontrol->value.iec958.status[3] = 255U;
#line 79
  return (0);
}
}
#line 86 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static char *emu1010_src_texts[53U]  = 
#line 86
  {      (char *)"Silence",      (char *)"Dock Mic A",      (char *)"Dock Mic B",      (char *)"Dock ADC1 Left", 
        (char *)"Dock ADC1 Right",      (char *)"Dock ADC2 Left",      (char *)"Dock ADC2 Right",      (char *)"Dock ADC3 Left", 
        (char *)"Dock ADC3 Right",      (char *)"0202 ADC Left",      (char *)"0202 ADC Right",      (char *)"0202 SPDIF Left", 
        (char *)"0202 SPDIF Right",      (char *)"ADAT 0",      (char *)"ADAT 1",      (char *)"ADAT 2", 
        (char *)"ADAT 3",      (char *)"ADAT 4",      (char *)"ADAT 5",      (char *)"ADAT 6", 
        (char *)"ADAT 7",      (char *)"DSP 0",      (char *)"DSP 1",      (char *)"DSP 2", 
        (char *)"DSP 3",      (char *)"DSP 4",      (char *)"DSP 5",      (char *)"DSP 6", 
        (char *)"DSP 7",      (char *)"DSP 8",      (char *)"DSP 9",      (char *)"DSP 10", 
        (char *)"DSP 11",      (char *)"DSP 12",      (char *)"DSP 13",      (char *)"DSP 14", 
        (char *)"DSP 15",      (char *)"DSP 16",      (char *)"DSP 17",      (char *)"DSP 18", 
        (char *)"DSP 19",      (char *)"DSP 20",      (char *)"DSP 21",      (char *)"DSP 22", 
        (char *)"DSP 23",      (char *)"DSP 24",      (char *)"DSP 25",      (char *)"DSP 26", 
        (char *)"DSP 27",      (char *)"DSP 28",      (char *)"DSP 29",      (char *)"DSP 30", 
        (char *)"DSP 31"};
#line 144 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static char *emu1616_src_texts[49U]  = 
#line 144
  {      (char *)"Silence",      (char *)"Dock Mic A",      (char *)"Dock Mic B",      (char *)"Dock ADC1 Left", 
        (char *)"Dock ADC1 Right",      (char *)"Dock ADC2 Left",      (char *)"Dock ADC2 Right",      (char *)"Dock SPDIF Left", 
        (char *)"Dock SPDIF Right",      (char *)"ADAT 0",      (char *)"ADAT 1",      (char *)"ADAT 2", 
        (char *)"ADAT 3",      (char *)"ADAT 4",      (char *)"ADAT 5",      (char *)"ADAT 6", 
        (char *)"ADAT 7",      (char *)"DSP 0",      (char *)"DSP 1",      (char *)"DSP 2", 
        (char *)"DSP 3",      (char *)"DSP 4",      (char *)"DSP 5",      (char *)"DSP 6", 
        (char *)"DSP 7",      (char *)"DSP 8",      (char *)"DSP 9",      (char *)"DSP 10", 
        (char *)"DSP 11",      (char *)"DSP 12",      (char *)"DSP 13",      (char *)"DSP 14", 
        (char *)"DSP 15",      (char *)"DSP 16",      (char *)"DSP 17",      (char *)"DSP 18", 
        (char *)"DSP 19",      (char *)"DSP 20",      (char *)"DSP 21",      (char *)"DSP 22", 
        (char *)"DSP 23",      (char *)"DSP 24",      (char *)"DSP 25",      (char *)"DSP 26", 
        (char *)"DSP 27",      (char *)"DSP 28",      (char *)"DSP 29",      (char *)"DSP 30", 
        (char *)"DSP 31"};
#line 200 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static unsigned int emu1010_src_regs[53U]  = 
#line 200
  {      0U,      256U,      260U,      264U, 
        268U,      272U,      276U,      280U, 
        284U,      512U,      513U,      1280U, 
        1281U,      1024U,      1025U,      1026U, 
        1027U,      1028U,      1029U,      1030U, 
        1031U,      768U,      769U,      770U, 
        771U,      772U,      773U,      774U, 
        775U,      776U,      777U,      778U, 
        779U,      780U,      781U,      782U, 
        783U,      784U,      785U,      786U, 
        787U,      788U,      789U,      790U, 
        791U,      792U,      793U,      794U, 
        795U,      796U,      797U,      798U, 
        799U};
#line 257 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static unsigned int emu1616_src_regs[49U]  = 
#line 257
  {      0U,      256U,      260U,      264U, 
        268U,      272U,      276U,      274U, 
        278U,      280U,      281U,      282U, 
        283U,      284U,      285U,      286U, 
        287U,      768U,      769U,      770U, 
        771U,      772U,      773U,      774U, 
        775U,      776U,      777U,      778U, 
        779U,      780U,      781U,      782U, 
        783U,      784U,      785U,      786U, 
        787U,      788U,      789U,      790U, 
        791U,      792U,      793U,      794U, 
        795U,      796U,      797U,      798U, 
        799U};
#line 313 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static unsigned int emu1010_output_dst[24U]  = 
#line 313
  {      256U,      260U,      264U,      268U, 
        272U,      276U,      280U,      284U, 
        274U,      278U,      282U,      286U, 
        512U,      513U,      768U,      769U, 
        1024U,      1025U,      1026U,      1027U, 
        1028U,      1029U,      1030U,      1031U};
#line 341 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static unsigned int emu1616_output_dst[18U]  = 
#line 341
  {      256U,      260U,      264U,      268U, 
        272U,      276U,      274U,      278U, 
        280U,      281U,      282U,      283U, 
        284U,      285U,      286U,      287U, 
        768U,      769U};
#line 367 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static unsigned int emu1010_input_dst[22U]  = 
#line 367
  {      15U,      0U,      1U,      2U, 
        3U,      4U,      5U,      6U, 
        7U,      8U,      9U,      10U, 
        11U,      12U,      13U,      14U, 
        1280U,      1281U,      1536U,      1537U, 
        1792U,      1793U};
#line 392 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_input_output_source_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1 *emu ;
  char **items ;

  {
#line 395
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 398
  uinfo->type = 3;
#line 399
  uinfo->count = 1U;
#line 400
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U) {
#line 401
    uinfo->value.enumerated.items = 49U;
#line 402
    items = (char **)(& emu1616_src_texts);
  } else {
#line 404
    uinfo->value.enumerated.items = 53U;
#line 405
    items = (char **)(& emu1010_src_texts);
  }
#line 407
  if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items) {
#line 408
    uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1U;
  } else {

  }
  {
#line 410
  strcpy((char *)(& uinfo->value.enumerated.name), (char const   *)*(items + (unsigned long )uinfo->value.enumerated.item));
  }
#line 412
  return (0);
}
}
#line 415 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_output_source_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int channel ;

  {
#line 418
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 421
  channel = (unsigned int )kcontrol->private_value & 255U;
#line 423
  if (channel > 23U || ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U && channel > 17U)) {
#line 426
    return (-22);
  } else {

  }
#line 427
  ucontrol->value.enumerated.item[0] = emu->emu1010.output_source[channel];
#line 428
  return (0);
}
}
#line 431 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_output_source_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  unsigned int channel ;

  {
#line 434
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 438
  val = ucontrol->value.enumerated.item[0];
#line 439
  if (val > 52U || ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U && val > 48U)) {
#line 442
    return (-22);
  } else {

  }
#line 443
  channel = (unsigned int )kcontrol->private_value & 255U;
#line 445
  if (channel > 23U || ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U && channel > 17U)) {
#line 448
    return (-22);
  } else {

  }
#line 449
  if (emu->emu1010.output_source[channel] == val) {
#line 450
    return (0);
  } else {

  }
#line 451
  emu->emu1010.output_source[channel] = val;
#line 452
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U) {
    {
#line 453
    snd_emu1010_fpga_link_dst_src_write(emu, emu1616_output_dst[channel], emu1616_src_regs[val]);
    }
  } else {
    {
#line 456
    snd_emu1010_fpga_link_dst_src_write(emu, emu1010_output_dst[channel], emu1010_src_regs[val]);
    }
  }
#line 458
  return (1);
}
}
#line 461 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_input_source_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int channel ;

  {
#line 464
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 467
  channel = (unsigned int )kcontrol->private_value & 255U;
#line 469
  if (channel > 21U) {
#line 470
    return (-22);
  } else {

  }
#line 471
  ucontrol->value.enumerated.item[0] = emu->emu1010.input_source[channel];
#line 472
  return (0);
}
}
#line 475 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_input_source_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  unsigned int channel ;

  {
#line 478
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 482
  val = ucontrol->value.enumerated.item[0];
#line 483
  if (val > 52U || ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U && val > 48U)) {
#line 486
    return (-22);
  } else {

  }
#line 487
  channel = (unsigned int )kcontrol->private_value & 255U;
#line 489
  if (channel > 21U) {
#line 490
    return (-22);
  } else {

  }
#line 491
  if (emu->emu1010.input_source[channel] == val) {
#line 492
    return (0);
  } else {

  }
#line 493
  emu->emu1010.input_source[channel] = val;
#line 494
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U) {
    {
#line 495
    snd_emu1010_fpga_link_dst_src_write(emu, emu1010_input_dst[channel], emu1616_src_regs[val]);
    }
  } else {
    {
#line 498
    snd_emu1010_fpga_link_dst_src_write(emu, emu1010_input_dst[channel], emu1010_src_regs[val]);
    }
  }
#line 500
  return (1);
}
}
#line 513 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu1010_output_enum_ctls[24U]  = 
#line 513
  {      {2, 0U, 0U, (unsigned char *)"Dock DAC1 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 0UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC1 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 1UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC2 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 2UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC2 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 3UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC3 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 4UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC3 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 5UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC4 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 6UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC4 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 7UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock Phones Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 8UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock Phones Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 9UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock SPDIF Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 10UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock SPDIF Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 11UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 SPDIF Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 12UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 SPDIF Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 13UL}, 
        {2,
      0U, 0U, (unsigned char *)"0202 DAC Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 14UL}, 
        {2,
      0U, 0U, (unsigned char *)"0202 DAC Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 15UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 0 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 16UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 1 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 17UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 2 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 18UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 3 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 19UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 4 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 20UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 5 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 21UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 6 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 22UL}, 
        {2,
      0U, 0U, (unsigned char *)"1010 ADAT 7 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 23UL}};
#line 542 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu1616_output_enum_ctls[18U]  = 
#line 542
  {      {2, 0U, 0U, (unsigned char *)"Dock DAC1 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 0UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC1 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 1UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC2 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 2UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC2 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 3UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC3 Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 4UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock DAC3 Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 5UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock SPDIF Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 6UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock SPDIF Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 7UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 0 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 8UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 1 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 9UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 2 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 10UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 3 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 11UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 4 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 12UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 5 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 13UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 6 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 14UL}, 
        {2,
      0U, 0U, (unsigned char *)"Dock ADAT 7 Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 15UL}, 
        {2,
      0U, 0U, (unsigned char *)"Mana DAC Left Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 16UL}, 
        {2,
      0U, 0U, (unsigned char *)"Mana DAC Right Playback Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_output_source_get, & snd_emu1010_output_source_put, {0}, 17UL}};
#line 574 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu1010_input_enum_ctls[22U]  = 
#line 574
  {      {2, 0U, 0U, (unsigned char *)"DSP 0 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 0UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 1 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 1UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 2 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 2UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 3 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 3UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 4 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 4UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 5 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 5UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 6 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 6UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 7 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 7UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 8 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 8UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 9 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 9UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP A Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 10UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP B Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 11UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP C Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 12UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP D Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 13UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP E Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 14UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP F Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 15UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 10 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 16UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 11 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 17UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 12 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 18UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 13 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 19UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 14 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 20UL}, 
        {2, 0U, 0U, (unsigned char *)"DSP 15 Capture Enum", 0U, 3U, 0U, & snd_emu1010_input_output_source_info,
      & snd_emu1010_input_source_get, & snd_emu1010_input_source_put, {0}, 21UL}};
#line 603 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_adc_pads_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int mask ;

  {
#line 605
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 606
  mask = (unsigned int )kcontrol->private_value & 255U;
#line 607
  ucontrol->value.integer.value[0] = (emu->emu1010.adc_pads & mask) != 0U;
#line 608
  return (0);
}
}
#line 611 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_adc_pads_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int mask ;
  unsigned int val ;
  unsigned int cache ;

  {
#line 613
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 614
  mask = (unsigned int )kcontrol->private_value & 255U;
#line 616
  val = (unsigned int )ucontrol->value.integer.value[0];
#line 617
  cache = emu->emu1010.adc_pads;
#line 618
  if (val == 1U) {
#line 619
    cache = cache | mask;
  } else {
#line 621
    cache = cache & ~ mask;
  }
#line 622
  if (cache != emu->emu1010.adc_pads) {
    {
#line 623
    snd_emu1010_fpga_write(emu, 16U, cache);
#line 624
    emu->emu1010.adc_pads = cache;
    }
  } else {

  }
#line 627
  return (0);
}
}
#line 642 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu1010_adc_pads[4U]  = {      {2, 0U, 0U, (unsigned char *)"ADC1 14dB PAD Audio Dock Capture Switch", 0U, 3U,
      0U, & snd_ctl_boolean_mono_info, & snd_emu1010_adc_pads_get, & snd_emu1010_adc_pads_put,
      {0}, 1UL}, 
        {2, 0U, 0U, (unsigned char *)"ADC2 14dB PAD Audio Dock Capture Switch", 0U, 3U,
      0U, & snd_ctl_boolean_mono_info, & snd_emu1010_adc_pads_get, & snd_emu1010_adc_pads_put,
      {0}, 2UL}, 
        {2, 0U, 0U, (unsigned char *)"ADC3 14dB PAD Audio Dock Capture Switch", 0U, 3U,
      0U, & snd_ctl_boolean_mono_info, & snd_emu1010_adc_pads_get, & snd_emu1010_adc_pads_put,
      {0}, 4UL}, 
        {2, 0U, 0U, (unsigned char *)"ADC1 14dB PAD 0202 Capture Switch", 0U, 3U, 0U,
      & snd_ctl_boolean_mono_info, & snd_emu1010_adc_pads_get, & snd_emu1010_adc_pads_put,
      {0}, 8UL}};
#line 651 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_dac_pads_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int mask ;

  {
#line 653
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 654
  mask = (unsigned int )kcontrol->private_value & 255U;
#line 655
  ucontrol->value.integer.value[0] = (emu->emu1010.dac_pads & mask) != 0U;
#line 656
  return (0);
}
}
#line 659 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_dac_pads_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int mask ;
  unsigned int val ;
  unsigned int cache ;

  {
#line 661
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 662
  mask = (unsigned int )kcontrol->private_value & 255U;
#line 664
  val = (unsigned int )ucontrol->value.integer.value[0];
#line 665
  cache = emu->emu1010.dac_pads;
#line 666
  if (val == 1U) {
#line 667
    cache = cache | mask;
  } else {
#line 669
    cache = cache & ~ mask;
  }
#line 670
  if (cache != emu->emu1010.dac_pads) {
    {
#line 671
    snd_emu1010_fpga_write(emu, 19U, cache);
#line 672
    emu->emu1010.dac_pads = cache;
    }
  } else {

  }
#line 675
  return (0);
}
}
#line 690 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu1010_dac_pads[5U]  = {      {2, 0U, 0U, (unsigned char *)"DAC1 Audio Dock 14dB PAD Playback Switch", 0U,
      3U, 0U, & snd_ctl_boolean_mono_info, & snd_emu1010_dac_pads_get, & snd_emu1010_dac_pads_put,
      {0}, 1UL}, 
        {2, 0U, 0U, (unsigned char *)"DAC2 Audio Dock 14dB PAD Playback Switch", 0U,
      3U, 0U, & snd_ctl_boolean_mono_info, & snd_emu1010_dac_pads_get, & snd_emu1010_dac_pads_put,
      {0}, 2UL}, 
        {2, 0U, 0U, (unsigned char *)"DAC3 Audio Dock 14dB PAD Playback Switch", 0U,
      3U, 0U, & snd_ctl_boolean_mono_info, & snd_emu1010_dac_pads_get, & snd_emu1010_dac_pads_put,
      {0}, 4UL}, 
        {2, 0U, 0U, (unsigned char *)"DAC4 Audio Dock 14dB PAD Playback Switch", 0U,
      3U, 0U, & snd_ctl_boolean_mono_info, & snd_emu1010_dac_pads_get, & snd_emu1010_dac_pads_put,
      {0}, 8UL}, 
        {2, 0U, 0U, (unsigned char *)"DAC1 0202 14dB PAD Playback Switch", 0U, 3U, 0U,
      & snd_ctl_boolean_mono_info, & snd_emu1010_dac_pads_get, & snd_emu1010_dac_pads_put,
      {0}, 16UL}};
#line 699 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_internal_clock_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  char *texts[4U] ;

  {
#line 702
  texts[0] = (char *)"44100";
#line 702
  texts[1] = (char *)"48000";
#line 702
  texts[2] = (char *)"SPDIF";
#line 702
  texts[3] = (char *)"ADAT";
#line 706
  uinfo->type = 3;
#line 707
  uinfo->count = 1U;
#line 708
  uinfo->value.enumerated.items = 4U;
#line 709
  if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items) {
#line 710
    uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1U;
  } else {

  }
  {
#line 711
  strcpy((char *)(& uinfo->value.enumerated.name), (char const   *)texts[uinfo->value.enumerated.item]);
  }
#line 712
  return (0);
}
}
#line 717 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_internal_clock_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 720
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 722
  ucontrol->value.enumerated.item[0] = emu->emu1010.internal_clock;
#line 723
  return (0);
}
}
#line 726 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu1010_internal_clock_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  int change ;

  {
#line 729
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 731
  change = 0;
#line 733
  val = ucontrol->value.enumerated.item[0];
#line 735
  if (val > 3U) {
#line 736
    return (-22);
  } else {

  }
#line 737
  change = emu->emu1010.internal_clock != val;
#line 738
  if (change != 0) {
#line 739
    emu->emu1010.internal_clock = val;
    {
#line 741
    if (val == 0U) {
#line 741
      goto case_0;
    } else {

    }
#line 758
    if (val == 1U) {
#line 758
      goto case_1;
    } else {

    }
#line 776
    if (val == 2U) {
#line 776
      goto case_2;
    } else {

    }
#line 794
    if (val == 3U) {
#line 794
      goto case_3;
    } else {

    }
#line 740
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 744
    snd_emu1010_fpga_write(emu, 7U, 0U);
#line 746
    snd_emu1010_fpga_write(emu, 6U, 1U);
#line 748
    snd_emu1010_fpga_write(emu, 5U, 1U);
#line 751
    snd_emu1010_fpga_write(emu, 14U, 17U);
#line 754
    msleep(10U);
#line 756
    snd_emu1010_fpga_write(emu, 7U, 1U);
    }
#line 757
    goto ldv_30523;
    case_1: /* CIL Label */ 
    {
#line 761
    snd_emu1010_fpga_write(emu, 7U, 0U);
#line 763
    snd_emu1010_fpga_write(emu, 6U, 0U);
#line 765
    snd_emu1010_fpga_write(emu, 5U, 0U);
#line 768
    snd_emu1010_fpga_write(emu, 14U, 18U);
#line 771
    msleep(10U);
#line 773
    snd_emu1010_fpga_write(emu, 7U, 1U);
    }
#line 774
    goto ldv_30523;
    case_2: /* CIL Label */ 
    {
#line 778
    snd_emu1010_fpga_write(emu, 7U, 0U);
#line 780
    snd_emu1010_fpga_write(emu, 6U, 0U);
#line 782
    snd_emu1010_fpga_write(emu, 5U, 2U);
#line 785
    snd_emu1010_fpga_write(emu, 14U, 48U);
#line 789
    msleep(10U);
#line 791
    snd_emu1010_fpga_write(emu, 7U, 1U);
    }
#line 792
    goto ldv_30523;
    case_3: /* CIL Label */ 
    {
#line 797
    snd_emu1010_fpga_write(emu, 7U, 0U);
#line 799
    snd_emu1010_fpga_write(emu, 6U, 0U);
#line 801
    snd_emu1010_fpga_write(emu, 5U, 3U);
#line 804
    snd_emu1010_fpga_write(emu, 14U, 48U);
#line 807
    msleep(10U);
#line 809
    snd_emu1010_fpga_write(emu, 7U, 1U);
    }
#line 812
    goto ldv_30523;
    switch_break: /* CIL Label */ ;
    }
    ldv_30523: ;
  } else {

  }
#line 815
  return (change);
}
}
#line 818 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu1010_internal_clock  = 
#line 818
     {2, 0U, 0U, (unsigned char *)"Clock Internal Rate", 0U, 3U, 1U, & snd_emu1010_internal_clock_info,
    & snd_emu1010_internal_clock_get, & snd_emu1010_internal_clock_put, {0}, 0UL};
#line 829 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_i2c_capture_source_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  char *texts[2U] ;

  {
#line 837
  texts[0] = (char *)"Mic";
#line 837
  texts[1] = (char *)"Line";
#line 841
  uinfo->type = 3;
#line 842
  uinfo->count = 1U;
#line 843
  uinfo->value.enumerated.items = 2U;
#line 844
  if (uinfo->value.enumerated.item > 1U) {
#line 845
    uinfo->value.enumerated.item = 1U;
  } else {

  }
  {
#line 846
  strcpy((char *)(& uinfo->value.enumerated.name), (char const   *)texts[uinfo->value.enumerated.item]);
  }
#line 847
  return (0);
}
}
#line 850 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_i2c_capture_source_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 853
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 855
  ucontrol->value.enumerated.item[0] = emu->i2c_capture_source;
#line 856
  return (0);
}
}
#line 859 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_i2c_capture_source_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int source_id ;
  unsigned int ngain ;
  unsigned int ogain ;
  u32 gpio ;
  int change ;
  unsigned long flags ;
  u32 source ;

  {
#line 862
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 866
  change = 0;
#line 873
  source_id = ucontrol->value.enumerated.item[0];
#line 876
  if (source_id > 1U) {
#line 877
    return (-22);
  } else {

  }
#line 878
  change = emu->i2c_capture_source != source_id;
#line 879
  if (change != 0) {
    {
#line 880
    snd_emu10k1_i2c_write(emu, 21U, 0U);
#line 881
    ldv___ldv_spin_lock_35___3(& emu->emu_lock);
#line 882
    gpio = inl((int )((unsigned int )emu->port + 24U));
    }
#line 883
    if (source_id == 0U) {
      {
#line 884
      outl(gpio | 4U, (int )((unsigned int )emu->port + 24U));
      }
    } else {
      {
#line 886
      outl(gpio & 4294967291U, (int )((unsigned int )emu->port + 24U));
      }
    }
    {
#line 887
    ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
#line 889
    ngain = (unsigned int )emu->i2c_capture_volume[source_id][0];
#line 890
    ogain = (unsigned int )emu->i2c_capture_volume[emu->i2c_capture_source][0];
    }
#line 891
    if (ngain != ogain) {
      {
#line 892
      snd_emu10k1_i2c_write(emu, 14U, ngain & 255U);
      }
    } else {

    }
#line 893
    ngain = (unsigned int )emu->i2c_capture_volume[source_id][1];
#line 894
    ogain = (unsigned int )emu->i2c_capture_volume[emu->i2c_capture_source][1];
#line 895
    if (ngain != ogain) {
      {
#line 896
      snd_emu10k1_i2c_write(emu, 15U, ngain & 255U);
      }
    } else {

    }
    {
#line 898
    source = (u32 )(1 << (int )(source_id + 2U));
#line 899
    snd_emu10k1_i2c_write(emu, 21U, source);
#line 900
    emu->i2c_capture_source = source_id;
    }
  } else {

  }
#line 902
  return (change);
}
}
#line 905 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_audigy_i2c_capture_source  = 
#line 905
     {2, 0U, 0U, (unsigned char *)"Capture Source", 0U, 0U, 0U, & snd_audigy_i2c_capture_source_info,
    & snd_audigy_i2c_capture_source_get, & snd_audigy_i2c_capture_source_put, {0},
    0UL};
#line 914 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_i2c_volume_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
#line 917
  uinfo->type = 2;
#line 918
  uinfo->count = 2U;
#line 919
  uinfo->value.integer.min = 0L;
#line 920
  uinfo->value.integer.max = 255L;
#line 921
  return (0);
}
}
#line 924 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_i2c_volume_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int source_id ;

  {
#line 927
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 930
  source_id = (unsigned int )kcontrol->private_value;
#line 933
  if (source_id > 1U) {
#line 934
    return (-22);
  } else {

  }
#line 936
  ucontrol->value.integer.value[0] = (long )emu->i2c_capture_volume[source_id][0];
#line 937
  ucontrol->value.integer.value[1] = (long )emu->i2c_capture_volume[source_id][1];
#line 938
  return (0);
}
}
#line 941 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_i2c_volume_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int ogain ;
  unsigned int ngain ;
  unsigned int source_id ;
  int change ;

  {
#line 944
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 948
  change = 0;
#line 950
  source_id = (unsigned int )kcontrol->private_value;
#line 953
  if (source_id > 1U) {
#line 954
    return (-22);
  } else {

  }
#line 955
  ogain = (unsigned int )emu->i2c_capture_volume[source_id][0];
#line 956
  ngain = (unsigned int )ucontrol->value.integer.value[0];
#line 957
  if (ngain > 255U) {
#line 958
    return (0);
  } else {

  }
#line 959
  if (ogain != ngain) {
#line 960
    if (emu->i2c_capture_source == source_id) {
      {
#line 961
      snd_emu10k1_i2c_write(emu, 14U, ngain & 255U);
      }
    } else {

    }
#line 962
    emu->i2c_capture_volume[source_id][0] = (u8 )ngain;
#line 963
    change = 1;
  } else {

  }
#line 965
  ogain = (unsigned int )emu->i2c_capture_volume[source_id][1];
#line 966
  ngain = (unsigned int )ucontrol->value.integer.value[1];
#line 967
  if (ngain > 255U) {
#line 968
    return (0);
  } else {

  }
#line 969
  if (ogain != ngain) {
#line 970
    if (emu->i2c_capture_source == source_id) {
      {
#line 971
      snd_emu10k1_i2c_write(emu, 15U, ngain & 255U);
      }
    } else {

    }
#line 972
    emu->i2c_capture_volume[source_id][1] = (u8 )ngain;
#line 973
    change = 1;
  } else {

  }
#line 976
  return (change);
}
}
#line 992 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_audigy_i2c_volume_ctls[2U]  = {      {2, 0U, 0U, (unsigned char *)"Mic Capture Volume", 0U, 19U, 0U, & snd_audigy_i2c_volume_info,
      & snd_audigy_i2c_volume_get, & snd_audigy_i2c_volume_put, {.p = (unsigned int const   *)(& snd_audigy_db_scale2)},
      0UL}, 
        {2, 0U, 0U, (unsigned char *)"Line Capture Volume", 0U, 19U, 0U, & snd_audigy_i2c_volume_info,
      & snd_audigy_i2c_volume_get, & snd_audigy_i2c_volume_put, {.p = (unsigned int const   *)(& snd_audigy_db_scale2)},
      0UL}};
#line 1084 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_spdif_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int idx ;
  unsigned int tmp ;
  int change ;
  unsigned int val ;
  unsigned long flags ;

  {
  {
#line 1087
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1088
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1088
  idx = tmp;
  }
#line 1094
  if (idx > 2U) {
#line 1095
    return (-22);
  } else {

  }
  {
#line 1096
  val = (unsigned int )((((int )ucontrol->value.iec958.status[0] | ((int )ucontrol->value.iec958.status[1] << 8)) | ((int )ucontrol->value.iec958.status[2] << 16)) | ((int )ucontrol->value.iec958.status[3] << 24));
#line 1100
  ldv___ldv_spin_lock_37___2(& emu->reg_lock);
#line 1101
  change = val != emu->spdif_bits[idx];
  }
#line 1102
  if (change != 0) {
    {
#line 1103
    snd_emu10k1_ptr_write(emu, idx + 84U, 0U, val);
#line 1104
    emu->spdif_bits[idx] = val;
    }
  } else {

  }
  {
#line 1106
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1107
  return (change);
}
}
#line 1110 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_spdif_mask_control  = 
#line 1110
     {3, 0U, 0U, (unsigned char *)"IEC958 Playback Mask", 0U, 1U, 3U, & snd_emu10k1_spdif_info,
    & snd_emu10k1_spdif_get_mask, 0, {0}, 0UL};
#line 1120 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_spdif_control  = 
#line 1120
     {3, 0U, 0U, (unsigned char *)"IEC958 Playback Default", 0U, 0U, 3U, & snd_emu10k1_spdif_info,
    & snd_emu10k1_spdif_get, & snd_emu10k1_spdif_put, {0}, 0UL};
#line 1131 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static void update_emu10k1_fxrt(struct snd_emu10k1 *emu , int voice , unsigned char *route ) 
{ 


  {
#line 1133
  if (emu->audigy != 0U) {
    {
#line 1134
    snd_emu10k1_ptr_write(emu, 126U, (unsigned int )voice, (((unsigned int )*route | ((unsigned int )*(route + 1UL) << 8)) | ((unsigned int )*(route + 2UL) << 16)) | ((unsigned int )*(route + 3UL) << 24));
#line 1136
    snd_emu10k1_ptr_write(emu, 124U, (unsigned int )voice, (((unsigned int )*(route + 4UL) | ((unsigned int )*(route + 5UL) << 8)) | ((unsigned int )*(route + 6UL) << 16)) | ((unsigned int )*(route + 7UL) << 24));
    }
  } else {
    {
#line 1139
    snd_emu10k1_ptr_write(emu, 11U, (unsigned int )voice, (unsigned int )(((((int )*route | ((int )*(route + 1UL) << 4)) | ((int )*(route + 2UL) << 8)) | ((int )*(route + 3UL) << 12)) << 16));
    }
  }
#line 1141
  return;
}
}
#line 1144 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static void update_emu10k1_send_volume(struct snd_emu10k1 *emu , int voice , unsigned char *volume ) 
{ 
  unsigned int val ;

  {
  {
#line 1146
  snd_emu10k1_ptr_write(emu, 134742017U, (unsigned int )voice, (unsigned int )*volume);
#line 1147
  snd_emu10k1_ptr_write(emu, 134217729U, (unsigned int )voice, (unsigned int )*(volume + 1UL));
#line 1148
  snd_emu10k1_ptr_write(emu, 135790598U, (unsigned int )voice, (unsigned int )*(volume + 2UL));
#line 1149
  snd_emu10k1_ptr_write(emu, 135790599U, (unsigned int )voice, (unsigned int )*(volume + 3UL));
  }
#line 1150
  if (emu->audigy != 0U) {
    {
#line 1151
    val = ((((unsigned int )*(volume + 4UL) << 24) | ((unsigned int )*(volume + 5UL) << 16)) | ((unsigned int )*(volume + 6UL) << 8)) | (unsigned int )*(volume + 7UL);
#line 1155
    snd_emu10k1_ptr_write(emu, 125U, (unsigned int )voice, val);
    }
  } else {

  }
#line 1157
  return;
}
}
#line 1161 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_send_routing_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1163
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1164
  uinfo->type = 2;
#line 1165
  uinfo->count = emu->audigy != 0U ? 24U : 12U;
#line 1166
  uinfo->value.integer.min = 0L;
#line 1167
  uinfo->value.integer.max = emu->audigy != 0U ? 63L : 15L;
#line 1168
  return (0);
}
}
#line 1171 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_send_routing_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int voice ;
  int idx ;
  int num_efx ;
  int mask ;

  {
  {
#line 1175
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1176
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1176
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )tmp;
#line 1179
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1180
  mask = emu->audigy != 0U ? 63 : 15;
#line 1182
  ldv___ldv_spin_lock_39___2(& emu->reg_lock);
#line 1183
  voice = 0;
  }
#line 1183
  goto ldv_30613;
  ldv_30612: 
#line 1184
  idx = 0;
#line 1184
  goto ldv_30610;
  ldv_30609: 
#line 1185
  ucontrol->value.integer.value[voice * num_efx + idx] = (long )((int )mix->send_routing[voice][idx] & mask);
#line 1184
  idx = idx + 1;
  ldv_30610: ;
#line 1184
  if (idx < num_efx) {
#line 1186
    goto ldv_30609;
  } else {

  }
#line 1183
  voice = voice + 1;
  ldv_30613: ;
#line 1183
  if (voice <= 2) {
#line 1185
    goto ldv_30612;
  } else {

  }
  {
#line 1187
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1188
  return (0);
}
}
#line 1191 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_send_routing_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int change ;
  int voice ;
  int idx ;
  int val ;
  int num_efx ;
  int mask ;

  {
  {
#line 1195
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1196
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1196
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )tmp;
#line 1198
  change = 0;
#line 1199
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1200
  mask = emu->audigy != 0U ? 63 : 15;
#line 1202
  ldv___ldv_spin_lock_41___1(& emu->reg_lock);
#line 1203
  voice = 0;
  }
#line 1203
  goto ldv_30632;
  ldv_30631: 
#line 1204
  idx = 0;
#line 1204
  goto ldv_30629;
  ldv_30628: 
#line 1205
  val = (int )ucontrol->value.integer.value[voice * num_efx + idx] & mask;
#line 1206
  if ((int )mix->send_routing[voice][idx] != val) {
#line 1207
    mix->send_routing[voice][idx] = (unsigned char )val;
#line 1208
    change = 1;
  } else {

  }
#line 1204
  idx = idx + 1;
  ldv_30629: ;
#line 1204
  if (idx < num_efx) {
#line 1206
    goto ldv_30628;
  } else {

  }
#line 1203
  voice = voice + 1;
  ldv_30632: ;
#line 1203
  if (voice <= 2) {
#line 1205
    goto ldv_30631;
  } else {

  }

#line 1211
  if (change != 0 && (unsigned long )mix->epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1212
    if ((unsigned long )(mix->epcm)->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0) && (unsigned long )(mix->epcm)->voices[1] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1213
      update_emu10k1_fxrt(emu, ((mix->epcm)->voices[0])->number, (unsigned char *)((unsigned char (*)[8])(& mix->send_routing) + 1UL));
#line 1215
      update_emu10k1_fxrt(emu, ((mix->epcm)->voices[1])->number, (unsigned char *)((unsigned char (*)[8])(& mix->send_routing) + 2UL));
      }
    } else
#line 1217
    if ((unsigned long )(mix->epcm)->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1218
      update_emu10k1_fxrt(emu, ((mix->epcm)->voices[0])->number, (unsigned char *)(& mix->send_routing));
      }
    } else {

    }
  } else {

  }
  {
#line 1222
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1223
  return (change);
}
}
#line 1226 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_send_routing_control  = 
#line 1226
     {3, 0U, 0U, (unsigned char *)"EMU10K1 PCM Send Routing", 0U, 259U, 32U, & snd_emu10k1_send_routing_info,
    & snd_emu10k1_send_routing_get, & snd_emu10k1_send_routing_put, {0}, 0UL};
#line 1237 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_send_volume_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1239
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1240
  uinfo->type = 2;
#line 1241
  uinfo->count = emu->audigy != 0U ? 24U : 12U;
#line 1242
  uinfo->value.integer.min = 0L;
#line 1243
  uinfo->value.integer.max = 255L;
#line 1244
  return (0);
}
}
#line 1247 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_send_volume_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int idx ;
  int num_efx ;

  {
  {
#line 1251
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1252
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1252
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )tmp;
#line 1255
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1257
  ldv___ldv_spin_lock_43___1(& emu->reg_lock);
#line 1258
  idx = 0;
  }
#line 1258
  goto ldv_30650;
  ldv_30649: 
#line 1259
  ucontrol->value.integer.value[idx] = (long )mix->send_volume[idx / num_efx][idx % num_efx];
#line 1258
  idx = idx + 1;
  ldv_30650: ;
#line 1258
  if (idx < num_efx * 3) {
#line 1260
    goto ldv_30649;
  } else {

  }
  {
#line 1260
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1261
  return (0);
}
}
#line 1264 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_send_volume_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int change ;
  int idx ;
  int val ;
  int num_efx ;

  {
  {
#line 1268
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1269
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1269
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )tmp;
#line 1271
  change = 0;
#line 1272
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1274
  ldv___ldv_spin_lock_45___1(& emu->reg_lock);
#line 1275
  idx = 0;
  }
#line 1275
  goto ldv_30664;
  ldv_30663: 
#line 1276
  val = (int )ucontrol->value.integer.value[idx] & 255;
#line 1277
  if ((int )mix->send_volume[idx / num_efx][idx % num_efx] != val) {
#line 1278
    mix->send_volume[idx / num_efx][idx % num_efx] = (unsigned char )val;
#line 1279
    change = 1;
  } else {

  }
#line 1275
  idx = idx + 1;
  ldv_30664: ;
#line 1275
  if (idx < num_efx * 3) {
#line 1277
    goto ldv_30663;
  } else {

  }

#line 1282
  if (change != 0 && (unsigned long )mix->epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1283
    if ((unsigned long )(mix->epcm)->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0) && (unsigned long )(mix->epcm)->voices[1] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1284
      update_emu10k1_send_volume(emu, ((mix->epcm)->voices[0])->number, (unsigned char *)((unsigned char (*)[8])(& mix->send_volume) + 1UL));
#line 1286
      update_emu10k1_send_volume(emu, ((mix->epcm)->voices[1])->number, (unsigned char *)((unsigned char (*)[8])(& mix->send_volume) + 2UL));
      }
    } else
#line 1288
    if ((unsigned long )(mix->epcm)->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1289
      update_emu10k1_send_volume(emu, ((mix->epcm)->voices[0])->number, (unsigned char *)(& mix->send_volume));
      }
    } else {

    }
  } else {

  }
  {
#line 1293
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1294
  return (change);
}
}
#line 1297 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_send_volume_control  = 
#line 1297
     {3, 0U, 0U, (unsigned char *)"EMU10K1 PCM Send Volume", 0U, 259U, 32U, & snd_emu10k1_send_volume_info,
    & snd_emu10k1_send_volume_get, & snd_emu10k1_send_volume_put, {0}, 0UL};
#line 1308 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_attn_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
#line 1310
  uinfo->type = 2;
#line 1311
  uinfo->count = 3U;
#line 1312
  uinfo->value.integer.min = 0L;
#line 1313
  uinfo->value.integer.max = 65535L;
#line 1314
  return (0);
}
}
#line 1317 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_attn_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  unsigned long flags ;
  int idx ;

  {
  {
#line 1320
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1321
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1321
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )tmp;
#line 1326
  ldv___ldv_spin_lock_47___0(& emu->reg_lock);
#line 1327
  idx = 0;
  }
#line 1327
  goto ldv_30680;
  ldv_30679: 
#line 1328
  ucontrol->value.integer.value[idx] = (long )mix->attn[idx];
#line 1327
  idx = idx + 1;
  ldv_30680: ;
#line 1327
  if (idx <= 2) {
#line 1329
    goto ldv_30679;
  } else {

  }
  {
#line 1329
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1330
  return (0);
}
}
#line 1333 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_attn_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int change ;
  int idx ;
  int val ;

  {
  {
#line 1337
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1338
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1338
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )tmp;
#line 1340
  change = 0;
#line 1342
  ldv___ldv_spin_lock_49___1(& emu->reg_lock);
#line 1343
  idx = 0;
  }
#line 1343
  goto ldv_30693;
  ldv_30692: 
#line 1344
  val = (int )ucontrol->value.integer.value[idx] & 65535;
#line 1345
  if ((int )mix->attn[idx] != val) {
#line 1346
    mix->attn[idx] = (unsigned short )val;
#line 1347
    change = 1;
  } else {

  }
#line 1343
  idx = idx + 1;
  ldv_30693: ;
#line 1343
  if (idx <= 2) {
#line 1345
    goto ldv_30692;
  } else {

  }

#line 1350
  if (change != 0 && (unsigned long )mix->epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1351
    if ((unsigned long )(mix->epcm)->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0) && (unsigned long )(mix->epcm)->voices[1] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1352
      snd_emu10k1_ptr_write(emu, 269484035U, (unsigned int )((mix->epcm)->voices[0])->number,
                            (unsigned int )mix->attn[1]);
#line 1353
      snd_emu10k1_ptr_write(emu, 269484035U, (unsigned int )((mix->epcm)->voices[1])->number,
                            (unsigned int )mix->attn[2]);
      }
    } else
#line 1354
    if ((unsigned long )(mix->epcm)->voices[0] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1355
      snd_emu10k1_ptr_write(emu, 269484035U, (unsigned int )((mix->epcm)->voices[0])->number,
                            (unsigned int )mix->attn[0]);
      }
    } else {

    }
  } else {

  }
  {
#line 1358
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1359
  return (change);
}
}
#line 1362 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_attn_control  = 
#line 1362
     {3, 0U, 0U, (unsigned char *)"EMU10K1 PCM Volume", 0U, 259U, 32U, & snd_emu10k1_attn_info,
    & snd_emu10k1_attn_get, & snd_emu10k1_attn_put, {0}, 0UL};
#line 1375 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_send_routing_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1377
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1378
  uinfo->type = 2;
#line 1379
  uinfo->count = emu->audigy != 0U ? 8U : 4U;
#line 1380
  uinfo->value.integer.min = 0L;
#line 1381
  uinfo->value.integer.max = emu->audigy != 0U ? 63L : 15L;
#line 1382
  return (0);
}
}
#line 1385 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_send_routing_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int idx ;
  int num_efx ;
  int mask ;

  {
  {
#line 1389
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1390
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1390
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )tmp;
#line 1393
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1394
  mask = emu->audigy != 0U ? 63 : 15;
#line 1396
  ldv___ldv_spin_lock_51___1(& emu->reg_lock);
#line 1397
  idx = 0;
  }
#line 1397
  goto ldv_30712;
  ldv_30711: 
#line 1398
  ucontrol->value.integer.value[idx] = (long )((int )mix->send_routing[0][idx] & mask);
#line 1397
  idx = idx + 1;
  ldv_30712: ;
#line 1397
  if (idx < num_efx) {
#line 1399
    goto ldv_30711;
  } else {

  }
  {
#line 1400
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1401
  return (0);
}
}
#line 1404 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_send_routing_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  int ch ;
  unsigned int tmp ;
  struct snd_emu10k1_pcm_mixer *mix ;
  int change ;
  int idx ;
  int val ;
  int num_efx ;
  int mask ;

  {
  {
#line 1408
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1409
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1409
  ch = (int )tmp;
#line 1410
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )ch;
#line 1411
  change = 0;
#line 1412
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1413
  mask = emu->audigy != 0U ? 63 : 15;
#line 1415
  ldv___ldv_spin_lock_53___0(& emu->reg_lock);
#line 1416
  idx = 0;
  }
#line 1416
  goto ldv_30728;
  ldv_30727: 
#line 1417
  val = (int )ucontrol->value.integer.value[idx] & mask;
#line 1418
  if ((int )mix->send_routing[0][idx] != val) {
#line 1419
    mix->send_routing[0][idx] = (unsigned char )val;
#line 1420
    change = 1;
  } else {

  }
#line 1416
  idx = idx + 1;
  ldv_30728: ;
#line 1416
  if (idx < num_efx) {
#line 1418
    goto ldv_30727;
  } else {

  }

#line 1424
  if (change != 0 && (unsigned long )mix->epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1425
    if ((unsigned long )(mix->epcm)->voices[ch] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1426
      update_emu10k1_fxrt(emu, ((mix->epcm)->voices[ch])->number, (unsigned char *)(& mix->send_routing));
      }
    } else {

    }
  } else {

  }
  {
#line 1430
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1431
  return (change);
}
}
#line 1434 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_efx_send_routing_control  = 
#line 1434
     {3, 0U, 0U, (unsigned char *)"Multichannel PCM Send Routing", 0U, 259U, 16U, & snd_emu10k1_efx_send_routing_info,
    & snd_emu10k1_efx_send_routing_get, & snd_emu10k1_efx_send_routing_put, {0}, 0UL};
#line 1445 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_send_volume_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1447
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1448
  uinfo->type = 2;
#line 1449
  uinfo->count = emu->audigy != 0U ? 8U : 4U;
#line 1450
  uinfo->value.integer.min = 0L;
#line 1451
  uinfo->value.integer.max = 255L;
#line 1452
  return (0);
}
}
#line 1455 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_send_volume_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  int idx ;
  int num_efx ;

  {
  {
#line 1459
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1460
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1460
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )tmp;
#line 1463
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1465
  ldv___ldv_spin_lock_55___0(& emu->reg_lock);
#line 1466
  idx = 0;
  }
#line 1466
  goto ldv_30746;
  ldv_30745: 
#line 1467
  ucontrol->value.integer.value[idx] = (long )mix->send_volume[0][idx];
#line 1466
  idx = idx + 1;
  ldv_30746: ;
#line 1466
  if (idx < num_efx) {
#line 1468
    goto ldv_30745;
  } else {

  }
  {
#line 1468
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1469
  return (0);
}
}
#line 1472 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_send_volume_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  int ch ;
  unsigned int tmp ;
  struct snd_emu10k1_pcm_mixer *mix ;
  int change ;
  int idx ;
  int val ;
  int num_efx ;

  {
  {
#line 1476
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1477
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1477
  ch = (int )tmp;
#line 1478
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )ch;
#line 1479
  change = 0;
#line 1480
  num_efx = emu->audigy != 0U ? 8 : 4;
#line 1482
  ldv___ldv_spin_lock_57___0(& emu->reg_lock);
#line 1483
  idx = 0;
  }
#line 1483
  goto ldv_30761;
  ldv_30760: 
#line 1484
  val = (int )ucontrol->value.integer.value[idx] & 255;
#line 1485
  if ((int )mix->send_volume[0][idx] != val) {
#line 1486
    mix->send_volume[0][idx] = (unsigned char )val;
#line 1487
    change = 1;
  } else {

  }
#line 1483
  idx = idx + 1;
  ldv_30761: ;
#line 1483
  if (idx < num_efx) {
#line 1485
    goto ldv_30760;
  } else {

  }

#line 1490
  if (change != 0 && (unsigned long )mix->epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1491
    if ((unsigned long )(mix->epcm)->voices[ch] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1492
      update_emu10k1_send_volume(emu, ((mix->epcm)->voices[ch])->number, (unsigned char *)(& mix->send_volume));
      }
    } else {

    }
  } else {

  }
  {
#line 1496
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1497
  return (change);
}
}
#line 1501 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_efx_send_volume_control  = 
#line 1501
     {3, 0U, 0U, (unsigned char *)"Multichannel PCM Send Volume", 0U, 259U, 16U, & snd_emu10k1_efx_send_volume_info,
    & snd_emu10k1_efx_send_volume_get, & snd_emu10k1_efx_send_volume_put, {0}, 0UL};
#line 1512 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_attn_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
#line 1514
  uinfo->type = 2;
#line 1515
  uinfo->count = 1U;
#line 1516
  uinfo->value.integer.min = 0L;
#line 1517
  uinfo->value.integer.max = 65535L;
#line 1518
  return (0);
}
}
#line 1521 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_attn_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_pcm_mixer *mix ;
  unsigned int tmp ;
  unsigned long flags ;

  {
  {
#line 1524
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1525
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1525
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )tmp;
#line 1529
  ldv___ldv_spin_lock_59___0(& emu->reg_lock);
#line 1530
  ucontrol->value.integer.value[0] = (long )mix->attn[0];
#line 1531
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1532
  return (0);
}
}
#line 1535 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_efx_attn_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  int ch ;
  unsigned int tmp ;
  struct snd_emu10k1_pcm_mixer *mix ;
  int change ;
  int val ;

  {
  {
#line 1539
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1540
  tmp = snd_ctl_get_ioffidx(kcontrol, & ucontrol->id);
#line 1540
  ch = (int )tmp;
#line 1541
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )ch;
#line 1542
  change = 0;
#line 1544
  ldv___ldv_spin_lock_61___0(& emu->reg_lock);
#line 1545
  val = (int )ucontrol->value.integer.value[0] & 65535;
  }
#line 1546
  if ((int )mix->attn[0] != val) {
#line 1547
    mix->attn[0] = (unsigned short )val;
#line 1548
    change = 1;
  } else {

  }
#line 1550
  if (change != 0 && (unsigned long )mix->epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 1551
    if ((unsigned long )(mix->epcm)->voices[ch] != (unsigned long )((struct snd_emu10k1_voice *)0)) {
      {
#line 1552
      snd_emu10k1_ptr_write(emu, 269484035U, (unsigned int )((mix->epcm)->voices[ch])->number,
                            (unsigned int )mix->attn[0]);
      }
    } else {

    }
  } else {

  }
  {
#line 1555
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1556
  return (change);
}
}
#line 1559 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_efx_attn_control  = 
#line 1559
     {3, 0U, 0U, (unsigned char *)"Multichannel PCM Volume", 0U, 259U, 16U, & snd_emu10k1_efx_attn_info,
    & snd_emu10k1_efx_attn_get, & snd_emu10k1_efx_attn_put, {0}, 0UL};
#line 1572 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_shared_spdif_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1575
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1577
  if (emu->audigy != 0U) {
    {
#line 1578
    tmp = inl((int )((unsigned int )emu->port + 24U));
#line 1578
    ucontrol->value.integer.value[0] = (tmp & 68U) != 0U;
    }
  } else {
    {
#line 1580
    tmp___0 = inl((int )((unsigned int )emu->port + 20U));
#line 1580
    ucontrol->value.integer.value[0] = (tmp___0 & 4096U) != 0U;
    }
  }
#line 1581
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->invert_shared_spdif) != 0U) {
#line 1582
    ucontrol->value.integer.value[0] = ucontrol->value.integer.value[0] == 0L;
  } else {

  }
#line 1585
  return (0);
}
}
#line 1588 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_emu10k1_shared_spdif_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  unsigned long flags ;
  struct snd_emu10k1 *emu ;
  unsigned int reg ;
  unsigned int val ;
  unsigned int sw ;
  int change ;

  {
#line 1592
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1594
  change = 0;
#line 1596
  sw = (unsigned int )ucontrol->value.integer.value[0];
#line 1597
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->invert_shared_spdif) != 0U) {
#line 1598
    sw = sw == 0U;
  } else {

  }
  {
#line 1599
  ldv___ldv_spin_lock_63___0(& emu->reg_lock);
  }
#line 1600
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {

  } else
#line 1602
  if (emu->audigy != 0U) {
    {
#line 1603
    reg = inl((int )((unsigned int )emu->port + 24U));
#line 1604
    val = sw != 0U ? 68U : 0U;
#line 1605
    change = (reg & 68U) != val;
    }
#line 1606
    if (change != 0) {
      {
#line 1607
      reg = reg & 4294967227U;
#line 1608
      reg = reg | val;
#line 1609
      outl(reg | val, (int )((unsigned int )emu->port + 24U));
      }
    } else {

    }
  } else {

  }
  {
#line 1612
  reg = inl((int )((unsigned int )emu->port + 20U));
#line 1613
  val = sw != 0U ? 4096U : 0U;
#line 1614
  change = change | ((reg & 4096U) != val);
  }
#line 1615
  if (change != 0) {
    {
#line 1616
    reg = reg & 4294963199U;
#line 1617
    reg = reg | val;
#line 1618
    outl(reg | val, (int )((unsigned int )emu->port + 20U));
    }
  } else {

  }
  {
#line 1620
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 1621
  return (change);
}
}
#line 1624 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_emu10k1_shared_spdif  = 
#line 1624
     {2, 0U, 0U, (unsigned char *)"SB Live Analog/Digital Output Jack", 0U, 0U, 0U,
    & snd_ctl_boolean_mono_info, & snd_emu10k1_shared_spdif_get, & snd_emu10k1_shared_spdif_put,
    {0}, 0UL};
#line 1633 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_audigy_shared_spdif  = 
#line 1633
     {2, 0U, 0U, (unsigned char *)"Audigy Analog/Digital Output Jack", 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
    & snd_emu10k1_shared_spdif_get, & snd_emu10k1_shared_spdif_put, {0}, 0UL};
#line 1646 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_capture_boost_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  unsigned short tmp ;

  {
  {
#line 1649
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1653
  tmp = snd_ac97_read(emu->ac97, 28);
#line 1653
  val = (unsigned int )tmp;
#line 1654
  ucontrol->value.integer.value[0] = val != 0U;
  }
#line 1655
  return (0);
}
}
#line 1658 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int snd_audigy_capture_boost_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  int tmp ;

  {
#line 1661
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 1664
  if (ucontrol->value.integer.value[0] != 0L) {
#line 1665
    val = 3855U;
  } else {
#line 1667
    val = 0U;
  }
  {
#line 1668
  tmp = snd_ac97_update(emu->ac97, 28, (int )((unsigned short )val));
  }
#line 1668
  return (tmp);
}
}
#line 1671 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol_new snd_audigy_capture_boost  = 
#line 1671
     {2, 0U, 0U, (unsigned char *)"Analog Capture Boost", 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
    & snd_audigy_capture_boost_get, & snd_audigy_capture_boost_put, {0}, 0UL};
#line 1683 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static void snd_emu10k1_mixer_free_ac97(struct snd_ac97 *ac97 ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 1685
  emu = (struct snd_emu10k1 *)ac97->private_data;
#line 1686
  emu->ac97 = (struct snd_ac97 *)0;
#line 1687
  return;
}
}
#line 1691 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int remove_ctl(struct snd_card *card , char const   *name ) 
{ 
  struct snd_ctl_elem_id id___0 ;
  int tmp ;

  {
  {
#line 1694
  memset((void *)(& id___0), 0, 64UL);
#line 1695
  strcpy((char *)(& id___0.name), name);
#line 1696
  id___0.iface = 2;
#line 1697
  tmp = snd_ctl_remove_id(card, & id___0);
  }
#line 1697
  return (tmp);
}
}
#line 1700 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static struct snd_kcontrol *ctl_find(struct snd_card *card , char const   *name ) 
{ 
  struct snd_ctl_elem_id sid ;
  struct snd_kcontrol *tmp ;

  {
  {
#line 1703
  memset((void *)(& sid), 0, 64UL);
#line 1704
  strcpy((char *)(& sid.name), name);
#line 1705
  sid.iface = 2;
#line 1706
  tmp = snd_ctl_find_id(card, & sid);
  }
#line 1706
  return (tmp);
}
}
#line 1709 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
static int rename_ctl(struct snd_card *card , char const   *src , char const   *dst ) 
{ 
  struct snd_kcontrol *kctl ;
  struct snd_kcontrol *tmp ;

  {
  {
#line 1711
  tmp = ctl_find(card, src);
#line 1711
  kctl = tmp;
  }
#line 1712
  if ((unsigned long )kctl != (unsigned long )((struct snd_kcontrol *)0)) {
    {
#line 1713
    strcpy((char *)(& kctl->id.name), dst);
    }
#line 1714
    return (0);
  } else {

  }
#line 1716
  return (-2);
}
}
#line 1719 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emumixer.c"
int snd_emu10k1_mixer(struct snd_emu10k1 *emu , int pcm_device , int multi_device ) 
{ 
  int err ;
  int pcm ;
  struct snd_kcontrol *kctl ;
  struct snd_card *card ;
  char **c ;
  char *emu10k1_remove_ctls[11U] ;
  char *emu10k1_rename_ctls[7U] ;
  char *audigy_remove_ctls[17U] ;
  char *audigy_rename_ctls[7U] ;
  char *audigy_rename_ctls_i2c_adc[11U] ;
  char *audigy_remove_ctls_i2c_adc[5U] ;
  char *audigy_remove_ctls_1361t_adc[16U] ;
  char *audigy_rename_ctls_1361t_adc[35U] ;
  struct snd_ac97_bus *pbus ;
  struct snd_ac97_template ac97 ;
  struct snd_ac97_bus_ops ops ;
  struct snd_kcontrol *tmp ;
  struct snd_kcontrol *tmp___0 ;
  struct snd_kcontrol *tmp___1 ;
  struct snd_kcontrol *tmp___2 ;
  struct snd_kcontrol *tmp___3 ;
  struct snd_kcontrol *tmp___4 ;
  struct snd_emu10k1_pcm_mixer *mix ;
  int v ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;
  struct snd_emu10k1_pcm_mixer *mix___0 ;
  int v___0 ;
  int i ;
  struct snd_kcontrol *tmp___12 ;
  struct snd_kcontrol *tmp___13 ;
  struct snd_kcontrol *tmp___14 ;
  struct snd_kcontrol *tmp___15 ;
  struct snd_kcontrol *tmp___16 ;
  int i___0 ;
  struct snd_kcontrol *tmp___17 ;
  struct snd_kcontrol *tmp___18 ;
  struct snd_kcontrol *tmp___19 ;
  struct snd_kcontrol *tmp___20 ;
  struct snd_kcontrol *tmp___21 ;
  int i___1 ;
  struct snd_kcontrol *tmp___22 ;
  struct snd_kcontrol *tmp___23 ;
  struct snd_kcontrol *tmp___24 ;

  {
#line 1724
  card = emu->card;
#line 1726
  emu10k1_remove_ctls[0] = (char *)"Master Mono Playback Switch";
#line 1726
  emu10k1_remove_ctls[1] = (char *)"Master Mono Playback Volume";
#line 1726
  emu10k1_remove_ctls[2] = (char *)"PCM Out Path & Mute";
#line 1726
  emu10k1_remove_ctls[3] = (char *)"Mono Output Select";
#line 1726
  emu10k1_remove_ctls[4] = (char *)"Surround Playback Switch";
#line 1726
  emu10k1_remove_ctls[5] = (char *)"Surround Playback Volume";
#line 1726
  emu10k1_remove_ctls[6] = (char *)"Center Playback Switch";
#line 1726
  emu10k1_remove_ctls[7] = (char *)"Center Playback Volume";
#line 1726
  emu10k1_remove_ctls[8] = (char *)"LFE Playback Switch";
#line 1726
  emu10k1_remove_ctls[9] = (char *)"LFE Playback Volume";
#line 1726
  emu10k1_remove_ctls[10] = (char *)0;
#line 1740
  emu10k1_rename_ctls[0] = (char *)"Surround Digital Playback Volume";
#line 1740
  emu10k1_rename_ctls[1] = (char *)"Surround Playback Volume";
#line 1740
  emu10k1_rename_ctls[2] = (char *)"Center Digital Playback Volume";
#line 1740
  emu10k1_rename_ctls[3] = (char *)"Center Playback Volume";
#line 1740
  emu10k1_rename_ctls[4] = (char *)"LFE Digital Playback Volume";
#line 1740
  emu10k1_rename_ctls[5] = (char *)"LFE Playback Volume";
#line 1740
  emu10k1_rename_ctls[6] = (char *)0;
#line 1746
  audigy_remove_ctls[0] = (char *)"PCM Playback Switch";
#line 1746
  audigy_remove_ctls[1] = (char *)"PCM Playback Volume";
#line 1746
  audigy_remove_ctls[2] = (char *)"Master Mono Playback Switch";
#line 1746
  audigy_remove_ctls[3] = (char *)"Master Mono Playback Volume";
#line 1746
  audigy_remove_ctls[4] = (char *)"Master Playback Switch";
#line 1746
  audigy_remove_ctls[5] = (char *)"Master Playback Volume";
#line 1746
  audigy_remove_ctls[6] = (char *)"PCM Out Path & Mute";
#line 1746
  audigy_remove_ctls[7] = (char *)"Mono Output Select";
#line 1746
  audigy_remove_ctls[8] = (char *)"Capture Source";
#line 1746
  audigy_remove_ctls[9] = (char *)"Capture Switch";
#line 1746
  audigy_remove_ctls[10] = (char *)"Capture Volume";
#line 1746
  audigy_remove_ctls[11] = (char *)"Mic Select";
#line 1746
  audigy_remove_ctls[12] = (char *)"Video Playback Switch";
#line 1746
  audigy_remove_ctls[13] = (char *)"Video Playback Volume";
#line 1746
  audigy_remove_ctls[14] = (char *)"Mic Playback Switch";
#line 1746
  audigy_remove_ctls[15] = (char *)"Mic Playback Volume";
#line 1746
  audigy_remove_ctls[16] = (char *)0;
#line 1769
  audigy_rename_ctls[0] = (char *)"Wave Playback Volume";
#line 1769
  audigy_rename_ctls[1] = (char *)"PCM Playback Volume";
#line 1769
  audigy_rename_ctls[2] = (char *)"Wave Master Playback Volume";
#line 1769
  audigy_rename_ctls[3] = (char *)"Master Playback Volume";
#line 1769
  audigy_rename_ctls[4] = (char *)"AMic Playback Volume";
#line 1769
  audigy_rename_ctls[5] = (char *)"Mic Playback Volume";
#line 1769
  audigy_rename_ctls[6] = (char *)0;
#line 1777
  audigy_rename_ctls_i2c_adc[0] = (char *)"Line Capture Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[1] = (char *)"Analog Mix Capture Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[2] = (char *)"Wave Playback Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[3] = (char *)"OLD PCM Playback Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[4] = (char *)"Wave Master Playback Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[5] = (char *)"Master Playback Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[6] = (char *)"AMic Playback Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[7] = (char *)"Old Mic Playback Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[8] = (char *)"CD Capture Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[9] = (char *)"IEC958 Optical Capture Volume";
#line 1777
  audigy_rename_ctls_i2c_adc[10] = (char *)0;
#line 1786
  audigy_remove_ctls_i2c_adc[0] = (char *)"Mic Capture Volume";
#line 1786
  audigy_remove_ctls_i2c_adc[1] = (char *)"Analog Mix Capture Volume";
#line 1786
  audigy_remove_ctls_i2c_adc[2] = (char *)"Aux Capture Volume";
#line 1786
  audigy_remove_ctls_i2c_adc[3] = (char *)"IEC958 Optical Capture Volume";
#line 1786
  audigy_remove_ctls_i2c_adc[4] = (char *)0;
#line 1795
  audigy_remove_ctls_1361t_adc[0] = (char *)"PCM Playback Switch";
#line 1795
  audigy_remove_ctls_1361t_adc[1] = (char *)"PCM Playback Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[2] = (char *)"Master Mono Playback Switch";
#line 1795
  audigy_remove_ctls_1361t_adc[3] = (char *)"Master Mono Playback Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[4] = (char *)"Capture Source";
#line 1795
  audigy_remove_ctls_1361t_adc[5] = (char *)"Capture Switch";
#line 1795
  audigy_remove_ctls_1361t_adc[6] = (char *)"Capture Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[7] = (char *)"Mic Capture Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[8] = (char *)"Headphone Playback Switch";
#line 1795
  audigy_remove_ctls_1361t_adc[9] = (char *)"Headphone Playback Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[10] = (char *)"3D Control - Center";
#line 1795
  audigy_remove_ctls_1361t_adc[11] = (char *)"3D Control - Depth";
#line 1795
  audigy_remove_ctls_1361t_adc[12] = (char *)"3D Control - Switch";
#line 1795
  audigy_remove_ctls_1361t_adc[13] = (char *)"Line2 Playback Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[14] = (char *)"Line2 Capture Volume";
#line 1795
  audigy_remove_ctls_1361t_adc[15] = (char *)0;
#line 1815
  audigy_rename_ctls_1361t_adc[0] = (char *)"Master Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[1] = (char *)"Master Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[2] = (char *)"Master Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[3] = (char *)"Master Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[4] = (char *)"Wave Master Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[5] = (char *)"Master Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[6] = (char *)"Beep Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[7] = (char *)"Beep Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[8] = (char *)"Beep Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[9] = (char *)"Beep Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[10] = (char *)"Phone Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[11] = (char *)"Phone Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[12] = (char *)"Phone Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[13] = (char *)"Phone Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[14] = (char *)"Mic Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[15] = (char *)"Mic Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[16] = (char *)"Mic Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[17] = (char *)"Mic Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[18] = (char *)"Line Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[19] = (char *)"Line Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[20] = (char *)"Line Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[21] = (char *)"Line Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[22] = (char *)"CD Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[23] = (char *)"CD Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[24] = (char *)"CD Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[25] = (char *)"CD Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[26] = (char *)"Aux Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[27] = (char *)"Aux Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[28] = (char *)"Aux Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[29] = (char *)"Aux Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[30] = (char *)"Video Playback Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[31] = (char *)"Video Capture Switch";
#line 1815
  audigy_rename_ctls_1361t_adc[32] = (char *)"Video Playback Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[33] = (char *)"Video Capture Volume";
#line 1815
  audigy_rename_ctls_1361t_adc[34] = (char *)0;
#line 1837
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U) {
    {
#line 1840
    ops.reset = 0;
#line 1840
    ops.warm_reset = 0;
#line 1840
    ops.write = & snd_emu10k1_ac97_write;
#line 1840
    ops.read = & snd_emu10k1_ac97_read;
#line 1840
    ops.wait = 0;
#line 1840
    ops.init = 0;
#line 1845
    err = snd_ac97_bus(emu->card, 0, & ops, (void *)0, & pbus);
    }
#line 1845
    if (err < 0) {
#line 1846
      return (err);
    } else {

    }
    {
#line 1847
    pbus->no_vra = 1U;
#line 1849
    memset((void *)(& ac97), 0, 40UL);
#line 1850
    ac97.private_data = (void *)emu;
#line 1851
    ac97.private_free = & snd_emu10k1_mixer_free_ac97;
#line 1852
    ac97.scaps = 512U;
#line 1853
    err = snd_ac97_mixer(pbus, & ac97, & emu->ac97);
    }
#line 1853
    if (err < 0) {
#line 1854
      if ((unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) == 1U) {
#line 1855
        return (err);
      } else {

      }
      {
#line 1856
      __snd_printk(1U, "sound/pci/emu10k1/emumixer.c", 1856, "<6>emu10k1: AC97 is optional on this board\n");
#line 1857
      __snd_printk(1U, "sound/pci/emu10k1/emumixer.c", 1857, "<6>          Proceeding without ac97 mixers...\n");
#line 1858
      snd_device_free(emu->card, (void *)pbus);
      }
#line 1859
      goto no_ac97;
    } else {

    }
#line 1861
    if (emu->audigy != 0U) {
      {
#line 1863
      snd_ac97_write_cache(emu->ac97, 2, 0);
#line 1865
      snd_ac97_write_cache(emu->ac97, 26, 0);
      }
#line 1866
      if ((unsigned int )((unsigned char )(emu->card_capabilities)->adc_1361t) != 0U) {
#line 1867
        c = (char **)(& audigy_remove_ctls_1361t_adc);
      } else {
#line 1869
        c = (char **)(& audigy_remove_ctls);
      }
    } else {
#line 1876
      if ((emu->ac97)->id == 2206496344U) {
        {
#line 1877
        emu->rear_ac97 = 1U;
#line 1878
        snd_emu10k1_ptr_write(emu, 95U, 0U, 51U);
#line 1879
        snd_ac97_write_cache(emu->ac97, 4, 514);
#line 1880
        remove_ctl(card, "Front Playback Volume");
#line 1881
        remove_ctl(card, "Front Playback Switch");
        }
      } else {

      }
      {
#line 1884
      snd_ac97_write_cache(emu->ac97, 56, 514);
#line 1885
      snd_ac97_write_cache(emu->ac97, 54, 514);
#line 1886
      c = (char **)(& emu10k1_remove_ctls);
      }
    }
#line 1888
    goto ldv_30859;
    ldv_30858: 
    {
#line 1889
    remove_ctl(card, (char const   *)*c);
#line 1888
    c = c + 1;
    }
    ldv_30859: ;
#line 1888
    if ((unsigned long )*c != (unsigned long )((char *)0)) {
#line 1890
      goto ldv_30858;
    } else {

    }

  } else
#line 1890
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {
#line 1891
    c = (char **)(& audigy_remove_ctls_i2c_adc);
#line 1892
    goto ldv_30862;
    ldv_30861: 
    {
#line 1893
    remove_ctl(card, (char const   *)*c);
#line 1892
    c = c + 1;
    }
    ldv_30862: ;
#line 1892
    if ((unsigned long )*c != (unsigned long )((char *)0)) {
#line 1894
      goto ldv_30861;
    } else {

    }

  } else {
    no_ac97: ;
#line 1896
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->ecard) != 0U) {
      {
#line 1897
      strcpy((char *)(& (emu->card)->mixername), "EMU APS");
      }
    } else
#line 1898
    if (emu->audigy != 0U) {
      {
#line 1899
      strcpy((char *)(& (emu->card)->mixername), "SB Audigy");
      }
    } else {
      {
#line 1901
      strcpy((char *)(& (emu->card)->mixername), "Emu10k1");
      }
    }
  }
#line 1904
  if (emu->audigy != 0U) {
#line 1905
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->adc_1361t) != 0U) {
#line 1906
      c = (char **)(& audigy_rename_ctls_1361t_adc);
    } else
#line 1907
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {
#line 1908
      c = (char **)(& audigy_rename_ctls_i2c_adc);
    } else {
#line 1910
      c = (char **)(& audigy_rename_ctls);
    }
  } else {
#line 1912
    c = (char **)(& emu10k1_rename_ctls);
  }
#line 1913
  goto ldv_30865;
  ldv_30864: 
  {
#line 1914
  rename_ctl(card, (char const   *)*c, (char const   *)*(c + 1UL));
#line 1913
  c = c + 2UL;
  }
  ldv_30865: ;
#line 1913
  if ((unsigned long )*c != (unsigned long )((char *)0)) {
#line 1915
    goto ldv_30864;
  } else {

  }

#line 1916
  if ((unsigned int )(emu->card_capabilities)->subsystem == 2151682306U) {
    {
#line 1917
    remove_ctl(card, "Center Playback Volume");
#line 1918
    remove_ctl(card, "LFE Playback Volume");
#line 1919
    remove_ctl(card, "Wave Center Playback Volume");
#line 1920
    remove_ctl(card, "Wave LFE Playback Volume");
    }
  } else {

  }
#line 1922
  if ((unsigned int )(emu->card_capabilities)->subsystem == 537334018U) {
    {
#line 1923
    rename_ctl(card, "Line2 Capture Volume", "Line1/Mic Capture Volume");
#line 1924
    rename_ctl(card, "Analog Mix Capture Volume", "Line2 Capture Volume");
#line 1925
    rename_ctl(card, "Aux2 Capture Volume", "Line3 Capture Volume");
#line 1926
    rename_ctl(card, "Mic Capture Volume", "Unknown1 Capture Volume");
#line 1927
    remove_ctl(card, "Headphone Playback Switch");
#line 1928
    remove_ctl(card, "Headphone Playback Volume");
#line 1929
    remove_ctl(card, "3D Control - Center");
#line 1930
    remove_ctl(card, "3D Control - Depth");
#line 1931
    remove_ctl(card, "3D Control - Switch");
    }
  } else {

  }
  {
#line 1933
  tmp = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_send_routing_control),
                     (void *)emu);
#line 1933
  emu->ctl_send_routing = tmp;
#line 1933
  kctl = tmp;
  }
#line 1933
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1934
    return (-12);
  } else {

  }
  {
#line 1935
  kctl->id.device = (unsigned int )pcm_device;
#line 1936
  err = snd_ctl_add(card, kctl);
  }
#line 1936
  if (err != 0) {
#line 1937
    return (err);
  } else {

  }
  {
#line 1938
  tmp___0 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_send_volume_control),
                         (void *)emu);
#line 1938
  emu->ctl_send_volume = tmp___0;
#line 1938
  kctl = tmp___0;
  }
#line 1938
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1939
    return (-12);
  } else {

  }
  {
#line 1940
  kctl->id.device = (unsigned int )pcm_device;
#line 1941
  err = snd_ctl_add(card, kctl);
  }
#line 1941
  if (err != 0) {
#line 1942
    return (err);
  } else {

  }
  {
#line 1943
  tmp___1 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_attn_control),
                         (void *)emu);
#line 1943
  emu->ctl_attn = tmp___1;
#line 1943
  kctl = tmp___1;
  }
#line 1943
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1944
    return (-12);
  } else {

  }
  {
#line 1945
  kctl->id.device = (unsigned int )pcm_device;
#line 1946
  err = snd_ctl_add(card, kctl);
  }
#line 1946
  if (err != 0) {
#line 1947
    return (err);
  } else {

  }
  {
#line 1949
  tmp___2 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_efx_send_routing_control),
                         (void *)emu);
#line 1949
  emu->ctl_efx_send_routing = tmp___2;
#line 1949
  kctl = tmp___2;
  }
#line 1949
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1950
    return (-12);
  } else {

  }
  {
#line 1951
  kctl->id.device = (unsigned int )multi_device;
#line 1952
  err = snd_ctl_add(card, kctl);
  }
#line 1952
  if (err != 0) {
#line 1953
    return (err);
  } else {

  }
  {
#line 1955
  tmp___3 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_efx_send_volume_control),
                         (void *)emu);
#line 1955
  emu->ctl_efx_send_volume = tmp___3;
#line 1955
  kctl = tmp___3;
  }
#line 1955
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1956
    return (-12);
  } else {

  }
  {
#line 1957
  kctl->id.device = (unsigned int )multi_device;
#line 1958
  err = snd_ctl_add(card, kctl);
  }
#line 1958
  if (err != 0) {
#line 1959
    return (err);
  } else {

  }
  {
#line 1961
  tmp___4 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_efx_attn_control),
                         (void *)emu);
#line 1961
  emu->ctl_efx_attn = tmp___4;
#line 1961
  kctl = tmp___4;
  }
#line 1961
  if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 1962
    return (-12);
  } else {

  }
  {
#line 1963
  kctl->id.device = (unsigned int )multi_device;
#line 1964
  err = snd_ctl_add(card, kctl);
  }
#line 1964
  if (err != 0) {
#line 1965
    return (err);
  } else {

  }
#line 1968
  pcm = 0;
#line 1968
  goto ldv_30873;
  ldv_30872: 
#line 1972
  mix = (struct snd_emu10k1_pcm_mixer *)(& emu->pcm_mixer) + (unsigned long )pcm;
#line 1973
  mix->epcm = (struct snd_emu10k1_pcm *)0;
#line 1975
  v = 0;
#line 1975
  goto ldv_30870;
  ldv_30869: 
#line 1976
  tmp___6 = (unsigned char )v;
#line 1976
  mix->send_routing[2][v] = tmp___6;
#line 1976
  tmp___5 = tmp___6;
#line 1976
  mix->send_routing[1][v] = tmp___5;
#line 1976
  mix->send_routing[0][v] = tmp___5;
#line 1975
  v = v + 1;
  ldv_30870: ;
#line 1975
  if (v <= 3) {
#line 1977
    goto ldv_30869;
  } else {

  }
  {
#line 1980
  memset((void *)(& mix->send_volume), 0, 24UL);
#line 1981
  tmp___9 = 255U;
#line 1981
  mix->send_volume[2][1] = tmp___9;
#line 1981
  tmp___8 = tmp___9;
#line 1981
  mix->send_volume[1][0] = tmp___8;
#line 1981
  tmp___7 = tmp___8;
#line 1981
  mix->send_volume[0][1] = tmp___7;
#line 1981
  mix->send_volume[0][0] = tmp___7;
#line 1984
  tmp___11 = 65535U;
#line 1984
  mix->attn[2] = tmp___11;
#line 1984
  tmp___10 = tmp___11;
#line 1984
  mix->attn[1] = tmp___10;
#line 1984
  mix->attn[0] = tmp___10;
#line 1968
  pcm = pcm + 1;
  }
  ldv_30873: ;
#line 1968
  if (pcm <= 31) {
#line 1970
    goto ldv_30872;
  } else {

  }
#line 1988
  pcm = 0;
#line 1988
  goto ldv_30884;
  ldv_30883: 
#line 1992
  mix___0 = (struct snd_emu10k1_pcm_mixer *)(& emu->efx_pcm_mixer) + (unsigned long )pcm;
#line 1993
  mix___0->epcm = (struct snd_emu10k1_pcm *)0;
#line 1995
  mix___0->send_routing[0][0] = (unsigned char )pcm;
#line 1996
  mix___0->send_routing[0][1] = pcm == 0;
#line 1997
  v___0 = 0;
#line 1997
  goto ldv_30878;
  ldv_30877: 
#line 1998
  mix___0->send_routing[0][v___0 + 2] = (unsigned int )((unsigned char )v___0) + 13U;
#line 1997
  v___0 = v___0 + 1;
  ldv_30878: ;
#line 1997
  if (v___0 <= 1) {
#line 1999
    goto ldv_30877;
  } else {

  }

#line 1999
  if (emu->audigy != 0U) {
#line 2000
    v___0 = 0;
#line 2000
    goto ldv_30881;
    ldv_30880: 
#line 2001
    mix___0->send_routing[0][v___0 + 4] = (unsigned int )((unsigned char )v___0) + 60U;
#line 2000
    v___0 = v___0 + 1;
    ldv_30881: ;
#line 2000
    if (v___0 <= 3) {
#line 2002
      goto ldv_30880;
    } else {

    }

  } else {

  }
  {
#line 2003
  memset((void *)(& mix___0->send_volume), 0, 24UL);
#line 2004
  mix___0->send_volume[0][0] = 255U;
#line 2006
  mix___0->attn[0] = 65535U;
#line 1988
  pcm = pcm + 1;
  }
  ldv_30884: ;
#line 1988
  if (pcm <= 15) {
#line 1990
    goto ldv_30883;
  } else {

  }

#line 2009
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ecard) == 0U) {
    {
#line 2011
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_spdif_mask_control),
                        (void *)emu);
    }
#line 2011
    if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 2012
      return (-12);
    } else {

    }
#line 2013
    if (emu->audigy == 0U) {
#line 2014
      kctl->id.device = (unsigned int )(emu->pcm_efx)->device;
    } else {

    }
    {
#line 2015
    err = snd_ctl_add(card, kctl);
    }
#line 2015
    if (err != 0) {
#line 2016
      return (err);
    } else {

    }
    {
#line 2017
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_spdif_control),
                        (void *)emu);
    }
#line 2017
    if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 2018
      return (-12);
    } else {

    }
#line 2019
    if (emu->audigy == 0U) {
#line 2020
      kctl->id.device = (unsigned int )(emu->pcm_efx)->device;
    } else {

    }
    {
#line 2021
    err = snd_ctl_add(card, kctl);
    }
#line 2021
    if (err != 0) {
#line 2022
      return (err);
    } else {

    }
  } else {

  }
#line 2025
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {

  } else
#line 2027
  if (emu->audigy != 0U) {
    {
#line 2028
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_audigy_shared_spdif),
                        (void *)emu);
    }
#line 2028
    if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 2029
      return (-12);
    } else {

    }
    {
#line 2030
    err = snd_ctl_add(card, kctl);
    }
#line 2030
    if (err != 0) {
#line 2031
      return (err);
    } else {

    }
  } else
#line 2038
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ecard) == 0U) {
    {
#line 2040
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu10k1_shared_spdif),
                        (void *)emu);
    }
#line 2040
    if ((unsigned long )kctl == (unsigned long )((struct snd_kcontrol *)0)) {
#line 2041
      return (-12);
    } else {

    }
    {
#line 2042
    err = snd_ctl_add(card, kctl);
    }
#line 2042
    if (err != 0) {
#line 2043
      return (err);
    } else {

    }
  } else {

  }
#line 2045
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0151_chip) != 0U) {
    {
#line 2046
    err = snd_p16v_mixer(emu);
    }
#line 2046
    if (err != 0) {
#line 2047
      return (err);
    } else {

    }
  } else {

  }
#line 2050
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) == 3U) {
#line 2054
    i = 0;
#line 2054
    goto ldv_30890;
    ldv_30889: 
    {
#line 2055
    tmp___12 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1616_output_enum_ctls) + (unsigned long )i),
                            (void *)emu);
#line 2055
    err = snd_ctl_add(card, tmp___12);
    }
#line 2058
    if (err < 0) {
#line 2059
      return (err);
    } else {

    }
#line 2054
    i = i + 1;
    ldv_30890: ;
#line 2054
    if ((unsigned int )i <= 17U) {
#line 2056
      goto ldv_30889;
    } else {

    }
#line 2061
    i = 0;
#line 2061
    goto ldv_30895;
    ldv_30894: 
    {
#line 2062
    tmp___13 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_input_enum_ctls) + (unsigned long )i),
                            (void *)emu);
#line 2062
    err = snd_ctl_add(card, tmp___13);
    }
#line 2065
    if (err < 0) {
#line 2066
      return (err);
    } else {

    }
#line 2061
    i = i + 1;
    ldv_30895: ;
#line 2061
    if ((unsigned int )i <= 21U) {
#line 2063
      goto ldv_30894;
    } else {

    }
#line 2068
    i = 0;
#line 2068
    goto ldv_30900;
    ldv_30899: 
    {
#line 2069
    tmp___14 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_adc_pads) + (unsigned long )i),
                            (void *)emu);
#line 2069
    err = snd_ctl_add(card, tmp___14);
    }
#line 2071
    if (err < 0) {
#line 2072
      return (err);
    } else {

    }
#line 2068
    i = i + 1;
    ldv_30900: ;
#line 2068
    if ((unsigned int )i <= 1U) {
#line 2070
      goto ldv_30899;
    } else {

    }
#line 2074
    i = 0;
#line 2074
    goto ldv_30905;
    ldv_30904: 
    {
#line 2075
    tmp___15 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_dac_pads) + (unsigned long )i),
                            (void *)emu);
#line 2075
    err = snd_ctl_add(card, tmp___15);
    }
#line 2077
    if (err < 0) {
#line 2078
      return (err);
    } else {

    }
#line 2074
    i = i + 1;
    ldv_30905: ;
#line 2074
    if ((unsigned int )i <= 2U) {
#line 2076
      goto ldv_30904;
    } else {

    }
    {
#line 2080
    tmp___16 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu1010_internal_clock),
                            (void *)emu);
#line 2080
    err = snd_ctl_add(card, tmp___16);
    }
#line 2082
    if (err < 0) {
#line 2083
      return (err);
    } else {

    }
  } else
#line 2085
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
#line 2089
    i___0 = 0;
#line 2089
    goto ldv_30911;
    ldv_30910: 
    {
#line 2090
    tmp___17 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_output_enum_ctls) + (unsigned long )i___0),
                            (void *)emu);
#line 2090
    err = snd_ctl_add(card, tmp___17);
    }
#line 2093
    if (err < 0) {
#line 2094
      return (err);
    } else {

    }
#line 2089
    i___0 = i___0 + 1;
    ldv_30911: ;
#line 2089
    if ((unsigned int )i___0 <= 23U) {
#line 2091
      goto ldv_30910;
    } else {

    }
#line 2096
    i___0 = 0;
#line 2096
    goto ldv_30916;
    ldv_30915: 
    {
#line 2097
    tmp___18 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_input_enum_ctls) + (unsigned long )i___0),
                            (void *)emu);
#line 2097
    err = snd_ctl_add(card, tmp___18);
    }
#line 2100
    if (err < 0) {
#line 2101
      return (err);
    } else {

    }
#line 2096
    i___0 = i___0 + 1;
    ldv_30916: ;
#line 2096
    if ((unsigned int )i___0 <= 21U) {
#line 2098
      goto ldv_30915;
    } else {

    }
#line 2103
    i___0 = 0;
#line 2103
    goto ldv_30921;
    ldv_30920: 
    {
#line 2104
    tmp___19 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_adc_pads) + (unsigned long )i___0),
                            (void *)emu);
#line 2104
    err = snd_ctl_add(card, tmp___19);
    }
#line 2106
    if (err < 0) {
#line 2107
      return (err);
    } else {

    }
#line 2103
    i___0 = i___0 + 1;
    ldv_30921: ;
#line 2103
    if ((unsigned int )i___0 <= 3U) {
#line 2105
      goto ldv_30920;
    } else {

    }
#line 2109
    i___0 = 0;
#line 2109
    goto ldv_30926;
    ldv_30925: 
    {
#line 2110
    tmp___20 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_emu1010_dac_pads) + (unsigned long )i___0),
                            (void *)emu);
#line 2110
    err = snd_ctl_add(card, tmp___20);
    }
#line 2112
    if (err < 0) {
#line 2113
      return (err);
    } else {

    }
#line 2109
    i___0 = i___0 + 1;
    ldv_30926: ;
#line 2109
    if ((unsigned int )i___0 <= 4U) {
#line 2111
      goto ldv_30925;
    } else {

    }
    {
#line 2115
    tmp___21 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_emu1010_internal_clock),
                            (void *)emu);
#line 2115
    err = snd_ctl_add(card, tmp___21);
    }
#line 2117
    if (err < 0) {
#line 2118
      return (err);
    } else {

    }
  } else {

  }
#line 2121
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->i2c_adc) != 0U) {
    {
#line 2124
    tmp___22 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_audigy_i2c_capture_source),
                            (void *)emu);
#line 2124
    err = snd_ctl_add(card, tmp___22);
    }
#line 2125
    if (err < 0) {
#line 2126
      return (err);
    } else {

    }
#line 2128
    i___1 = 0;
#line 2128
    goto ldv_30932;
    ldv_30931: 
    {
#line 2129
    tmp___23 = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& snd_audigy_i2c_volume_ctls) + (unsigned long )i___1),
                            (void *)emu);
#line 2129
    err = snd_ctl_add(card, tmp___23);
    }
#line 2130
    if (err < 0) {
#line 2131
      return (err);
    } else {

    }
#line 2128
    i___1 = i___1 + 1;
    ldv_30932: ;
#line 2128
    if ((unsigned int )i___1 <= 1U) {
#line 2130
      goto ldv_30931;
    } else {

    }

  } else {

  }
#line 2135
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U && emu->audigy != 0U) {
    {
#line 2136
    tmp___24 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_audigy_capture_boost),
                            (void *)emu);
#line 2136
    err = snd_ctl_add(card, tmp___24);
    }
#line 2138
    if (err < 0) {
#line 2139
      return (err);
    } else {

    }
  } else {

  }
#line 2142
  return (0);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_33___6(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_35___3(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 515 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_37___2(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 518
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 520
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 521
  return;
}
}
#line 533 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_39___2(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 536
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 538
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 539
  return;
}
}
#line 551 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_41___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 554
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 556
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 557
  return;
}
}
#line 569 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_43___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 572
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 574
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 575
  return;
}
}
#line 587 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_45___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 590
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 592
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 593
  return;
}
}
#line 605 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_47___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 608
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 610
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 611
  return;
}
}
#line 623 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_49___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 626
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 628
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 629
  return;
}
}
#line 641 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_51___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 644
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 646
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 647
  return;
}
}
#line 659 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_53___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 662
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 664
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 665
  return;
}
}
#line 677 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_55___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 680
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 682
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 683
  return;
}
}
#line 695 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_57___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 698
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 700
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 701
  return;
}
}
#line 713 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_59___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 716
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 718
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 719
  return;
}
}
#line 731 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_61___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 734
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 736
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 737
  return;
}
}
#line 749 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emumixer.c.aux"
static void ldv___ldv_spin_lock_63___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 752
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 754
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 755
  return;
}
}
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 30
long ldv_ptr_err(void const   *ptr ) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/slab.h"
void *ldv_kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 60 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 


  {
#line 68
  __asm__  volatile   (".section .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.previous\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 70
  return;
}
}
#line 315 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 319
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 324
  return (oldbit);
}
}
#line 317 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 88 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 16 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/string.h"
extern void *memdup_user(void const   * , size_t  ) ;
#line 31 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 40
__inline static long IS_ERR(void const   *ptr ) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
static void ldv___ldv_spin_lock_33___7(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___4(spinlock_t *ldv_func_arg1 ) ;
#line 33
static void ldv___ldv_spin_lock_37___3(spinlock_t *ldv_func_arg1 ) ;
#line 37
static void ldv___ldv_spin_lock_39___3(spinlock_t *ldv_func_arg1 ) ;
#line 93
void ldv_spin_lock_irq_lock_of_snd_emu10k1_fx8010(void) ;
#line 94
void ldv_spin_unlock_irq_lock_of_snd_emu10k1_fx8010(void) ;
#line 217 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack ;
#line 219 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
  {
#line 222
  if (8UL == 1UL) {
#line 222
    goto case_1;
  } else {

  }
#line 222
  if (8UL == 2UL) {
#line 222
    goto case_2;
  } else {

  }
#line 222
  if (8UL == 4UL) {
#line 222
    goto case_4;
  } else {

  }
#line 222
  if (8UL == 8UL) {
#line 222
    goto case_8;
  } else {

  }
#line 222
  goto switch_default;
  case_1: /* CIL Label */ 
#line 222
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 222
  goto ldv_6937;
  case_2: /* CIL Label */ 
#line 222
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 222
  goto ldv_6937;
  case_4: /* CIL Label */ 
#line 222
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 222
  goto ldv_6937;
  case_8: /* CIL Label */ 
#line 222
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 222
  goto ldv_6937;
  switch_default: /* CIL Label */ 
  {
#line 222
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_6937: 
#line 222
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 224
  return (ti);
}
}
#line 326 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 330
__inline static void ldv_spin_lock_irq_41(spinlock_t *lock ) ;
#line 334
__inline static void ldv_spin_lock_irq_45___0(spinlock_t *lock ) ;
#line 338
__inline static void ldv_spin_lock_irq_45___0(spinlock_t *lock ) ;
#line 389
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 393
__inline static void ldv_spin_unlock_irq_42(spinlock_t *lock ) ;
#line 397
__inline static void ldv_spin_unlock_irq_46___0(spinlock_t *lock ) ;
#line 401
__inline static void ldv_spin_unlock_irq_46___0(spinlock_t *lock ) ;
#line 422
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 426
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 430
__inline static void ldv_spin_unlock_irqrestore_38___3(spinlock_t *lock , unsigned long flags ) ;
#line 434
__inline static void ldv_spin_unlock_irqrestore_38___3(spinlock_t *lock , unsigned long flags ) ;
#line 81 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 91
extern void down_write(struct rw_semaphore * ) ;
#line 101
extern void up_read(struct rw_semaphore * ) ;
#line 106
extern void up_write(struct rw_semaphore * ) ;
#line 265 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 260 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 349
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 547 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/capability.h"
extern bool capable(int  ) ;
#line 79 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/hwdep.h"
extern int snd_hwdep_new(struct snd_card * , char * , int  , struct snd_hwdep ** ) ;
#line 115 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/control.h"
extern int snd_ctl_remove(struct snd_card * , struct snd_kcontrol * ) ;
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static bool high_res_gpr_volume  ;
#line 62 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static char *fxbuses[16U]  = 
#line 62
  {      (char *)"PCM Left",      (char *)"PCM Right",      (char *)"PCM Surround Left",      (char *)"PCM Surround Right", 
        (char *)"MIDI Left",      (char *)"MIDI Right",      (char *)"Center",      (char *)"LFE", 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)"MIDI Reverb",      (char *)"MIDI Chorus",      (char *)0,      (char *)0};
#line 81 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static char *creative_ins[16U]  = 
#line 81
  {      (char *)"AC97 Left",      (char *)"AC97 Right",      (char *)"TTL IEC958 Left",      (char *)"TTL IEC958 Right", 
        (char *)"Zoom Video Left",      (char *)"Zoom Video Right",      (char *)"Optical IEC958 Left",      (char *)"Optical IEC958 Right", 
        (char *)"Line/Mic 1 Left",      (char *)"Line/Mic 1 Right",      (char *)"Coaxial IEC958 Left",      (char *)"Coaxial IEC958 Right", 
        (char *)"Line/Mic 2 Left",      (char *)"Line/Mic 2 Right",      (char *)0,      (char *)0};
#line 100 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static char *audigy_ins[16U]  = 
#line 100
  {      (char *)"AC97 Left",      (char *)"AC97 Right",      (char *)"Audigy CD Left",      (char *)"Audigy CD Right", 
        (char *)"Optical IEC958 Left",      (char *)"Optical IEC958 Right",      (char *)0,      (char *)0, 
        (char *)"Line/Mic 2 Left",      (char *)"Line/Mic 2 Right",      (char *)"SPDIF Left",      (char *)"SPDIF Right", 
        (char *)"Aux2 Left",      (char *)"Aux2 Right",      (char *)0,      (char *)0};
#line 119 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static char *creative_outs[32U]  = 
#line 119
  {      (char *)"AC97 Left",      (char *)"AC97 Right",      (char *)"Optical IEC958 Left",      (char *)"Optical IEC958 Right", 
        (char *)"Center",      (char *)"LFE",      (char *)"Headphone Left",      (char *)"Headphone Right", 
        (char *)"Surround Left",      (char *)"Surround Right",      (char *)"PCM Capture Left",      (char *)"PCM Capture Right", 
        (char *)"MIC Capture",      (char *)"AC97 Surround Left",      (char *)"AC97 Surround Right",      (char *)0, 
        (char *)0,      (char *)"Analog Center",      (char *)"Analog LFE",      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0};
#line 154 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static char *audigy_outs[32U]  = 
#line 154
  {      (char *)"Digital Front Left",      (char *)"Digital Front Right",      (char *)"Digital Center",      (char *)"Digital LEF", 
        (char *)"Headphone Left",      (char *)"Headphone Right",      (char *)"Digital Rear Left",      (char *)"Digital Rear Right", 
        (char *)"Front Left",      (char *)"Front Right",      (char *)"Center",      (char *)"LFE", 
        (char *)0,      (char *)0,      (char *)"Rear Left",      (char *)"Rear Right", 
        (char *)"AC97 Front Left",      (char *)"AC97 Front Right",      (char *)"ADC Caputre Left",      (char *)"ADC Capture Right", 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0};
#line 189 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static u32 const   bass_table[41U][5U]  = 
#line 189
  { {        1045398607U,        2230144195U,        1019648295U,        2063815994U, 
            3302655110U}, 
   {        1047110010U,        2227339515U,        1020755156U,        2066688623U, 
            3299904797U}, 
   {        1048772418U,        2224656853U,        1021789803U,        2069436358U, 
            3297272814U}, 
   {        1050389308U,        2222090224U,        1022754792U,        2072065376U, 
            3294753324U}, 
   {        1051964021U,        2219633961U,        1023652501U,        2074581532U, 
            3292340795U}, 
   {        1053499764U,        2217282699U,        1024485140U,        2076990371U, 
            3290029989U}, 
   {        1054999627U,        2215031364U,        1025254753U,        2079297143U, 
            3287815951U}, 
   {        1056466584U,        2212875158U,        1025963224U,        2081506816U, 
            3285693989U}, 
   {        1057903504U,        2210809545U,        1026612281U,        2083624088U, 
            3283659671U}, 
   {        1059313163U,        2208830241U,        1027203503U,        2085653404U, 
            3281708804U}, 
   {        1060698244U,        2206933202U,        1027738322U,        2087598965U, 
            3279837425U}, 
   {        1062061356U,        2205114607U,        1028218027U,        2089464742U, 
            3278041790U}, 
   {        1063405032U,        2203370853U,        1028643768U,        2091254486U, 
            3276318363U}, 
   {        1064731743U,        2201698540U,        1029016560U,        2092971743U, 
            3274663804U}, 
   {        1066043907U,        2200094459U,        1029337284U,        2094619863U, 
            3273074955U}, 
   {        1067343892U,        2198555587U,        1029606693U,        2096202010U, 
            3271548837U}, 
   {        1068634030U,        2197079072U,        1029825407U,        2097721174U, 
            3270082634U}, 
   {        1069916620U,        2195662226U,        1029993923U,        2099180180U, 
            3268673686U}, 
   {        1071193941U,        2194302514U,        1030112612U,        2100581697U, 
            3267319481U}, 
   {        1072468256U,        2192997548U,        1030181718U,        2101928248U, 
            3266017646U}, 
   {        1073741824U,        2191745079U,        1030201362U,        2103222217U, 
            3264765934U}, 
   {        1075016903U,        2190542986U,        1030171539U,        2104465859U, 
            3263562226U}, 
   {        1076295767U,        2189389271U,        1030092121U,        2105661308U, 
            3262404515U}, 
   {        1077580703U,        2188282053U,        1029962851U,        2106810580U, 
            3261290902U}, 
   {        1078874031U,        2187219558U,        1029783346U,        2107915586U, 
            3260219590U}, 
   {        1080178106U,        2186200116U,        1029553091U,        2108978135U, 
            3259188878U}, 
   {        1081495327U,        2185222156U,        1029271439U,        2109999940U, 
            3258197154U}, 
   {        1082828150U,        2184284196U,        1028937607U,        2110982626U, 
            3257242889U}, 
   {        1084179094U,        2183384843U,        1028550674U,        2111927733U, 
            3256324632U}, 
   {        1085550752U,        2182522785U,        1028109573U,        2112836725U, 
            3255441008U}, 
   {        1086945802U,        2181696786U,        1027613089U,        2113710989U, 
            3254590709U}, 
   {        1088367014U,        2180905686U,        1027059853U,        2114551848U, 
            3253772490U}, 
   {        1089817265U,        2180148393U,        1026448337U,        2115360555U, 
            3252985170U}, 
   {        1091299546U,        2179423881U,        1025776846U,        2116138308U, 
            3252227620U}, 
   {        1092816977U,        2178731187U,        1025043511U,        2116886246U, 
            3251498768U}, 
   {        1094372816U,        2178069406U,        1024246282U,        2117605454U, 
            3250797587U}, 
   {        1095970471U,        2177437691U,        1023382917U,        2118296971U, 
            3250123098U}, 
   {        1097613517U,        2176835250U,        1022450977U,        2118961788U, 
            3249474367U}, 
   {        1099305706U,        2176261340U,        1021447813U,        2119600851U, 
            3248850496U}, 
   {        1101050981U,        2175715269U,        1020370556U,        2120215070U, 
            3248250627U}, 
   {        1102853491U,        2175196394U,        1019216105U,        2120805314U, 
            3247673936U}};
#line 233 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static u32 const   treble_table[41U][5U]  = 
#line 233
  { {        19254185U,        4275429053U,        5872492U,        220530394U, 
            4203066196U}, 
   {        21165694U,        4272959843U,        6737167U,        219465373U, 
            4203824243U}, 
   {        23275709U,        4270195032U,        7714802U,        218360615U, 
            4204606162U}, 
   {        25605176U,        4267100546U,        8819252U,        217215048U, 
            4205412298U}, 
   {        28177240U,        4263638526U,        10065986U,        216027586U, 
            4206242981U}, 
   {        31017466U,        4259766919U,        11472269U,        214797130U, 
            4207098535U}, 
   {        34154089U,        4255439039U,        13057356U,        213522564U, 
            4207979271U}, 
   {        37618280U,        4250603082U,        14842708U,        212202761U, 
            4208885490U}, 
   {        41444444U,        4245201584U,        16852233U,        210836579U, 
            4209817480U}, 
   {        45670545U,        4239170842U,        19112546U,        209422868U, 
            4210775519U}, 
   {        50338458U,        4232440270U,        21653257U,        207960463U, 
            4211759871U}, 
   {        55494359U,        4224931691U,        24507287U,        206448195U, 
            4212770788U}, 
   {        61189141U,        4216558574U,        27711213U,        204884884U, 
            4213808508U}, 
   {        67478882U,        4207225192U,        31305646U,        203269346U, 
            4214873253U}, 
   {        74425342U,        4196825702U,        35335645U,        201600397U, 
            4215965233U}, 
   {        82096511U,        4185243151U,        39851167U,        199876850U, 
            4217084640U}, 
   {        90567200U,        4172348389U,        44907561U,        198097523U, 
            4218231648U}, 
   {        99919685U,        4157998882U,        50566100U,        196261240U, 
            4219406413U}, 
   {        110244406U,        4142037437U,        56894565U,        194366837U, 
            4220609075U}, 
   {        121640723U,        4124290809U,        63967875U,        192413165U, 
            4221839748U}, 
   {        134217728U,        4104568200U,        71868769U,        190399096U, 
            4223098527U}, 
   {        148095127U,        4082659633U,        80688548U,        188323529U, 
            4224385483U}, 
   {        163404194U,        4058334201U,        90527872U,        186185394U, 
            4225700659U}, 
   {        180288783U,        4031338186U,        101497618U,        183983660U, 
            4227044072U}, 
   {        198906430U,        4001393028U,        113719806U,        181717346U, 
            4228415709U}, 
   {        219429524U,        3968193159U,        127328592U,        179385520U, 
            4229815525U}, 
   {        242046564U,        3931403672U,        142471328U,        176987318U, 
            4231243437U}, 
   {        266963498U,        3890657845U,        159309699U,        174521947U, 
            4232699330U}, 
   {        294405153U,        3845554490U,        178020936U,        171988695U, 
            4234183045U}, 
   {        324616750U,        3795655147U,        198799099U,        169386943U, 
            4235694380U}, 
   {        357865515U,        3740481093U,        221856445U,        166716178U, 
            4237233089U}, 
   {        394442378U,        3679510193U,        247424877U,        163975999U, 
            4238798873U}, 
   {        434663773U,        3612173565U,        275757465U,        161166135U, 
            4240391382U}, 
   {        478873528U,        3537852075U,        307130056U,        158286452U, 
            4242010208U}, 
   {        527444845U,        3455872658U,        341842960U,        155336971U, 
            4243654885U}, 
   {        580782387U,        3365504461U,        380222714U,        152317877U, 
            4245324881U}, 
   {        639324440U,        3265954825U,        422623926U,        149229532U, 
            4247019597U}, 
   {        703545181U,        3156365096U,        469431190U,        146072490U, 
            4248738363U}, 
   {        773957019U,        3035806278U,        521061078U,        142847509U, 
            4250480435U}, 
   {        851113035U,        2903274537U,        577964195U,        139555563U, 
            4252244989U}, 
   {        935609483U,        2757686557U,        640627303U,        136197852U, 
            4254031124U}};
#line 278 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static u32 const   db_table[101U]  = 
#line 278
  {      0U,      22486914U,      23546689U,      24656411U, 
        25818432U,      27035217U,      28309347U,      29643526U, 
        31040582U,      32503480U,      34035322U,      35639357U, 
        37318988U,      39077778U,      40919457U,      42847931U, 
        44867292U,      46981823U,      49196008U,      51514544U, 
        53942350U,      56484575U,      59146611U,      61934104U, 
        64852969U,      67909395U,      71109866U,      74461171U, 
        77970418U,      81645051U,      85492863U,      89522018U, 
        93741061U,      98158941U,      102785029U,      107629138U, 
        112701543U,      118013004U,      123574785U,      129398685U, 
        135497057U,      141882837U,      148569569U,      155571437U, 
        162903293U,      170580689U,      178619909U,      187038006U, 
        195852836U,      205083096U,      214748364U,      224869143U, 
        235466899U,      246564112U,      258184321U,      270352173U, 
        283093478U,      296435263U,      310405827U,      325034803U, 
        340353221U,      356393574U,      373189886U,      390777783U, 
        409194573U,      428479319U,      448672927U,      469818231U, 
        491960082U,      515145446U,      539423503U,      564845750U, 
        591466110U,      619341049U,      648529693U,      679093956U, 
        711098668U,      744611716U,      779704185U,      816450511U, 
        854928638U,      895220184U,      937410611U,      981589412U, 
        1027850296U,      1076291388U,      1127015439U,      1180130040U, 
        1235747855U,      1293986858U,      1354970579U,      1418828375U, 
        1485695697U,      1555714378U,      1629032938U,      1705806895U, 
        1786199097U,      1870380067U,      1958528364U,      2050830962U, 
        2147483647U};
#line 303 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static unsigned int const   snd_emu10k1_db_scale1[4U]  = {      1U,      8U,      4294963296U,      65576U};
#line 304 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static unsigned int const   snd_emu10k1_db_linear[4U]  = {      2U,      8U,      4284967297U,      0U};
#line 307 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static unsigned int const   snd_emu10k1_bass_treble_db_scale[4U]  = {      1U,      8U,      4294966096U,      60U};
#line 309 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static u32 const   onoff_table[2U]  = {      0U,      1U};
#line 316 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
__inline static mm_segment_t snd_enter_user(void) 
{ 
  mm_segment_t fs ;
  struct thread_info *tmp ;
  struct thread_info *tmp___0 ;
  mm_segment_t __constr_expr_0 ;

  {
  {
#line 318
  tmp = current_thread_info();
#line 318
  fs = tmp->addr_limit;
#line 319
  tmp___0 = current_thread_info();
#line 319
  __constr_expr_0.seg = 0xffffffffffffffffUL;
#line 319
  tmp___0->addr_limit = __constr_expr_0;
  }
#line 320
  return (fs);
}
}
#line 323 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
__inline static void snd_leave_user(mm_segment_t fs ) 
{ 
  struct thread_info *tmp ;

  {
  {
#line 325
  tmp = current_thread_info();
#line 325
  tmp->addr_limit = fs;
  }
#line 326
  return;
}
}
#line 332 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_gpr_ctl_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct snd_emu10k1_fx8010_ctl *ctl ;

  {
#line 334
  ctl = (struct snd_emu10k1_fx8010_ctl *)kcontrol->private_value;
#line 337
  if (*((unsigned long *)ctl + 27UL) == 4294967296UL) {
#line 338
    uinfo->type = 1;
  } else {
#line 340
    uinfo->type = 2;
  }
#line 341
  uinfo->count = ctl->vcount;
#line 342
  uinfo->value.integer.min = (long )ctl->min;
#line 343
  uinfo->value.integer.max = (long )ctl->max;
#line 344
  return (0);
}
}
#line 347 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_gpr_ctl_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_ctl *ctl ;
  unsigned long flags ;
  unsigned int i ;

  {
  {
#line 349
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 350
  ctl = (struct snd_emu10k1_fx8010_ctl *)kcontrol->private_value;
#line 355
  ldv___ldv_spin_lock_33___7(& emu->reg_lock);
#line 356
  i = 0U;
  }
#line 356
  goto ldv_30499;
  ldv_30498: 
#line 357
  ucontrol->value.integer.value[i] = (long )ctl->value[i];
#line 356
  i = i + 1U;
  ldv_30499: ;
#line 356
  if (i < ctl->vcount) {
#line 358
    goto ldv_30498;
  } else {

  }
  {
#line 358
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 359
  return (0);
}
}
#line 362 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_gpr_ctl_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_ctl *ctl ;
  unsigned long flags ;
  unsigned int nval ;
  unsigned int val ;
  unsigned int i ;
  unsigned int j ;
  int change ;
  unsigned int tmp ;

  {
  {
#line 364
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 365
  ctl = (struct snd_emu10k1_fx8010_ctl *)kcontrol->private_value;
#line 370
  change = 0;
#line 372
  ldv___ldv_spin_lock_35___4(& emu->reg_lock);
#line 373
  i = 0U;
  }
#line 373
  goto ldv_30527;
  ldv_30526: 
#line 374
  nval = (unsigned int )ucontrol->value.integer.value[i];
#line 375
  if (nval < ctl->min) {
#line 376
    nval = ctl->min;
  } else {

  }
#line 377
  if (nval > ctl->max) {
#line 378
    nval = ctl->max;
  } else {

  }
#line 379
  if (nval != ctl->value[i]) {
#line 380
    change = 1;
  } else {

  }
#line 381
  tmp = nval;
#line 381
  ctl->value[i] = tmp;
#line 381
  val = tmp;
  {
#line 383
  if (ctl->translation == 0U) {
#line 383
    goto case_0;
  } else {

  }
#line 386
  if (ctl->translation == 1U) {
#line 386
    goto case_1;
  } else {

  }
#line 389
  if (ctl->translation == 2U) {
#line 389
    goto case_2;
  } else {

  }
#line 397
  if (ctl->translation == 3U) {
#line 397
    goto case_3;
  } else {

  }
#line 405
  if (ctl->translation == 4U) {
#line 405
    goto case_4;
  } else {

  }
#line 382
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 384
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )ctl->gpr[i]), 0U,
                        val);
  }
#line 385
  goto ldv_30514;
  case_1: /* CIL Label */ 
  {
#line 387
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )ctl->gpr[i]), 0U,
                        db_table[val]);
  }
#line 388
  goto ldv_30514;
  case_2: /* CIL Label */ ;
#line 390
  if (ctl->count % 5U != 0U || ctl->count / 5U != ctl->vcount) {
#line 391
    change = -5;
#line 392
    goto __error;
  } else {

  }
#line 394
  j = 0U;
#line 394
  goto ldv_30519;
  ldv_30518: 
  {
#line 395
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )ctl->gpr[j * ctl->vcount + i]),
                        0U, bass_table[val][j]);
#line 394
  j = j + 1U;
  }
  ldv_30519: ;
#line 394
  if (j <= 4U) {
#line 396
    goto ldv_30518;
  } else {

  }

#line 396
  goto ldv_30514;
  case_3: /* CIL Label */ ;
#line 398
  if (ctl->count % 5U != 0U || ctl->count / 5U != ctl->vcount) {
#line 399
    change = -5;
#line 400
    goto __error;
  } else {

  }
#line 402
  j = 0U;
#line 402
  goto ldv_30523;
  ldv_30522: 
  {
#line 403
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )ctl->gpr[j * ctl->vcount + i]),
                        0U, treble_table[val][j]);
#line 402
  j = j + 1U;
  }
  ldv_30523: ;
#line 402
  if (j <= 4U) {
#line 404
    goto ldv_30522;
  } else {

  }

#line 404
  goto ldv_30514;
  case_4: /* CIL Label */ 
  {
#line 406
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )ctl->gpr[i]), 0U,
                        onoff_table[val]);
  }
#line 407
  goto ldv_30514;
  switch_break: /* CIL Label */ ;
  }
  ldv_30514: 
#line 373
  i = i + 1U;
  ldv_30527: ;
#line 373
  if (i < ctl->vcount) {
#line 375
    goto ldv_30526;
  } else {

  }

  __error: 
  {
#line 411
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 412
  return (change);
}
}
#line 419 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_fx8010_interrupt(struct snd_emu10k1 *emu ) 
{ 
  struct snd_emu10k1_fx8010_irq *irq ;
  struct snd_emu10k1_fx8010_irq *nirq ;
  unsigned int tmp ;

  {
#line 423
  irq = emu->fx8010.irq_handlers;
#line 424
  goto ldv_30535;
  ldv_30534: 
  {
#line 425
  nirq = irq->next;
#line 426
  tmp = snd_emu10k1_ptr_read(emu, (unsigned int )(emu->gpr_base + (int )irq->gpr_running),
                             0U);
  }
#line 426
  if ((tmp & 4294901760U) != 0U) {
#line 427
    if ((unsigned long )irq->handler != (unsigned long )((snd_fx8010_irq_handler_t *)0)) {
      {
#line 428
      (*(irq->handler))(emu, irq->private_data);
      }
    } else {

    }
    {
#line 429
    snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + (int )irq->gpr_running),
                          0U, 1U);
    }
  } else {

  }
#line 431
  irq = nirq;
  ldv_30535: ;
#line 424
  if ((unsigned long )irq != (unsigned long )((struct snd_emu10k1_fx8010_irq *)0)) {
#line 426
    goto ldv_30534;
  } else {

  }

#line 431
  return;
}
}
#line 435 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
int snd_emu10k1_fx8010_register_irq_handler(struct snd_emu10k1 *emu , snd_fx8010_irq_handler_t *handler ,
                                            unsigned char gpr_running , void *private_data ,
                                            struct snd_emu10k1_fx8010_irq **r_irq ) 
{ 
  struct snd_emu10k1_fx8010_irq *irq ;
  unsigned long flags ;
  void *tmp ;

  {
  {
#line 444
  tmp = kmalloc(32UL, 32U);
#line 444
  irq = (struct snd_emu10k1_fx8010_irq *)tmp;
  }
#line 445
  if ((unsigned long )irq == (unsigned long )((struct snd_emu10k1_fx8010_irq *)0)) {
#line 446
    return (-12);
  } else {

  }
  {
#line 447
  irq->handler = handler;
#line 448
  irq->gpr_running = (unsigned short )gpr_running;
#line 449
  irq->private_data = private_data;
#line 450
  irq->next = (struct snd_emu10k1_fx8010_irq *)0;
#line 451
  ldv___ldv_spin_lock_37___3(& emu->fx8010.irq_lock);
  }
#line 452
  if ((unsigned long )emu->fx8010.irq_handlers == (unsigned long )((struct snd_emu10k1_fx8010_irq *)0)) {
    {
#line 453
    emu->fx8010.irq_handlers = irq;
#line 454
    emu->dsp_interrupt = & snd_emu10k1_fx8010_interrupt;
#line 455
    snd_emu10k1_intr_enable(emu, 4096U);
    }
  } else {
#line 457
    irq->next = emu->fx8010.irq_handlers;
#line 458
    emu->fx8010.irq_handlers = irq;
  }
  {
#line 460
  ldv_spin_unlock_irqrestore_38___3(& emu->fx8010.irq_lock, flags);
  }
#line 461
  if ((unsigned long )r_irq != (unsigned long )((struct snd_emu10k1_fx8010_irq **)0)) {
#line 462
    *r_irq = irq;
  } else {

  }
#line 463
  return (0);
}
}
#line 466 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
int snd_emu10k1_fx8010_unregister_irq_handler(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_irq *irq ) 
{ 
  struct snd_emu10k1_fx8010_irq *tmp ;
  unsigned long flags ;

  {
  {
#line 472
  ldv___ldv_spin_lock_39___3(& emu->fx8010.irq_lock);
#line 473
  tmp = emu->fx8010.irq_handlers;
  }
#line 473
  if ((unsigned long )tmp == (unsigned long )irq) {
#line 474
    emu->fx8010.irq_handlers = tmp->next;
#line 475
    if ((unsigned long )emu->fx8010.irq_handlers == (unsigned long )((struct snd_emu10k1_fx8010_irq *)0)) {
      {
#line 476
      snd_emu10k1_intr_disable(emu, 4096U);
#line 477
      emu->dsp_interrupt = (void (*)(struct snd_emu10k1 * ))0;
      }
    } else {

    }
  } else {
#line 480
    goto ldv_30553;
    ldv_30552: 
#line 481
    tmp = tmp->next;
    ldv_30553: ;
#line 480
    if ((unsigned long )tmp != (unsigned long )((struct snd_emu10k1_fx8010_irq *)0) && (unsigned long )tmp->next != (unsigned long )irq) {
#line 482
      goto ldv_30552;
    } else {

    }

#line 482
    if ((unsigned long )tmp != (unsigned long )((struct snd_emu10k1_fx8010_irq *)0)) {
#line 483
      tmp->next = (tmp->next)->next;
    } else {

    }
  }
  {
#line 485
  ldv_spin_unlock_irqrestore_38___3(& emu->fx8010.irq_lock, flags);
#line 486
  kfree((void const   *)irq);
  }
#line 487
  return (0);
}
}
#line 494 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_write_op(struct snd_emu10k1_fx8010_code *icode , unsigned int *ptr ,
                                 u32 op , u32 r , u32 a , u32 x , u32 y ) 
{ 
  u_int32_t *code ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 499
  __ret_warn_on = *ptr > 511U;
#line 499
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 499
  if (tmp != 0L) {
    {
#line 499
    warn_slowpath_fmt("sound/pci/emu10k1/emufx.c", 499, "BUG? (%s)\n", (char *)"*ptr >= 512");
    }
  } else {

  }
  {
#line 499
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 499
  if (tmp___0 != 0L) {
#line 500
    return;
  } else {

  }
  {
#line 501
  code = icode->code + (unsigned long )(*ptr * 2U);
#line 502
  set_bit(*ptr, (unsigned long volatile   *)(& icode->code_valid));
#line 503
  *code = ((x & 1023U) << 10) | (y & 1023U);
#line 504
  *(code + 1UL) = (((op & 15U) << 20) | ((r & 1023U) << 10)) | (a & 1023U);
#line 505
  *ptr = *ptr + 1U;
  }
#line 506
  return;
}
}
#line 511 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_audigy_write_op(struct snd_emu10k1_fx8010_code *icode , unsigned int *ptr ,
                                        u32 op , u32 r , u32 a , u32 x , u32 y ) 
{ 
  u_int32_t *code ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 516
  __ret_warn_on = *ptr > 1023U;
#line 516
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 516
  if (tmp != 0L) {
    {
#line 516
    warn_slowpath_fmt("sound/pci/emu10k1/emufx.c", 516, "BUG? (%s)\n", (char *)"*ptr >= 1024");
    }
  } else {

  }
  {
#line 516
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 516
  if (tmp___0 != 0L) {
#line 517
    return;
  } else {

  }
  {
#line 518
  code = icode->code + (unsigned long )(*ptr * 2U);
#line 519
  set_bit(*ptr, (unsigned long volatile   *)(& icode->code_valid));
#line 520
  *code = ((x & 2047U) << 12) | (y & 2047U);
#line 521
  *(code + 1UL) = (((op & 15U) << 24) | ((r & 2047U) << 12)) | (a & 2047U);
#line 522
  *ptr = *ptr + 1U;
  }
#line 523
  return;
}
}
#line 528 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_efx_write(struct snd_emu10k1 *emu , unsigned int pc , unsigned int data ) 
{ 


  {
  {
#line 530
  pc = pc + (emu->audigy != 0U ? 1536U : 1024U);
#line 531
  snd_emu10k1_ptr_write(emu, pc, 0U, data);
  }
#line 532
  return;
}
}
#line 534 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
unsigned int snd_emu10k1_efx_read(struct snd_emu10k1 *emu , unsigned int pc ) 
{ 
  unsigned int tmp ;

  {
  {
#line 536
  pc = pc + (emu->audigy != 0U ? 1536U : 1024U);
#line 537
  tmp = snd_emu10k1_ptr_read(emu, pc, 0U);
  }
#line 537
  return (tmp);
}
}
#line 540 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_gpr_poke(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  int gpr ;
  u32 val ;
  int tmp___0 ;
  int __ret_gu ;
  unsigned long __val_gu ;

  {
#line 546
  gpr = 0;
#line 546
  goto ldv_30605;
  ldv_30604: 
  {
#line 547
  tmp___0 = variable_test_bit(gpr, (unsigned long const volatile   *)(& icode->gpr_valid));
  }
#line 547
  if (tmp___0 == 0) {
#line 548
    goto ldv_30594;
  } else {

  }
  {
#line 549
  might_fault();
  }
  {
#line 549
  if (4UL == 1UL) {
#line 549
    goto case_1;
  } else {

  }
#line 549
  if (4UL == 2UL) {
#line 549
    goto case_2;
  } else {

  }
#line 549
  if (4UL == 4UL) {
#line 549
    goto case_4;
  } else {

  }
#line 549
  if (4UL == 8UL) {
#line 549
    goto case_8;
  } else {

  }
#line 549
  goto switch_default;
  case_1: /* CIL Label */ 
#line 549
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->gpr_map + (unsigned long )gpr));
#line 549
  goto ldv_30598;
  case_2: /* CIL Label */ 
#line 549
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->gpr_map + (unsigned long )gpr));
#line 549
  goto ldv_30598;
  case_4: /* CIL Label */ 
#line 549
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->gpr_map + (unsigned long )gpr));
#line 549
  goto ldv_30598;
  case_8: /* CIL Label */ 
#line 549
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->gpr_map + (unsigned long )gpr));
#line 549
  goto ldv_30598;
  switch_default: /* CIL Label */ 
#line 549
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->gpr_map + (unsigned long )gpr));
#line 549
  goto ldv_30598;
  switch_break: /* CIL Label */ ;
  }
  ldv_30598: 
#line 549
  val = (unsigned int )__val_gu;
#line 549
  if (__ret_gu != 0) {
#line 550
    return (-14);
  } else {

  }
  {
#line 551
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + gpr), 0U, val);
  }
  ldv_30594: 
#line 546
  gpr = gpr + 1;
  ldv_30605: ;
#line 546
  if (gpr < (emu->audigy != 0U ? 512 : 256)) {
#line 548
    goto ldv_30604;
  } else {

  }

#line 553
  return (0);
}
}
#line 556 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_gpr_peek(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  int gpr ;
  u32 val ;
  int __ret_pu ;
  __u32 __pu_val ;

  {
#line 562
  gpr = 0;
#line 562
  goto ldv_30623;
  ldv_30622: 
  {
#line 563
  set_bit((unsigned int )gpr, (unsigned long volatile   *)(& icode->gpr_valid));
#line 564
  val = snd_emu10k1_ptr_read(emu, (unsigned int )(emu->gpr_base + gpr), 0U);
#line 565
  might_fault();
#line 565
  __pu_val = val;
  }
  {
#line 565
  if (4UL == 1UL) {
#line 565
    goto case_1;
  } else {

  }
#line 565
  if (4UL == 2UL) {
#line 565
    goto case_2;
  } else {

  }
#line 565
  if (4UL == 4UL) {
#line 565
    goto case_4;
  } else {

  }
#line 565
  if (4UL == 8UL) {
#line 565
    goto case_8;
  } else {

  }
#line 565
  goto switch_default;
  case_1: /* CIL Label */ 
#line 565
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->gpr_map + (unsigned long )gpr): "ebx");
#line 565
  goto ldv_30616;
  case_2: /* CIL Label */ 
#line 565
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->gpr_map + (unsigned long )gpr): "ebx");
#line 565
  goto ldv_30616;
  case_4: /* CIL Label */ 
#line 565
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->gpr_map + (unsigned long )gpr): "ebx");
#line 565
  goto ldv_30616;
  case_8: /* CIL Label */ 
#line 565
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->gpr_map + (unsigned long )gpr): "ebx");
#line 565
  goto ldv_30616;
  switch_default: /* CIL Label */ 
#line 565
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->gpr_map + (unsigned long )gpr): "ebx");
#line 565
  goto ldv_30616;
  switch_break: /* CIL Label */ ;
  }
  ldv_30616: ;
#line 565
  if (__ret_pu != 0) {
#line 566
    return (-14);
  } else {

  }
#line 562
  gpr = gpr + 1;
  ldv_30623: ;
#line 562
  if (gpr < (emu->audigy != 0U ? 512 : 256)) {
#line 564
    goto ldv_30622;
  } else {

  }

#line 568
  return (0);
}
}
#line 571 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_tram_poke(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  int tram ;
  u32 addr ;
  u32 val ;
  int tmp___0 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;

  {
#line 577
  tram = 0;
#line 577
  goto ldv_30652;
  ldv_30651: 
  {
#line 578
  tmp___0 = variable_test_bit(tram, (unsigned long const volatile   *)(& icode->tram_valid));
  }
#line 578
  if (tmp___0 == 0) {
#line 579
    goto ldv_30632;
  } else {

  }
  {
#line 580
  might_fault();
  }
  {
#line 580
  if (4UL == 1UL) {
#line 580
    goto case_1;
  } else {

  }
#line 580
  if (4UL == 2UL) {
#line 580
    goto case_2;
  } else {

  }
#line 580
  if (4UL == 4UL) {
#line 580
    goto case_4;
  } else {

  }
#line 580
  if (4UL == 8UL) {
#line 580
    goto case_8;
  } else {

  }
#line 580
  goto switch_default;
  case_1: /* CIL Label */ 
#line 580
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->tram_data_map + (unsigned long )tram));
#line 580
  goto ldv_30636;
  case_2: /* CIL Label */ 
#line 580
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->tram_data_map + (unsigned long )tram));
#line 580
  goto ldv_30636;
  case_4: /* CIL Label */ 
#line 580
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->tram_data_map + (unsigned long )tram));
#line 580
  goto ldv_30636;
  case_8: /* CIL Label */ 
#line 580
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->tram_data_map + (unsigned long )tram));
#line 580
  goto ldv_30636;
  switch_default: /* CIL Label */ 
#line 580
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->tram_data_map + (unsigned long )tram));
#line 580
  goto ldv_30636;
  switch_break: /* CIL Label */ ;
  }
  ldv_30636: 
#line 580
  val = (unsigned int )__val_gu;
#line 581
  if (__ret_gu != 0) {
#line 582
    return (-14);
  } else {
    {
#line 581
    might_fault();
    }
    {
#line 581
    if (4UL == 1UL) {
#line 581
      goto case_1___0;
    } else {

    }
#line 581
    if (4UL == 2UL) {
#line 581
      goto case_2___0;
    } else {

    }
#line 581
    if (4UL == 4UL) {
#line 581
      goto case_4___0;
    } else {

    }
#line 581
    if (4UL == 8UL) {
#line 581
      goto case_8___0;
    } else {

    }
#line 581
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 581
    __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->tram_addr_map + (unsigned long )tram));
#line 581
    goto ldv_30645;
    case_2___0: /* CIL Label */ 
#line 581
    __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->tram_addr_map + (unsigned long )tram));
#line 581
    goto ldv_30645;
    case_4___0: /* CIL Label */ 
#line 581
    __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->tram_addr_map + (unsigned long )tram));
#line 581
    goto ldv_30645;
    case_8___0: /* CIL Label */ 
#line 581
    __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->tram_addr_map + (unsigned long )tram));
#line 581
    goto ldv_30645;
    switch_default___0: /* CIL Label */ 
#line 581
    __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->tram_addr_map + (unsigned long )tram));
#line 581
    goto ldv_30645;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_30645: 
#line 581
    addr = (unsigned int )__val_gu___0;
#line 581
    if (__ret_gu___0 != 0) {
#line 582
      return (-14);
    } else {

    }
  }
  {
#line 583
  snd_emu10k1_ptr_write(emu, (unsigned int )(tram + 512), 0U, val);
  }
#line 584
  if (emu->audigy == 0U) {
    {
#line 585
    snd_emu10k1_ptr_write(emu, (unsigned int )(tram + 768), 0U, addr);
    }
  } else {
    {
#line 587
    snd_emu10k1_ptr_write(emu, (unsigned int )(tram + 768), 0U, addr << 12);
#line 588
    snd_emu10k1_ptr_write(emu, (unsigned int )(tram + 256), 0U, addr >> 20);
    }
  }
  ldv_30632: 
#line 577
  tram = tram + 1;
  ldv_30652: ;
#line 577
  if (tram < (emu->audigy != 0U ? 256 : 160)) {
#line 579
    goto ldv_30651;
  } else {

  }

#line 591
  return (0);
}
}
#line 594 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_tram_peek(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  int tram ;
  u32 val ;
  u32 addr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int __ret_pu ;
  __u32 __pu_val ;
  int __ret_pu___0 ;
  __u32 __pu_val___0 ;

  {
  {
#line 600
  memset((void *)(& icode->tram_valid), 0, 32UL);
#line 601
  tram = 0;
  }
#line 601
  goto ldv_30680;
  ldv_30679: 
  {
#line 602
  set_bit((unsigned int )tram, (unsigned long volatile   *)(& icode->tram_valid));
#line 603
  val = snd_emu10k1_ptr_read(emu, (unsigned int )(tram + 512), 0U);
  }
#line 604
  if (emu->audigy == 0U) {
    {
#line 605
    addr = snd_emu10k1_ptr_read(emu, (unsigned int )(tram + 768), 0U);
    }
  } else {
    {
#line 607
    tmp = snd_emu10k1_ptr_read(emu, (unsigned int )(tram + 768), 0U);
#line 607
    addr = tmp >> 12;
#line 608
    tmp___0 = snd_emu10k1_ptr_read(emu, (unsigned int )(tram + 256), 0U);
#line 608
    addr = addr | (tmp___0 << 20);
    }
  }
  {
#line 610
  might_fault();
#line 610
  __pu_val = val;
  }
  {
#line 610
  if (4UL == 1UL) {
#line 610
    goto case_1;
  } else {

  }
#line 610
  if (4UL == 2UL) {
#line 610
    goto case_2;
  } else {

  }
#line 610
  if (4UL == 4UL) {
#line 610
    goto case_4;
  } else {

  }
#line 610
  if (4UL == 8UL) {
#line 610
    goto case_8;
  } else {

  }
#line 610
  goto switch_default;
  case_1: /* CIL Label */ 
#line 610
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->tram_data_map + (unsigned long )tram): "ebx");
#line 610
  goto ldv_30664;
  case_2: /* CIL Label */ 
#line 610
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->tram_data_map + (unsigned long )tram): "ebx");
#line 610
  goto ldv_30664;
  case_4: /* CIL Label */ 
#line 610
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->tram_data_map + (unsigned long )tram): "ebx");
#line 610
  goto ldv_30664;
  case_8: /* CIL Label */ 
#line 610
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->tram_data_map + (unsigned long )tram): "ebx");
#line 610
  goto ldv_30664;
  switch_default: /* CIL Label */ 
#line 610
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->tram_data_map + (unsigned long )tram): "ebx");
#line 610
  goto ldv_30664;
  switch_break: /* CIL Label */ ;
  }
  ldv_30664: ;
#line 611
  if (__ret_pu != 0) {
#line 612
    return (-14);
  } else {
    {
#line 611
    might_fault();
#line 611
    __pu_val___0 = addr;
    }
    {
#line 611
    if (4UL == 1UL) {
#line 611
      goto case_1___0;
    } else {

    }
#line 611
    if (4UL == 2UL) {
#line 611
      goto case_2___0;
    } else {

    }
#line 611
    if (4UL == 4UL) {
#line 611
      goto case_4___0;
    } else {

    }
#line 611
    if (4UL == 8UL) {
#line 611
      goto case_8___0;
    } else {

    }
#line 611
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 611
    __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" (__pu_val___0),
                         "c" (icode->tram_addr_map + (unsigned long )tram): "ebx");
#line 611
    goto ldv_30673;
    case_2___0: /* CIL Label */ 
#line 611
    __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" (__pu_val___0),
                         "c" (icode->tram_addr_map + (unsigned long )tram): "ebx");
#line 611
    goto ldv_30673;
    case_4___0: /* CIL Label */ 
#line 611
    __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" (__pu_val___0),
                         "c" (icode->tram_addr_map + (unsigned long )tram): "ebx");
#line 611
    goto ldv_30673;
    case_8___0: /* CIL Label */ 
#line 611
    __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "0" (__pu_val___0),
                         "c" (icode->tram_addr_map + (unsigned long )tram): "ebx");
#line 611
    goto ldv_30673;
    switch_default___0: /* CIL Label */ 
#line 611
    __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "0" (__pu_val___0),
                         "c" (icode->tram_addr_map + (unsigned long )tram): "ebx");
#line 611
    goto ldv_30673;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_30673: ;
#line 611
    if (__ret_pu___0 != 0) {
#line 612
      return (-14);
    } else {

    }
  }
#line 601
  tram = tram + 1;
  ldv_30680: ;
#line 601
  if (tram < (emu->audigy != 0U ? 256 : 160)) {
#line 603
    goto ldv_30679;
  } else {

  }

#line 614
  return (0);
}
}
#line 617 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_code_poke(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  u32 pc ;
  u32 lo ;
  u32 hi ;
  int tmp___0 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;

  {
#line 622
  pc = 0U;
#line 622
  goto ldv_30709;
  ldv_30708: 
  {
#line 623
  tmp___0 = variable_test_bit((int )(pc / 2U), (unsigned long const volatile   *)(& icode->code_valid));
  }
#line 623
  if (tmp___0 == 0) {
#line 624
    goto ldv_30689;
  } else {

  }
  {
#line 625
  might_fault();
  }
  {
#line 625
  if (4UL == 1UL) {
#line 625
    goto case_1;
  } else {

  }
#line 625
  if (4UL == 2UL) {
#line 625
    goto case_2;
  } else {

  }
#line 625
  if (4UL == 4UL) {
#line 625
    goto case_4;
  } else {

  }
#line 625
  if (4UL == 8UL) {
#line 625
    goto case_8;
  } else {

  }
#line 625
  goto switch_default;
  case_1: /* CIL Label */ 
#line 625
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->code + (unsigned long )pc));
#line 625
  goto ldv_30693;
  case_2: /* CIL Label */ 
#line 625
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->code + (unsigned long )pc));
#line 625
  goto ldv_30693;
  case_4: /* CIL Label */ 
#line 625
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->code + (unsigned long )pc));
#line 625
  goto ldv_30693;
  case_8: /* CIL Label */ 
#line 625
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->code + (unsigned long )pc));
#line 625
  goto ldv_30693;
  switch_default: /* CIL Label */ 
#line 625
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (icode->code + (unsigned long )pc));
#line 625
  goto ldv_30693;
  switch_break: /* CIL Label */ ;
  }
  ldv_30693: 
#line 625
  lo = (unsigned int )__val_gu;
#line 626
  if (__ret_gu != 0) {
#line 627
    return (-14);
  } else {
    {
#line 626
    might_fault();
    }
    {
#line 626
    if (4UL == 1UL) {
#line 626
      goto case_1___0;
    } else {

    }
#line 626
    if (4UL == 2UL) {
#line 626
      goto case_2___0;
    } else {

    }
#line 626
    if (4UL == 4UL) {
#line 626
      goto case_4___0;
    } else {

    }
#line 626
    if (4UL == 8UL) {
#line 626
      goto case_8___0;
    } else {

    }
#line 626
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 626
    __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->code + (unsigned long )(pc + 1U)));
#line 626
    goto ldv_30702;
    case_2___0: /* CIL Label */ 
#line 626
    __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->code + (unsigned long )(pc + 1U)));
#line 626
    goto ldv_30702;
    case_4___0: /* CIL Label */ 
#line 626
    __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->code + (unsigned long )(pc + 1U)));
#line 626
    goto ldv_30702;
    case_8___0: /* CIL Label */ 
#line 626
    __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->code + (unsigned long )(pc + 1U)));
#line 626
    goto ldv_30702;
    switch_default___0: /* CIL Label */ 
#line 626
    __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (icode->code + (unsigned long )(pc + 1U)));
#line 626
    goto ldv_30702;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_30702: 
#line 626
    hi = (unsigned int )__val_gu___0;
#line 626
    if (__ret_gu___0 != 0) {
#line 627
      return (-14);
    } else {

    }
  }
  {
#line 628
  snd_emu10k1_efx_write(emu, pc, lo);
#line 629
  snd_emu10k1_efx_write(emu, pc + 1U, hi);
  }
  ldv_30689: 
#line 622
  pc = pc + 2U;
  ldv_30709: ;
#line 622
  if (pc < (emu->audigy != 0U ? 2048U : 1024U)) {
#line 624
    goto ldv_30708;
  } else {

  }

#line 631
  return (0);
}
}
#line 634 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_code_peek(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  u32 pc ;
  int __ret_pu ;
  __u32 __pu_val ;
  int __ret_pu___0 ;
  __u32 __pu_val___0 ;

  {
  {
#line 639
  memset((void *)(& icode->code_valid), 0, 128UL);
#line 640
  pc = 0U;
  }
#line 640
  goto ldv_30735;
  ldv_30734: 
  {
#line 641
  set_bit(pc / 2U, (unsigned long volatile   *)(& icode->code_valid));
#line 642
  might_fault();
#line 642
  __pu_val = snd_emu10k1_efx_read(emu, pc);
  }
  {
#line 642
  if (4UL == 1UL) {
#line 642
    goto case_1;
  } else {

  }
#line 642
  if (4UL == 2UL) {
#line 642
    goto case_2;
  } else {

  }
#line 642
  if (4UL == 4UL) {
#line 642
    goto case_4;
  } else {

  }
#line 642
  if (4UL == 8UL) {
#line 642
    goto case_8;
  } else {

  }
#line 642
  goto switch_default;
  case_1: /* CIL Label */ 
#line 642
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->code + (unsigned long )pc): "ebx");
#line 642
  goto ldv_30719;
  case_2: /* CIL Label */ 
#line 642
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->code + (unsigned long )pc): "ebx");
#line 642
  goto ldv_30719;
  case_4: /* CIL Label */ 
#line 642
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->code + (unsigned long )pc): "ebx");
#line 642
  goto ldv_30719;
  case_8: /* CIL Label */ 
#line 642
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->code + (unsigned long )pc): "ebx");
#line 642
  goto ldv_30719;
  switch_default: /* CIL Label */ 
#line 642
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" (icode->code + (unsigned long )pc): "ebx");
#line 642
  goto ldv_30719;
  switch_break: /* CIL Label */ ;
  }
  ldv_30719: ;
#line 642
  if (__ret_pu != 0) {
#line 643
    return (-14);
  } else {

  }
  {
#line 644
  might_fault();
#line 644
  __pu_val___0 = snd_emu10k1_efx_read(emu, pc + 1U);
  }
  {
#line 644
  if (4UL == 1UL) {
#line 644
    goto case_1___0;
  } else {

  }
#line 644
  if (4UL == 2UL) {
#line 644
    goto case_2___0;
  } else {

  }
#line 644
  if (4UL == 4UL) {
#line 644
    goto case_4___0;
  } else {

  }
#line 644
  if (4UL == 8UL) {
#line 644
    goto case_8___0;
  } else {

  }
#line 644
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 644
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" (icode->code + (unsigned long )(pc + 1U)): "ebx");
#line 644
  goto ldv_30728;
  case_2___0: /* CIL Label */ 
#line 644
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" (icode->code + (unsigned long )(pc + 1U)): "ebx");
#line 644
  goto ldv_30728;
  case_4___0: /* CIL Label */ 
#line 644
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" (icode->code + (unsigned long )(pc + 1U)): "ebx");
#line 644
  goto ldv_30728;
  case_8___0: /* CIL Label */ 
#line 644
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" (icode->code + (unsigned long )(pc + 1U)): "ebx");
#line 644
  goto ldv_30728;
  switch_default___0: /* CIL Label */ 
#line 644
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" (icode->code + (unsigned long )(pc + 1U)): "ebx");
#line 644
  goto ldv_30728;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_30728: ;
#line 644
  if (__ret_pu___0 != 0) {
#line 645
    return (-14);
  } else {

  }
#line 640
  pc = pc + 2U;
  ldv_30735: ;
#line 640
  if (pc < (emu->audigy != 0U ? 2048U : 1024U)) {
#line 642
    goto ldv_30734;
  } else {

  }

#line 647
  return (0);
}
}
#line 651 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static struct snd_emu10k1_fx8010_ctl *snd_emu10k1_look_for_ctl(struct snd_emu10k1 *emu ,
                                                               struct snd_ctl_elem_id *id___0 ) 
{ 
  struct snd_emu10k1_fx8010_ctl *ctl ;
  struct snd_kcontrol *kcontrol ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 656
  __mptr = (struct list_head  const  *)emu->fx8010.gpr_ctl.next;
#line 656
  ctl = (struct snd_emu10k1_fx8010_ctl *)__mptr;
#line 656
  goto ldv_30748;
  ldv_30747: 
#line 657
  kcontrol = ctl->kcontrol;
#line 658
  if (kcontrol->id.iface == id___0->iface) {
    {
#line 658
    tmp = strcmp((char const   *)(& kcontrol->id.name), (char const   *)(& id___0->name));
    }
#line 658
    if (tmp == 0) {
#line 658
      if (kcontrol->id.index == id___0->index) {
#line 661
        return (ctl);
      } else {

      }
    } else {

    }
  } else {

  }
#line 656
  __mptr___0 = (struct list_head  const  *)ctl->list.next;
#line 656
  ctl = (struct snd_emu10k1_fx8010_ctl *)__mptr___0;
  ldv_30748: ;
#line 656
  if ((unsigned long )(& ctl->list) != (unsigned long )(& emu->fx8010.gpr_ctl)) {
#line 658
    goto ldv_30747;
  } else {

  }

#line 663
  return ((struct snd_emu10k1_fx8010_ctl *)0);
}
}
#line 668 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static unsigned int *copy_tlv(unsigned int const   *_tlv ) 
{ 
  unsigned int data[2U] ;
  unsigned int *tlv ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 673
  if ((unsigned long )_tlv == (unsigned long )((unsigned int const   *)0U)) {
#line 674
    return ((unsigned int *)0U);
  } else {

  }
  {
#line 675
  tmp = copy_from_user((void *)(& data), (void const   *)_tlv, 8UL);
  }
#line 675
  if (tmp != 0UL) {
#line 676
    return ((unsigned int *)0U);
  } else {

  }
#line 677
  if (data[1] > 255U) {
#line 678
    return ((unsigned int *)0U);
  } else {

  }
  {
#line 679
  tmp___0 = kmalloc((unsigned long )data[1] + 8UL, 208U);
#line 679
  tlv = (unsigned int *)tmp___0;
  }
#line 680
  if ((unsigned long )tlv == (unsigned long )((unsigned int *)0U)) {
#line 681
    return ((unsigned int *)0U);
  } else {

  }
  {
#line 682
  memcpy((void *)tlv, (void const   *)(& data), 8UL);
#line 683
  tmp___1 = copy_from_user((void *)(tlv + 2UL), (void const   *)(_tlv + 2UL), (unsigned long )data[1]);
  }
#line 683
  if (tmp___1 != 0UL) {
    {
#line 684
    kfree((void const   *)tlv);
    }
#line 685
    return ((unsigned int *)0U);
  } else {

  }
#line 687
  return (tlv);
}
}
#line 690 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int copy_gctl(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_control_gpr *gctl ,
                     struct snd_emu10k1_fx8010_control_gpr *_gctl , int idx ) 
{ 
  struct snd_emu10k1_fx8010_control_old_gpr *octl ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 697
  if ((unsigned int )*((unsigned char *)emu + 16UL) != 0U) {
    {
#line 698
    tmp = copy_from_user((void *)gctl, (void const   *)(_gctl + (unsigned long )idx),
                         288UL);
    }
#line 698
    return ((int )tmp);
  } else {

  }
  {
#line 699
  octl = (struct snd_emu10k1_fx8010_control_old_gpr *)_gctl;
#line 700
  tmp___0 = copy_from_user((void *)gctl, (void const   *)(octl + (unsigned long )idx),
                           276UL);
  }
#line 700
  if (tmp___0 != 0UL) {
#line 701
    return (-14);
  } else {

  }
#line 702
  gctl->tlv = (unsigned int const   *)0U;
#line 703
  return (0);
}
}
#line 706 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int copy_gctl_to_user(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_control_gpr *_gctl ,
                             struct snd_emu10k1_fx8010_control_gpr *gctl , int idx ) 
{ 
  struct snd_emu10k1_fx8010_control_old_gpr *octl ;
  int tmp ;
  int tmp___0 ;

  {
#line 713
  if ((unsigned int )*((unsigned char *)emu + 16UL) != 0U) {
    {
#line 714
    tmp = copy_to_user((void *)(_gctl + (unsigned long )idx), (void const   *)gctl,
                       288U);
    }
#line 714
    return (tmp);
  } else {

  }
  {
#line 716
  octl = (struct snd_emu10k1_fx8010_control_old_gpr *)_gctl;
#line 717
  tmp___0 = copy_to_user((void *)(octl + (unsigned long )idx), (void const   *)gctl,
                         276U);
  }
#line 717
  return (tmp___0);
}
}
#line 720 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_verify_controls(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  unsigned int i ;
  struct snd_ctl_elem_id *_id ;
  struct snd_ctl_elem_id id___0 ;
  struct snd_emu10k1_fx8010_control_gpr *gctl ;
  int err ;
  unsigned long tmp ;
  struct snd_emu10k1_fx8010_ctl *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct snd_emu10k1_fx8010_ctl *tmp___3 ;
  struct snd_kcontrol *tmp___4 ;
  int tmp___5 ;

  {
#line 729
  i = 0U;
#line 729
  _id = icode->gpr_del_controls;
#line 729
  goto ldv_30779;
  ldv_30778: 
  {
#line 731
  tmp = copy_from_user((void *)(& id___0), (void const   *)_id, 64UL);
  }
#line 731
  if (tmp != 0UL) {
#line 732
    return (-14);
  } else {

  }
  {
#line 733
  tmp___0 = snd_emu10k1_look_for_ctl(emu, & id___0);
  }
#line 733
  if ((unsigned long )tmp___0 == (unsigned long )((struct snd_emu10k1_fx8010_ctl *)0)) {
#line 734
    return (-2);
  } else {

  }
#line 730
  i = i + 1U;
#line 730
  _id = _id + 1;
  ldv_30779: ;
#line 729
  if (i < icode->gpr_del_control_count) {
#line 732
    goto ldv_30778;
  } else {

  }
  {
#line 736
  tmp___1 = kmalloc(288UL, 208U);
#line 736
  gctl = (struct snd_emu10k1_fx8010_control_gpr *)tmp___1;
  }
#line 737
  if ((unsigned long )gctl == (unsigned long )((struct snd_emu10k1_fx8010_control_gpr *)0)) {
#line 738
    return (-12);
  } else {

  }
#line 739
  err = 0;
#line 740
  i = 0U;
#line 740
  goto ldv_30784;
  ldv_30783: 
  {
#line 741
  tmp___2 = copy_gctl(emu, gctl, icode->gpr_add_controls, (int )i);
  }
#line 741
  if (tmp___2 != 0) {
#line 742
    err = -14;
#line 743
    goto __error;
  } else {

  }
  {
#line 745
  tmp___3 = snd_emu10k1_look_for_ctl(emu, & gctl->id);
  }
#line 745
  if ((unsigned long )tmp___3 != (unsigned long )((struct snd_emu10k1_fx8010_ctl *)0)) {
#line 746
    goto ldv_30782;
  } else {

  }
  {
#line 747
  down_read(& (emu->card)->controls_rwsem);
#line 748
  tmp___4 = snd_ctl_find_id(emu->card, & gctl->id);
  }
#line 748
  if ((unsigned long )tmp___4 != (unsigned long )((struct snd_kcontrol *)0)) {
    {
#line 749
    up_read(& (emu->card)->controls_rwsem);
#line 750
    err = -17;
    }
#line 751
    goto __error;
  } else {

  }
  {
#line 753
  up_read(& (emu->card)->controls_rwsem);
  }
#line 754
  if ((unsigned int )gctl->id.iface - 2U > 1U) {
#line 756
    err = -22;
#line 757
    goto __error;
  } else {

  }
  ldv_30782: 
#line 740
  i = i + 1U;
  ldv_30784: ;
#line 740
  if (i < icode->gpr_add_control_count) {
#line 742
    goto ldv_30783;
  } else {

  }
#line 760
  i = 0U;
#line 760
  goto ldv_30787;
  ldv_30786: 
  {
#line 762
  tmp___5 = copy_gctl(emu, gctl, icode->gpr_list_controls, (int )i);
  }
#line 762
  if (tmp___5 != 0) {
#line 763
    err = -14;
#line 764
    goto __error;
  } else {

  }
#line 760
  i = i + 1U;
  ldv_30787: ;
#line 760
  if (i < icode->gpr_list_control_count) {
#line 762
    goto ldv_30786;
  } else {

  }

  __error: 
  {
#line 768
  kfree((void const   *)gctl);
  }
#line 769
  return (err);
}
}
#line 772 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_ctl_private_free(struct snd_kcontrol *kctl ) 
{ 
  struct snd_emu10k1_fx8010_ctl *ctl ;

  {
  {
#line 776
  ctl = (struct snd_emu10k1_fx8010_ctl *)kctl->private_value;
#line 777
  kctl->private_value = 0UL;
#line 778
  list_del(& ctl->list);
#line 779
  kfree((void const   *)ctl);
  }
#line 780
  if ((unsigned long )kctl->tlv.p != (unsigned long )((unsigned int const   *)0U)) {
    {
#line 781
    kfree((void const   *)kctl->tlv.p);
    }
  } else {

  }
#line 782
  return;
}
}
#line 784 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_add_controls(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  unsigned int i ;
  unsigned int j ;
  struct snd_emu10k1_fx8010_control_gpr *gctl ;
  struct snd_emu10k1_fx8010_ctl *ctl ;
  struct snd_emu10k1_fx8010_ctl *nctl ;
  struct snd_kcontrol_new knew ;
  struct snd_kcontrol *kctl ;
  struct snd_ctl_elem_value *val ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 793
  err = 0;
#line 795
  tmp = kmalloc(1224UL, 208U);
#line 795
  val = (struct snd_ctl_elem_value *)tmp;
#line 796
  tmp___0 = kmalloc(288UL, 208U);
#line 796
  gctl = (struct snd_emu10k1_fx8010_control_gpr *)tmp___0;
#line 797
  tmp___1 = kmalloc(240UL, 208U);
#line 797
  nctl = (struct snd_emu10k1_fx8010_ctl *)tmp___1;
  }
#line 798
  if (((unsigned long )val == (unsigned long )((struct snd_ctl_elem_value *)0) || (unsigned long )gctl == (unsigned long )((struct snd_emu10k1_fx8010_control_gpr *)0)) || (unsigned long )nctl == (unsigned long )((struct snd_emu10k1_fx8010_ctl *)0)) {
#line 799
    err = -12;
#line 800
    goto __error;
  } else {

  }
#line 803
  i = 0U;
#line 803
  goto ldv_30811;
  ldv_30810: 
  {
#line 804
  tmp___2 = copy_gctl(emu, gctl, icode->gpr_add_controls, (int )i);
  }
#line 804
  if (tmp___2 != 0) {
#line 805
    err = -14;
#line 806
    goto __error;
  } else {

  }
#line 808
  if ((unsigned int )gctl->id.iface - 2U > 1U) {
#line 810
    err = -22;
#line 811
    goto __error;
  } else {

  }
#line 813
  if ((unsigned int )gctl->id.name[0] == 0U) {
#line 814
    err = -22;
#line 815
    goto __error;
  } else {

  }
  {
#line 817
  ctl = snd_emu10k1_look_for_ctl(emu, & gctl->id);
#line 818
  memset((void *)(& knew), 0, 80UL);
#line 819
  knew.iface = gctl->id.iface;
#line 820
  knew.name = (unsigned char *)(& gctl->id.name);
#line 821
  knew.index = gctl->id.index;
#line 822
  knew.device = gctl->id.device;
#line 823
  knew.subdevice = gctl->id.subdevice;
#line 824
  knew.info = & snd_emu10k1_gpr_ctl_info;
#line 825
  tmp___3 = copy_tlv(gctl->tlv);
#line 825
  knew.tlv.p = (unsigned int const   *)tmp___3;
  }
#line 826
  if ((unsigned long )knew.tlv.p != (unsigned long )((unsigned int const   *)0U)) {
#line 827
    knew.access = 19U;
  } else {

  }
  {
#line 829
  knew.get = & snd_emu10k1_gpr_ctl_get;
#line 830
  knew.put = & snd_emu10k1_gpr_ctl_put;
#line 831
  memset((void *)nctl, 0, 240UL);
#line 832
  nctl->vcount = gctl->vcount;
#line 833
  nctl->count = gctl->count;
#line 834
  j = 0U;
  }
#line 834
  goto ldv_30808;
  ldv_30807: 
#line 835
  nctl->gpr[j] = gctl->gpr[j];
#line 836
  nctl->value[j] = ~ gctl->value[j];
#line 837
  val->value.integer.value[j] = (long )gctl->value[j];
#line 834
  j = j + 1U;
  ldv_30808: ;
#line 834
  if (j <= 31U) {
#line 836
    goto ldv_30807;
  } else {

  }
#line 839
  nctl->min = gctl->min;
#line 840
  nctl->max = gctl->max;
#line 841
  nctl->translation = gctl->translation;
#line 842
  if ((unsigned long )ctl == (unsigned long )((struct snd_emu10k1_fx8010_ctl *)0)) {
    {
#line 843
    tmp___4 = kmalloc(240UL, 208U);
#line 843
    ctl = (struct snd_emu10k1_fx8010_ctl *)tmp___4;
    }
#line 844
    if ((unsigned long )ctl == (unsigned long )((struct snd_emu10k1_fx8010_ctl *)0)) {
      {
#line 845
      err = -12;
#line 846
      kfree((void const   *)knew.tlv.p);
      }
#line 847
      goto __error;
    } else {

    }
    {
#line 849
    knew.private_value = (unsigned long )ctl;
#line 850
    *ctl = *nctl;
#line 851
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& knew), (void *)emu);
#line 851
    err = snd_ctl_add(emu->card, kctl);
    }
#line 851
    if (err < 0) {
      {
#line 852
      kfree((void const   *)ctl);
#line 853
      kfree((void const   *)knew.tlv.p);
      }
#line 854
      goto __error;
    } else {

    }
    {
#line 856
    kctl->private_free = & snd_emu10k1_ctl_private_free;
#line 857
    ctl->kcontrol = kctl;
#line 858
    list_add_tail(& ctl->list, & emu->fx8010.gpr_ctl);
    }
  } else {
    {
#line 861
    nctl->list = ctl->list;
#line 862
    nctl->kcontrol = ctl->kcontrol;
#line 863
    *ctl = *nctl;
#line 864
    snd_ctl_notify(emu->card, 3U, & (ctl->kcontrol)->id);
    }
  }
  {
#line 867
  snd_emu10k1_gpr_ctl_put(ctl->kcontrol, val);
#line 803
  i = i + 1U;
  }
  ldv_30811: ;
#line 803
  if (i < icode->gpr_add_control_count) {
#line 805
    goto ldv_30810;
  } else {

  }

  __error: 
  {
#line 870
  kfree((void const   *)nctl);
#line 871
  kfree((void const   *)gctl);
#line 872
  kfree((void const   *)val);
  }
#line 873
  return (err);
}
}
#line 876 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_del_controls(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  unsigned int i ;
  struct snd_ctl_elem_id id___0 ;
  struct snd_ctl_elem_id *_id ;
  struct snd_emu10k1_fx8010_ctl *ctl ;
  struct snd_card *card ;
  unsigned long tmp ;

  {
#line 883
  card = emu->card;
#line 885
  i = 0U;
#line 885
  _id = icode->gpr_del_controls;
#line 885
  goto ldv_30823;
  ldv_30822: 
  {
#line 887
  tmp = copy_from_user((void *)(& id___0), (void const   *)_id, 64UL);
  }
#line 887
  if (tmp != 0UL) {
#line 888
    return (-14);
  } else {

  }
  {
#line 889
  down_write(& card->controls_rwsem);
#line 890
  ctl = snd_emu10k1_look_for_ctl(emu, & id___0);
  }
#line 891
  if ((unsigned long )ctl != (unsigned long )((struct snd_emu10k1_fx8010_ctl *)0)) {
    {
#line 892
    snd_ctl_remove(card, ctl->kcontrol);
    }
  } else {

  }
  {
#line 893
  up_write(& card->controls_rwsem);
#line 886
  i = i + 1U;
#line 886
  _id = _id + 1;
  }
  ldv_30823: ;
#line 885
  if (i < icode->gpr_del_control_count) {
#line 888
    goto ldv_30822;
  } else {

  }

#line 895
  return (0);
}
}
#line 898 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_list_controls(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int total ;
  struct snd_emu10k1_fx8010_control_gpr *gctl ;
  struct snd_emu10k1_fx8010_ctl *ctl ;
  struct snd_ctl_elem_id *id___0 ;
  void *tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 901
  i = 0U;
#line 902
  total = 0U;
#line 907
  tmp = kmalloc(288UL, 208U);
#line 907
  gctl = (struct snd_emu10k1_fx8010_control_gpr *)tmp;
  }
#line 908
  if ((unsigned long )gctl == (unsigned long )((struct snd_emu10k1_fx8010_control_gpr *)0)) {
#line 909
    return (-12);
  } else {

  }
#line 911
  __mptr = (struct list_head  const  *)emu->fx8010.gpr_ctl.next;
#line 911
  ctl = (struct snd_emu10k1_fx8010_ctl *)__mptr;
#line 911
  goto ldv_30843;
  ldv_30842: 
#line 912
  total = total + 1U;
#line 913
  if ((unsigned long )icode->gpr_list_controls != (unsigned long )((struct snd_emu10k1_fx8010_control_gpr *)0) && i < icode->gpr_list_control_count) {
    {
#line 915
    memset((void *)gctl, 0, 288UL);
#line 916
    id___0 = & (ctl->kcontrol)->id;
#line 917
    gctl->id.iface = id___0->iface;
#line 918
    strlcpy((char *)(& gctl->id.name), (char const   *)(& id___0->name), 44UL);
#line 919
    gctl->id.index = id___0->index;
#line 920
    gctl->id.device = id___0->device;
#line 921
    gctl->id.subdevice = id___0->subdevice;
#line 922
    gctl->vcount = ctl->vcount;
#line 923
    gctl->count = ctl->count;
#line 924
    j = 0U;
    }
#line 924
    goto ldv_30840;
    ldv_30839: 
#line 925
    gctl->gpr[j] = ctl->gpr[j];
#line 926
    gctl->value[j] = ctl->value[j];
#line 924
    j = j + 1U;
    ldv_30840: ;
#line 924
    if (j <= 31U) {
#line 926
      goto ldv_30839;
    } else {

    }
    {
#line 928
    gctl->min = ctl->min;
#line 929
    gctl->max = ctl->max;
#line 930
    gctl->translation = ctl->translation;
#line 931
    tmp___0 = copy_gctl_to_user(emu, icode->gpr_list_controls, gctl, (int )i);
    }
#line 931
    if (tmp___0 != 0) {
      {
#line 933
      kfree((void const   *)gctl);
      }
#line 934
      return (-14);
    } else {

    }
#line 936
    i = i + 1U;
  } else {

  }
#line 911
  __mptr___0 = (struct list_head  const  *)ctl->list.next;
#line 911
  ctl = (struct snd_emu10k1_fx8010_ctl *)__mptr___0;
  ldv_30843: ;
#line 911
  if ((unsigned long )(& ctl->list) != (unsigned long )(& emu->fx8010.gpr_ctl)) {
#line 913
    goto ldv_30842;
  } else {

  }
  {
#line 939
  icode->gpr_list_control_total = total;
#line 940
  kfree((void const   *)gctl);
  }
#line 941
  return (0);
}
}
#line 944 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_icode_poke(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  int err ;

  {
  {
#line 947
  err = 0;
#line 949
  mutex_lock_nested(& emu->fx8010.lock, 0U);
#line 950
  err = snd_emu10k1_verify_controls(emu, icode);
  }
#line 950
  if (err < 0) {
#line 951
    goto __error;
  } else {

  }
  {
#line 952
  strlcpy((char *)(& emu->fx8010.name), (char const   *)(& icode->name), 128UL);
  }
#line 955
  if (emu->audigy != 0U) {
    {
#line 956
    snd_emu10k1_ptr_write(emu, 83U, 0U, emu->fx8010.dbg | 131072U);
    }
  } else {
    {
#line 958
    snd_emu10k1_ptr_write(emu, 82U, 0U, emu->fx8010.dbg | 32768U);
    }
  }
  {
#line 960
  err = snd_emu10k1_del_controls(emu, icode);
  }
#line 960
  if (err < 0) {
#line 965
    goto __error;
  } else {
    {
#line 960
    err = snd_emu10k1_gpr_poke(emu, icode);
    }
#line 960
    if (err < 0) {
#line 965
      goto __error;
    } else {
      {
#line 960
      err = snd_emu10k1_tram_poke(emu, icode);
      }
#line 960
      if (err < 0) {
#line 965
        goto __error;
      } else {
        {
#line 960
        err = snd_emu10k1_code_poke(emu, icode);
        }
#line 960
        if (err < 0) {
#line 965
          goto __error;
        } else {
          {
#line 960
          err = snd_emu10k1_add_controls(emu, icode);
          }
#line 960
          if (err < 0) {
#line 965
            goto __error;
          } else {

          }
        }
      }
    }
  }
#line 967
  if (emu->audigy != 0U) {
    {
#line 968
    snd_emu10k1_ptr_write(emu, 83U, 0U, emu->fx8010.dbg);
    }
  } else {
    {
#line 970
    snd_emu10k1_ptr_write(emu, 82U, 0U, emu->fx8010.dbg);
    }
  }
  __error: 
  {
#line 972
  mutex_unlock(& emu->fx8010.lock);
  }
#line 973
  return (err);
}
}
#line 976 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_icode_peek(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_code *icode ) 
{ 
  int err ;

  {
  {
#line 981
  mutex_lock_nested(& emu->fx8010.lock, 0U);
#line 982
  strlcpy((char *)(& icode->name), (char const   *)(& emu->fx8010.name), 128UL);
#line 984
  err = snd_emu10k1_gpr_peek(emu, icode);
  }
#line 985
  if (err >= 0) {
    {
#line 986
    err = snd_emu10k1_tram_peek(emu, icode);
    }
  } else {

  }
#line 987
  if (err >= 0) {
    {
#line 988
    err = snd_emu10k1_code_peek(emu, icode);
    }
  } else {

  }
#line 989
  if (err >= 0) {
    {
#line 990
    err = snd_emu10k1_list_controls(emu, icode);
    }
  } else {

  }
  {
#line 991
  mutex_unlock(& emu->fx8010.lock);
  }
#line 992
  return (err);
}
}
#line 995 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_ipcm_poke(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_pcm_rec *ipcm ) 
{ 
  unsigned int i ;
  int err ;
  struct snd_emu10k1_fx8010_pcm *pcm ;

  {
#line 999
  err = 0;
#line 1002
  if (ipcm->substream > 7U) {
#line 1003
    return (-22);
  } else {

  }
#line 1004
  if (ipcm->channels > 32U) {
#line 1005
    return (-22);
  } else {

  }
  {
#line 1006
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )ipcm->substream;
#line 1007
  mutex_lock_nested(& emu->fx8010.lock, 0U);
#line 1008
  ldv_spin_lock_irq_41(& emu->reg_lock);
  }
#line 1009
  if ((unsigned int )*((unsigned char *)pcm + 0UL) != 0U) {
#line 1010
    err = -16;
#line 1011
    goto __error;
  } else {

  }
#line 1013
  if (ipcm->channels == 0U) {
#line 1014
    pcm->valid = 0U;
  } else {
#line 1017
    if (ipcm->channels != 2U) {
#line 1018
      err = -22;
#line 1019
      goto __error;
    } else {

    }
#line 1021
    pcm->valid = 1U;
#line 1022
    pcm->opened = 0U;
#line 1023
    pcm->channels = ipcm->channels;
#line 1024
    pcm->tram_start = ipcm->tram_start;
#line 1025
    pcm->buffer_size = ipcm->buffer_size;
#line 1026
    pcm->gpr_size = ipcm->gpr_size;
#line 1027
    pcm->gpr_count = ipcm->gpr_count;
#line 1028
    pcm->gpr_tmpcount = ipcm->gpr_tmpcount;
#line 1029
    pcm->gpr_ptr = ipcm->gpr_ptr;
#line 1030
    pcm->gpr_trigger = ipcm->gpr_trigger;
#line 1031
    pcm->gpr_running = ipcm->gpr_running;
#line 1032
    i = 0U;
#line 1032
    goto ldv_30865;
    ldv_30864: 
#line 1033
    pcm->etram[i] = ipcm->etram[i];
#line 1032
    i = i + 1U;
    ldv_30865: ;
#line 1032
    if (i < pcm->channels) {
#line 1034
      goto ldv_30864;
    } else {

    }

  }
  __error: 
  {
#line 1036
  ldv_spin_unlock_irq_42(& emu->reg_lock);
#line 1037
  mutex_unlock(& emu->fx8010.lock);
  }
#line 1038
  return (err);
}
}
#line 1041 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_ipcm_peek(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_pcm_rec *ipcm ) 
{ 
  unsigned int i ;
  int err ;
  struct snd_emu10k1_fx8010_pcm *pcm ;
  unsigned int tmp ;

  {
#line 1045
  err = 0;
#line 1048
  if (ipcm->substream > 7U) {
#line 1049
    return (-22);
  } else {

  }
  {
#line 1050
  pcm = (struct snd_emu10k1_fx8010_pcm *)(& emu->fx8010.pcm) + (unsigned long )ipcm->substream;
#line 1051
  mutex_lock_nested(& emu->fx8010.lock, 0U);
#line 1052
  ldv_spin_lock_irq_41(& emu->reg_lock);
#line 1053
  ipcm->channels = pcm->channels;
#line 1054
  ipcm->tram_start = pcm->tram_start;
#line 1055
  ipcm->buffer_size = pcm->buffer_size;
#line 1056
  ipcm->gpr_size = pcm->gpr_size;
#line 1057
  ipcm->gpr_ptr = pcm->gpr_ptr;
#line 1058
  ipcm->gpr_count = pcm->gpr_count;
#line 1059
  ipcm->gpr_tmpcount = pcm->gpr_tmpcount;
#line 1060
  ipcm->gpr_trigger = pcm->gpr_trigger;
#line 1061
  ipcm->gpr_running = pcm->gpr_running;
#line 1062
  i = 0U;
  }
#line 1062
  goto ldv_30875;
  ldv_30874: 
#line 1063
  ipcm->etram[i] = pcm->etram[i];
#line 1062
  i = i + 1U;
  ldv_30875: ;
#line 1062
  if (i < pcm->channels) {
#line 1064
    goto ldv_30874;
  } else {

  }
  {
#line 1064
  tmp = 0U;
#line 1064
  ipcm->res2 = tmp;
#line 1064
  ipcm->res1 = tmp;
#line 1065
  ipcm->pad = 0U;
#line 1066
  ldv_spin_unlock_irq_42(& emu->reg_lock);
#line 1067
  mutex_unlock(& emu->fx8010.lock);
  }
#line 1068
  return (err);
}
}
#line 1077 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_init_mono_control(struct snd_emu10k1_fx8010_control_gpr *ctl ,
                                          char const   *name , int gpr , int defval ) 
{ 
  unsigned int tmp ;

  {
  {
#line 1080
  ctl->id.iface = 2;
#line 1081
  strcpy((char *)(& ctl->id.name), name);
#line 1082
  tmp = 1U;
#line 1082
  ctl->count = tmp;
#line 1082
  ctl->vcount = tmp;
#line 1083
  ctl->gpr[0] = (unsigned short )gpr;
#line 1083
  ctl->value[0] = (unsigned int )defval;
  }
#line 1084
  if ((int )high_res_gpr_volume) {
#line 1085
    ctl->min = 0U;
#line 1086
    ctl->max = 2147483647U;
#line 1087
    ctl->tlv = (unsigned int const   *)(& snd_emu10k1_db_linear);
#line 1088
    ctl->translation = 0U;
  } else {
#line 1090
    ctl->min = 0U;
#line 1091
    ctl->max = 100U;
#line 1092
    ctl->tlv = (unsigned int const   *)(& snd_emu10k1_db_scale1);
#line 1093
    ctl->translation = 1U;
  }
#line 1095
  return;
}
}
#line 1098 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_init_stereo_control(struct snd_emu10k1_fx8010_control_gpr *ctl ,
                                            char const   *name , int gpr , int defval ) 
{ 
  unsigned int tmp ;

  {
  {
#line 1101
  ctl->id.iface = 2;
#line 1102
  strcpy((char *)(& ctl->id.name), name);
#line 1103
  tmp = 2U;
#line 1103
  ctl->count = tmp;
#line 1103
  ctl->vcount = tmp;
#line 1104
  ctl->gpr[0] = (unsigned short )gpr;
#line 1104
  ctl->value[0] = (unsigned int )defval;
#line 1105
  ctl->gpr[1] = (unsigned int )((unsigned short )gpr) + 1U;
#line 1105
  ctl->value[1] = (unsigned int )defval;
  }
#line 1106
  if ((int )high_res_gpr_volume) {
#line 1107
    ctl->min = 0U;
#line 1108
    ctl->max = 2147483647U;
#line 1109
    ctl->tlv = (unsigned int const   *)(& snd_emu10k1_db_linear);
#line 1110
    ctl->translation = 0U;
  } else {
#line 1112
    ctl->min = 0U;
#line 1113
    ctl->max = 100U;
#line 1114
    ctl->tlv = (unsigned int const   *)(& snd_emu10k1_db_scale1);
#line 1115
    ctl->translation = 1U;
  }
#line 1117
  return;
}
}
#line 1120 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_init_mono_onoff_control(struct snd_emu10k1_fx8010_control_gpr *ctl ,
                                                char const   *name , int gpr , int defval ) 
{ 
  unsigned int tmp ;

  {
  {
#line 1123
  ctl->id.iface = 2;
#line 1124
  strcpy((char *)(& ctl->id.name), name);
#line 1125
  tmp = 1U;
#line 1125
  ctl->count = tmp;
#line 1125
  ctl->vcount = tmp;
#line 1126
  ctl->gpr[0] = (unsigned short )gpr;
#line 1126
  ctl->value[0] = (unsigned int )defval;
#line 1127
  ctl->min = 0U;
#line 1128
  ctl->max = 1U;
#line 1129
  ctl->translation = 4U;
  }
#line 1130
  return;
}
}
#line 1133 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_init_stereo_onoff_control(struct snd_emu10k1_fx8010_control_gpr *ctl ,
                                                  char const   *name , int gpr , int defval ) 
{ 
  unsigned int tmp ;

  {
  {
#line 1136
  ctl->id.iface = 2;
#line 1137
  strcpy((char *)(& ctl->id.name), name);
#line 1138
  tmp = 2U;
#line 1138
  ctl->count = tmp;
#line 1138
  ctl->vcount = tmp;
#line 1139
  ctl->gpr[0] = (unsigned short )gpr;
#line 1139
  ctl->value[0] = (unsigned int )defval;
#line 1140
  ctl->gpr[1] = (unsigned int )((unsigned short )gpr) + 1U;
#line 1140
  ctl->value[1] = (unsigned int )defval;
#line 1141
  ctl->min = 0U;
#line 1142
  ctl->max = 1U;
#line 1143
  ctl->translation = 4U;
  }
#line 1144
  return;
}
}
#line 1151 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_audigy_dsp_convert_32_to_2x16(struct snd_emu10k1_fx8010_code *icode ,
                                                     u32 *ptr , int tmp , int bit_shifter16 ,
                                                     int reg_in , int reg_out ) 
{ 


  {
  {
#line 1156
  snd_emu10k1_audigy_write_op(icode, ptr, 6U, (u32 )(tmp + 1025), (u32 )reg_in, 192U,
                              192U);
#line 1157
  snd_emu10k1_audigy_write_op(icode, ptr, 8U, (u32 )(tmp + 1024), (u32 )(tmp + 1025),
                              (u32 )(bit_shifter16 + 1023), 192U);
#line 1158
  snd_emu10k1_audigy_write_op(icode, ptr, 9U, (u32 )(tmp + 1026), (u32 )(tmp + 1024),
                              206U, (u32 )(bit_shifter16 + 1022));
#line 1159
  snd_emu10k1_audigy_write_op(icode, ptr, 8U, (u32 )(tmp + 1026), (u32 )(tmp + 1026),
                              206U, 192U);
#line 1160
  snd_emu10k1_audigy_write_op(icode, ptr, 8U, (u32 )(tmp + 1024), (u32 )(tmp + 1024),
                              (u32 )(bit_shifter16 + 1021), 192U);
#line 1161
  snd_emu10k1_audigy_write_op(icode, ptr, 4U, (u32 )(tmp + 1024), 192U, (u32 )(tmp + 1024),
                              201U);
#line 1162
  snd_emu10k1_audigy_write_op(icode, ptr, 8U, (u32 )reg_out, (u32 )(tmp + 1024), 208U,
                              (u32 )(tmp + 1026));
#line 1163
  snd_emu10k1_audigy_write_op(icode, ptr, 6U, (u32 )(reg_out + 1), (u32 )(tmp + 1025),
                              192U, 192U);
  }
#line 1164
  return (1);
}
}
#line 1171 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int _snd_emu10k1_audigy_init_efx(struct snd_emu10k1 *emu ) 
{ 
  int err ;
  int i ;
  int z ;
  int gpr ;
  int nctl ;
  int bit_shifter16 ;
  int playback ;
  int capture ;
  int stereo_mix ;
  int tmp ;
  u32 ptr ;
  struct snd_emu10k1_fx8010_code *icode ;
  struct snd_emu10k1_fx8010_control_gpr *controls ;
  struct snd_emu10k1_fx8010_control_gpr *ctl ;
  u32 *gpr_map ;
  mm_segment_t seg ;
  void *tmp___0 ;
  __u32 *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  int j ;
  int j___0 ;
  int k ;
  int l ;
  int d ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int __ret_warn_on ;
  long tmp___58 ;

  {
  {
#line 1175
  playback = 10;
#line 1176
  capture = 26;
#line 1177
  stereo_mix = 28;
#line 1178
  tmp = 136;
#line 1180
  icode = (struct snd_emu10k1_fx8010_code *)0;
#line 1181
  controls = (struct snd_emu10k1_fx8010_control_gpr *)0;
#line 1185
  tmp___0 = kzalloc(432UL, 208U);
#line 1185
  icode = (struct snd_emu10k1_fx8010_code *)tmp___0;
  }
#line 1185
  if ((unsigned long )icode == (unsigned long )((struct snd_emu10k1_fx8010_code *)0)) {
#line 1191
    err = -12;
#line 1192
    goto __err;
  } else {
    {
#line 1185
    tmp___2 = kcalloc(3072UL, 4UL, 208U);
#line 1185
    tmp___1 = (__u32 *)tmp___2;
#line 1185
    icode->gpr_map = tmp___1;
    }
#line 1185
    if ((unsigned long )tmp___1 == (unsigned long )((__u32 *)0U)) {
#line 1191
      err = -12;
#line 1192
      goto __err;
    } else {
      {
#line 1185
      tmp___3 = kcalloc(44UL, 288UL, 208U);
#line 1185
      controls = (struct snd_emu10k1_fx8010_control_gpr *)tmp___3;
      }
#line 1185
      if ((unsigned long )controls == (unsigned long )((struct snd_emu10k1_fx8010_control_gpr *)0)) {
#line 1191
        err = -12;
#line 1192
        goto __err;
      } else {

      }
    }
  }
#line 1194
  gpr_map = icode->gpr_map;
#line 1196
  icode->tram_data_map = icode->gpr_map + 512UL;
#line 1197
  icode->tram_addr_map = icode->tram_data_map + 256UL;
#line 1198
  icode->code = icode->tram_addr_map + 256UL;
#line 1201
  i = 0;
#line 1201
  goto ldv_30930;
  ldv_30929: 
  {
#line 1202
  set_bit((unsigned int )i, (unsigned long volatile   *)(& icode->gpr_valid));
#line 1201
  i = i + 1;
  }
  ldv_30930: ;
#line 1201
  if (i <= 511) {
#line 1203
    goto ldv_30929;
  } else {

  }
#line 1205
  i = 0;
#line 1205
  goto ldv_30933;
  ldv_30932: 
  {
#line 1206
  set_bit((unsigned int )i, (unsigned long volatile   *)(& icode->tram_valid));
#line 1205
  i = i + 1;
  }
  ldv_30933: ;
#line 1205
  if (i <= 255) {
#line 1207
    goto ldv_30932;
  } else {

  }
  {
#line 1208
  strcpy((char *)(& icode->name), "Audigy DSP code for ALSA");
#line 1209
  ptr = 0U;
#line 1210
  nctl = 0;
#line 1211
  gpr = 38;
#line 1212
  tmp___4 = gpr;
#line 1212
  gpr = gpr + 1;
#line 1212
  *(gpr_map + (unsigned long )tmp___4) = 32767U;
#line 1213
  tmp___5 = gpr;
#line 1213
  gpr = gpr + 1;
#line 1213
  *(gpr_map + (unsigned long )tmp___5) = 32768U;
#line 1214
  tmp___6 = gpr;
#line 1214
  gpr = gpr + 1;
#line 1214
  *(gpr_map + (unsigned long )tmp___6) = 65535U;
#line 1215
  bit_shifter16 = gpr;
#line 1218
  tmp___7 = 0U;
#line 1218
  emu->fx8010.dbg = tmp___7;
#line 1218
  snd_emu10k1_ptr_write(emu, 83U, 0U, tmp___7 | 131072U);
#line 1226
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1034U, 192U, (u32 )(gpr + 1024), 8U);
#line 1227
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1035U, 192U, (u32 )(gpr + 1025), 9U);
#line 1228
  tmp___8 = nctl;
#line 1228
  nctl = nctl + 1;
#line 1228
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___8, "PCM Front Playback Volume",
                                  gpr, 100);
#line 1229
  gpr = gpr + 2;
#line 1232
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1036U, 192U, (u32 )(gpr + 1024), 2U);
#line 1233
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1037U, 192U, (u32 )(gpr + 1025), 3U);
#line 1234
  tmp___9 = nctl;
#line 1234
  nctl = nctl + 1;
#line 1234
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___9, "PCM Surround Playback Volume",
                                  gpr, 100);
#line 1235
  gpr = gpr + 2;
  }
#line 1238
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->spk71) != 0U) {
    {
#line 1239
    snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1040U, 192U, (u32 )(gpr + 1024),
                                14U);
#line 1240
    snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1041U, 192U, (u32 )(gpr + 1025),
                                15U);
#line 1241
    tmp___10 = nctl;
#line 1241
    nctl = nctl + 1;
#line 1241
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___10, "PCM Side Playback Volume",
                                    gpr, 100);
#line 1242
    gpr = gpr + 2;
    }
  } else {

  }
  {
#line 1246
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1038U, 192U, (u32 )(gpr + 1024), 6U);
#line 1247
  tmp___11 = nctl;
#line 1247
  nctl = nctl + 1;
#line 1247
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___11, "PCM Center Playback Volume",
                                gpr, 100);
#line 1248
  gpr = gpr + 1;
#line 1251
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1039U, 192U, (u32 )(gpr + 1024), 7U);
#line 1252
  tmp___12 = nctl;
#line 1252
  nctl = nctl + 1;
#line 1252
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___12, "PCM LFE Playback Volume",
                                gpr, 100);
#line 1253
  gpr = gpr + 1;
#line 1259
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 192U, (u32 )(gpr + 1024), 0U);
#line 1260
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 192U, (u32 )(gpr + 1025), 1U);
#line 1261
  tmp___13 = nctl;
#line 1261
  nctl = nctl + 1;
#line 1261
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___13, "Wave Playback Volume",
                                  gpr, 100);
#line 1262
  gpr = gpr + 2;
#line 1265
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              4U);
#line 1266
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              5U);
#line 1267
  tmp___14 = nctl;
#line 1267
  nctl = nctl + 1;
#line 1267
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___14, "Synth Playback Volume",
                                  gpr, 100);
#line 1268
  gpr = gpr + 2;
#line 1271
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 192U, (u32 )(gpr + 1024), 0U);
#line 1272
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 192U, (u32 )(gpr + 1025), 1U);
#line 1273
  tmp___15 = nctl;
#line 1273
  nctl = nctl + 1;
#line 1273
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___15, "PCM Capture Volume",
                                  gpr, 0);
#line 1274
  gpr = gpr + 2;
#line 1277
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              4U);
#line 1278
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              5U);
#line 1279
  tmp___16 = nctl;
#line 1279
  nctl = nctl + 1;
#line 1279
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___16, "Synth Capture Volume",
                                  gpr, 0);
#line 1280
  gpr = gpr + 2;
  }
#line 1289
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
#line 1290
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0108_chip) != 0U) {
      {
#line 1292
      snd_emu10k1_audigy_write_op(icode, & ptr, 4U, 1160U, 192U, 352U, 193U);
#line 1293
      snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                                  1160U);
#line 1294
      snd_emu10k1_audigy_write_op(icode, & ptr, 4U, 1160U, 192U, 353U, 193U);
#line 1295
      snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1024),
                                  1160U);
      }
    } else {
      {
#line 1297
      snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                                  80U);
#line 1298
      snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                                  81U);
      }
    }
    {
#line 1300
    tmp___17 = nctl;
#line 1300
    nctl = nctl + 1;
#line 1300
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___17, "EMU Capture Volume",
                                    gpr, 0);
#line 1301
    gpr = gpr + 2;
    }
  } else {

  }
  {
#line 1304
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              64U);
#line 1305
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              65U);
#line 1306
  tmp___18 = nctl;
#line 1306
  nctl = nctl + 1;
#line 1306
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___18, "AMic Playback Volume",
                                  gpr, 0);
#line 1307
  gpr = gpr + 2;
#line 1309
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              64U);
#line 1310
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              65U);
#line 1311
  tmp___19 = nctl;
#line 1311
  nctl = nctl + 1;
#line 1311
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___19, "Mic Capture Volume",
                                  gpr, 0);
#line 1312
  gpr = gpr + 2;
#line 1315
  snd_emu10k1_audigy_write_op(icode, & ptr, 14U, 120U, 64U, 205U, 65U);
#line 1318
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              66U);
#line 1319
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              67U);
#line 1320
  tmp___20 = nctl;
#line 1320
  nctl = nctl + 1;
#line 1320
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___20, (unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U ? "Audigy CD Playback Volume" : "CD Playback Volume",
                                  gpr, 0);
#line 1323
  gpr = gpr + 2;
#line 1325
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              66U);
#line 1326
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              67U);
#line 1327
  tmp___21 = nctl;
#line 1327
  nctl = nctl + 1;
#line 1327
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___21, (unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U ? "Audigy CD Capture Volume" : "CD Capture Volume",
                                  gpr, 0);
#line 1330
  gpr = gpr + 2;
#line 1333
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              68U);
#line 1334
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              69U);
#line 1335
  tmp___22 = nctl;
#line 1335
  nctl = nctl + 1;
#line 1335
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___22, "IEC958 Optical Playback Volume",
                                  gpr, 0);
#line 1336
  gpr = gpr + 2;
#line 1338
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              68U);
#line 1339
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              69U);
#line 1340
  tmp___23 = nctl;
#line 1340
  nctl = nctl + 1;
#line 1340
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___23, "IEC958 Optical Capture Volume",
                                  gpr, 0);
#line 1341
  gpr = gpr + 2;
#line 1344
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              72U);
#line 1345
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              73U);
#line 1346
  tmp___24 = nctl;
#line 1346
  nctl = nctl + 1;
#line 1346
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___24, (unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U ? "Line2 Playback Volume" : "Line Playback Volume",
                                  gpr, 0);
#line 1349
  gpr = gpr + 2;
#line 1351
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              72U);
#line 1352
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              73U);
#line 1353
  tmp___25 = nctl;
#line 1353
  nctl = nctl + 1;
#line 1353
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___25, (unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U ? "Line2 Capture Volume" : "Line Capture Volume",
                                  gpr, 0);
#line 1356
  gpr = gpr + 2;
#line 1359
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              74U);
#line 1360
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              75U);
#line 1361
  tmp___26 = nctl;
#line 1361
  nctl = nctl + 1;
#line 1361
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___26, "Analog Mix Playback Volume",
                                  gpr, 0);
#line 1362
  gpr = gpr + 2;
#line 1364
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              74U);
#line 1365
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              75U);
#line 1366
  tmp___27 = nctl;
#line 1366
  nctl = nctl + 1;
#line 1366
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___27, "Analog Mix Capture Volume",
                                  gpr, 0);
#line 1367
  gpr = gpr + 2;
#line 1370
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1052U, 1052U, (u32 )(gpr + 1024),
                              76U);
#line 1371
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1053U, 1053U, (u32 )(gpr + 1025),
                              77U);
#line 1372
  tmp___28 = nctl;
#line 1372
  nctl = nctl + 1;
#line 1372
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___28, (unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U ? "Aux2 Playback Volume" : "Aux Playback Volume",
                                  gpr, 0);
#line 1375
  gpr = gpr + 2;
#line 1377
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1050U, 1050U, (u32 )(gpr + 1024),
                              76U);
#line 1378
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1051U, 1051U, (u32 )(gpr + 1025),
                              77U);
#line 1379
  tmp___29 = nctl;
#line 1379
  nctl = nctl + 1;
#line 1379
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___29, (unsigned int )((unsigned char )(emu->card_capabilities)->ac97_chip) != 0U ? "Aux2 Capture Volume" : "Aux Capture Volume",
                                  gpr, 0);
#line 1382
  gpr = gpr + 2;
#line 1385
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1034U, 1034U, (u32 )(gpr + 1024),
                              1052U);
#line 1386
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1035U, 1035U, (u32 )(gpr + 1025),
                              1053U);
#line 1387
  tmp___30 = nctl;
#line 1387
  nctl = nctl + 1;
#line 1387
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___30, "Front Playback Volume",
                                  gpr, 100);
#line 1388
  gpr = gpr + 2;
#line 1391
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1036U, 1036U, (u32 )(gpr + 1024),
                              1052U);
#line 1392
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1037U, 1037U, (u32 )(gpr + 1025),
                              1053U);
#line 1393
  tmp___31 = nctl;
#line 1393
  nctl = nctl + 1;
#line 1393
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___31, "Surround Playback Volume",
                                  gpr, 0);
#line 1394
  gpr = gpr + 2;
#line 1398
  snd_emu10k1_audigy_write_op(icode, & ptr, 14U, 1160U, 1052U, 205U, 1053U);
#line 1399
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1038U, 1038U, (u32 )(gpr + 1024),
                              1160U);
#line 1400
  tmp___32 = nctl;
#line 1400
  nctl = nctl + 1;
#line 1400
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___32, "Center Playback Volume",
                                gpr, 0);
#line 1401
  gpr = gpr + 1;
#line 1404
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1039U, 1039U, (u32 )(gpr + 1024),
                              1160U);
#line 1405
  tmp___33 = nctl;
#line 1405
  nctl = nctl + 1;
#line 1405
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___33, "LFE Playback Volume",
                                gpr, 0);
#line 1406
  gpr = gpr + 1;
  }
#line 1408
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->spk71) != 0U) {
    {
#line 1410
    snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1040U, 1040U, (u32 )(gpr + 1024),
                                1052U);
#line 1411
    snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1041U, 1041U, (u32 )(gpr + 1025),
                                1053U);
#line 1412
    tmp___34 = nctl;
#line 1412
    nctl = nctl + 1;
#line 1412
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___34, "Side Playback Volume",
                                    gpr, 0);
#line 1413
    gpr = gpr + 2;
    }
  } else {

  }
  {
#line 1436
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1042U, 1034U, 192U, 192U);
#line 1437
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1043U, 1035U, 192U, 192U);
#line 1438
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1044U, 1036U, 192U, 192U);
#line 1439
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1045U, 1037U, 192U, 192U);
#line 1440
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1046U, 1038U, 192U, 192U);
#line 1441
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1047U, 1039U, 192U, 192U);
  }
#line 1442
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->spk71) != 0U) {
    {
#line 1443
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1048U, 1040U, 192U, 192U);
#line 1444
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1049U, 1041U, 192U, 192U);
    }
  } else {

  }
  {
#line 1448
  ctl = controls + (unsigned long )nctl;
#line 1449
  ctl->id.iface = 2;
#line 1450
  strcpy((char *)(& ctl->id.name), "Tone Control - Bass");
#line 1451
  ctl->vcount = 2U;
#line 1452
  ctl->count = 10U;
#line 1453
  ctl->min = 0U;
#line 1454
  ctl->max = 40U;
#line 1455
  tmp___35 = 20U;
#line 1455
  ctl->value[1] = tmp___35;
#line 1455
  ctl->value[0] = tmp___35;
#line 1456
  ctl->translation = 2U;
#line 1457
  ctl = controls + ((unsigned long )nctl + 1UL);
#line 1458
  ctl->id.iface = 2;
#line 1459
  strcpy((char *)(& ctl->id.name), "Tone Control - Treble");
#line 1460
  ctl->vcount = 2U;
#line 1461
  ctl->count = 10U;
#line 1462
  ctl->min = 0U;
#line 1463
  ctl->max = 40U;
#line 1464
  tmp___36 = 20U;
#line 1464
  ctl->value[1] = tmp___36;
#line 1464
  ctl->value[0] = tmp___36;
#line 1465
  ctl->translation = 3U;
#line 1470
  z = 0;
  }
#line 1470
  goto ldv_30940;
  ldv_30939: 
#line 1472
  j = 0;
#line 1472
  goto ldv_30937;
  ldv_30936: 
#line 1473
  (controls + (unsigned long )nctl)->gpr[z * 2 + j] = (unsigned int )((unsigned short )(z + 70)) * 2U + (unsigned int )((unsigned short )j);
#line 1474
  (controls + ((unsigned long )nctl + 1UL))->gpr[z * 2 + j] = (unsigned int )((unsigned short )(z + 75)) * 2U + (unsigned int )((unsigned short )j);
#line 1472
  j = j + 1;
  ldv_30937: ;
#line 1472
  if (j <= 1) {
#line 1474
    goto ldv_30936;
  } else {

  }
#line 1470
  z = z + 1;
  ldv_30940: ;
#line 1470
  if (z <= 4) {
#line 1472
    goto ldv_30939;
  } else {

  }
#line 1477
  z = 0;
#line 1477
  goto ldv_30950;
  ldv_30949: 
#line 1479
  j___0 = 0;
#line 1479
  goto ldv_30948;
  ldv_30947: 
  {
#line 1480
  k = ((z + 22) * 2 + j___0) * 4;
#line 1481
  l = ((z + 28) * 2 + j___0) * 4;
#line 1482
  d = (z + 9) * 2 + j___0;
#line 1484
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 192U, 192U, (u32 )(d + 1024), (u32 )(j___0 + 1164));
#line 1485
  snd_emu10k1_audigy_write_op(icode, & ptr, 7U, (u32 )(k + 1025), (u32 )(k + 1024),
                              (u32 )(k + 1025), (u32 )(j___0 + 1168));
#line 1486
  snd_emu10k1_audigy_write_op(icode, & ptr, 7U, (u32 )(k + 1024), (u32 )(d + 1024),
                              (u32 )(k + 1024), (u32 )(j___0 + 1166));
#line 1487
  snd_emu10k1_audigy_write_op(icode, & ptr, 7U, (u32 )(k + 1027), (u32 )(k + 1026),
                              (u32 )(k + 1027), (u32 )(j___0 + 1172));
#line 1488
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, (u32 )(k + 1026), 214U, (u32 )(k + 1026),
                              (u32 )(j___0 + 1170));
#line 1489
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(k + 1026), (u32 )(k + 1026),
                              (u32 )(k + 1026), 192U);
#line 1491
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 192U, 192U, (u32 )(k + 1026), (u32 )(j___0 + 1174));
#line 1492
  snd_emu10k1_audigy_write_op(icode, & ptr, 7U, (u32 )(l + 1025), (u32 )(l + 1024),
                              (u32 )(l + 1025), (u32 )(j___0 + 1178));
#line 1493
  snd_emu10k1_audigy_write_op(icode, & ptr, 7U, (u32 )(l + 1024), (u32 )(k + 1026),
                              (u32 )(l + 1024), (u32 )(j___0 + 1176));
#line 1494
  snd_emu10k1_audigy_write_op(icode, & ptr, 7U, (u32 )(l + 1027), (u32 )(l + 1026),
                              (u32 )(l + 1027), (u32 )(j___0 + 1182));
#line 1495
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, (u32 )(l + 1026), 214U, (u32 )(l + 1026),
                              (u32 )(j___0 + 1180));
#line 1496
  snd_emu10k1_audigy_write_op(icode, & ptr, 4U, (u32 )(l + 1026), 192U, (u32 )(l + 1026),
                              198U);
#line 1498
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(d + 1024), (u32 )(l + 1026),
                              192U, 192U);
  }
#line 1500
  if (z == 2) {
#line 1501
    goto ldv_30946;
  } else {

  }
#line 1479
  j___0 = j___0 + 1;
  ldv_30948: ;
#line 1479
  if (j___0 <= 1) {
#line 1481
    goto ldv_30947;
  } else {

  }
  ldv_30946: 
#line 1477
  z = z + 1;
  ldv_30950: ;
#line 1477
  if (z <= 3) {
#line 1479
    goto ldv_30949;
  } else {

  }
#line 1504
  nctl = nctl + 2;
#line 1509
  z = 0;
#line 1509
  goto ldv_30953;
  ldv_30952: 
  {
#line 1510
  snd_emu10k1_audigy_write_op(icode, & ptr, 4U, 1160U, 192U, (u32 )(z + 1042), (u32 )(gpr + 1024));
#line 1511
  snd_emu10k1_audigy_write_op(icode, & ptr, 8U, 1161U, (u32 )(gpr + 1024), 193U, 193U);
#line 1512
  snd_emu10k1_audigy_write_op(icode, & ptr, 4U, 1161U, 192U, (u32 )(z + 1034), 1161U);
#line 1513
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(z + 1042), 1160U, 1161U, 192U);
#line 1509
  z = z + 1;
  }
  ldv_30953: ;
#line 1509
  if (z <= 7) {
#line 1511
    goto ldv_30952;
  } else {

  }
  {
#line 1515
  tmp___37 = nctl;
#line 1515
  nctl = nctl + 1;
#line 1515
  snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___37, "Tone Control - Switch",
                                        gpr, 0);
#line 1516
  gpr = gpr + 2;
#line 1519
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1042U, 192U, (u32 )(gpr + 1024), 1042U);
#line 1520
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1043U, 192U, (u32 )(gpr + 1024), 1043U);
#line 1521
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1044U, 192U, (u32 )(gpr + 1024), 1044U);
#line 1522
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1045U, 192U, (u32 )(gpr + 1024), 1045U);
#line 1523
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1046U, 192U, (u32 )(gpr + 1024), 1046U);
#line 1524
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1047U, 192U, (u32 )(gpr + 1024), 1047U);
#line 1525
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1048U, 192U, (u32 )(gpr + 1024), 1048U);
#line 1526
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1049U, 192U, (u32 )(gpr + 1024), 1049U);
#line 1527
  tmp___38 = nctl;
#line 1527
  nctl = nctl + 1;
#line 1527
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___38, "Wave Master Playback Volume",
                                gpr, 0);
#line 1528
  gpr = gpr + 2;
#line 1531
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 104U, 192U, 192U, 1042U);
#line 1531
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 105U, 192U, 192U, 1043U);
#line 1532
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 110U, 192U, 192U, 1044U);
#line 1532
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 111U, 192U, 192U, 1045U);
#line 1533
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 106U, 192U, 192U, 1046U);
#line 1534
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 107U, 192U, 192U, 1047U);
  }
#line 1535
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->spk71) != 0U) {
    {
#line 1536
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 108U, 192U, 192U, 1048U);
#line 1536
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 109U, 192U, 192U, 1049U);
    }
  } else {

  }
  {
#line 1539
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 100U, 192U, 192U, 1042U);
#line 1539
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 101U, 192U, 192U, 1043U);
  }
#line 1543
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
    {
#line 1545
    __snd_printk(0U, "sound/pci/emu10k1/emufx.c", 1545, "<6>EMU outputs on\n");
#line 1546
    z = 0;
    }
#line 1546
    goto ldv_30956;
    ldv_30955: ;
#line 1547
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0108_chip) != 0U) {
      {
#line 1548
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(z + 480), (u32 )(z + 1042),
                                  192U, 192U);
      }
    } else {
      {
#line 1550
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(z + 176), (u32 )(z + 1042),
                                  192U, 192U);
      }
    }
#line 1546
    z = z + 1;
    ldv_30956: ;
#line 1546
    if (z <= 7) {
#line 1548
      goto ldv_30955;
    } else {

    }

  } else {

  }
#line 1556
  tmp___39 = gpr;
#line 1556
  gpr = gpr + 1;
#line 1556
  *(gpr_map + (unsigned long )tmp___39) = 0U;
#line 1557
  tmp___40 = gpr;
#line 1557
  gpr = gpr + 1;
#line 1557
  *(gpr_map + (unsigned long )tmp___40) = 4104U;
#line 1558
  tmp___41 = gpr;
#line 1558
  gpr = gpr + 1;
#line 1558
  *(gpr_map + (unsigned long )tmp___41) = 4294901760U;
#line 1559
  z = 0;
#line 1559
  goto ldv_30959;
  ldv_30958: 
  {
#line 1560
  snd_emu10k1_audigy_write_op(icode, & ptr, 0U, 1162U, (u32 )(z + 20), 192U, 192U);
#line 1561
  snd_emu10k1_audigy_write_op(icode, & ptr, 15U, 215U, 215U, (u32 )(gpr + 1022), 193U);
#line 1562
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 1162U, 192U, 201U, 1162U);
#line 1563
  snd_emu10k1_audigy_write_op(icode, & ptr, 8U, 1162U, 1162U, (u32 )(gpr + 1023),
                              192U);
#line 1564
  snd_emu10k1_audigy_write_op(icode, & ptr, 4U, 1160U, 192U, 1162U, (u32 )((gpr + z) + 1024));
#line 1565
  snd_emu10k1_audigy_write_op(icode, & ptr, 8U, 1161U, (u32 )((gpr + z) + 1024), 193U,
                              193U);
#line 1566
  snd_emu10k1_audigy_write_op(icode, & ptr, 4U, 1161U, 192U, (u32 )(z + 1042), 1161U);
  }
#line 1567
  if (z == 1 && (unsigned int )((unsigned char )(emu->card_capabilities)->spdif_bug) != 0U) {
    {
#line 1569
    __snd_printk(0U, "sound/pci/emu10k1/emufx.c", 1569, "<6>Installing spdif_bug patch: %s\n",
                 (emu->card_capabilities)->name);
#line 1570
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(z + 96), (u32 )(gpr + 1021),
                                192U, 192U);
#line 1571
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1021), 1160U, 1161U,
                                192U);
    }
  } else {
    {
#line 1573
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(z + 96), 1160U, 1161U, 192U);
    }
  }
#line 1559
  z = z + 1;
  ldv_30959: ;
#line 1559
  if (z <= 1) {
#line 1561
    goto ldv_30958;
  } else {

  }
  {
#line 1576
  tmp___42 = nctl;
#line 1576
  nctl = nctl + 1;
#line 1576
  snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___42, "IEC958 Optical Raw Playback Switch",
                                        gpr, 0);
#line 1577
  gpr = gpr + 2;
#line 1579
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 102U, 192U, 192U, 1044U);
#line 1579
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 103U, 192U, 192U, 1045U);
#line 1580
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 98U, 192U, 192U, 1046U);
#line 1581
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 99U, 192U, 192U, 1047U);
#line 1587
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 118U, 192U, 192U, 1050U);
#line 1588
  snd_emu10k1_audigy_write_op(icode, & ptr, 6U, 119U, 192U, 192U, 1051U);
  }
#line 1591
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->emu_model) != 0U) {
#line 1592
    if ((unsigned int )((unsigned char )(emu->card_capabilities)->ca0108_chip) != 0U) {
      {
#line 1593
      __snd_printk(0U, "sound/pci/emu10k1/emufx.c", 1593, "<6>EMU2 inputs on\n");
#line 1594
      z = 0;
      }
#line 1594
      goto ldv_30962;
      ldv_30961: 
      {
#line 1595
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                z + 352, (z + 64) * 2);
#line 1594
      z = z + 1;
      }
      ldv_30962: ;
#line 1594
      if (z <= 15) {
#line 1596
        goto ldv_30961;
      } else {

      }

    } else {
      {
#line 1601
      __snd_printk(0U, "sound/pci/emu10k1/emufx.c", 1601, "<6>EMU inputs on\n");
#line 1613
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                80, 128);
#line 1615
      tmp___43 = gpr;
#line 1615
      gpr = gpr + 1;
#line 1615
      *(gpr_map + (unsigned long )tmp___43) = 0U;
#line 1621
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 130);
#line 1622
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 81U, 192U,
                                  192U);
#line 1623
      tmp___44 = gpr;
#line 1623
      gpr = gpr + 1;
#line 1623
      *(gpr_map + (unsigned long )tmp___44) = 0U;
#line 1624
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 132);
#line 1625
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 82U, 192U,
                                  192U);
#line 1626
      tmp___45 = gpr;
#line 1626
      gpr = gpr + 1;
#line 1626
      *(gpr_map + (unsigned long )tmp___45) = 0U;
#line 1627
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 134);
#line 1628
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 83U, 192U,
                                  192U);
#line 1631
      tmp___46 = gpr;
#line 1631
      gpr = gpr + 1;
#line 1631
      *(gpr_map + (unsigned long )tmp___46) = 0U;
#line 1632
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 136);
#line 1633
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 84U, 192U,
                                  192U);
#line 1635
      tmp___47 = gpr;
#line 1635
      gpr = gpr + 1;
#line 1635
      *(gpr_map + (unsigned long )tmp___47) = 0U;
#line 1636
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 138);
#line 1637
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 85U, 192U,
                                  192U);
#line 1638
      tmp___48 = gpr;
#line 1638
      gpr = gpr + 1;
#line 1638
      *(gpr_map + (unsigned long )tmp___48) = 0U;
#line 1639
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 140);
#line 1640
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 86U, 192U,
                                  192U);
#line 1641
      tmp___49 = gpr;
#line 1641
      gpr = gpr + 1;
#line 1641
      *(gpr_map + (unsigned long )tmp___49) = 0U;
#line 1642
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 142);
#line 1643
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 87U, 192U,
                                  192U);
#line 1648
      tmp___50 = gpr;
#line 1648
      gpr = gpr + 1;
#line 1648
      *(gpr_map + (unsigned long )tmp___50) = 0U;
#line 1649
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 144);
#line 1653
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 88U, 192U,
                                  192U);
#line 1655
      tmp___51 = gpr;
#line 1655
      gpr = gpr + 1;
#line 1655
      *(gpr_map + (unsigned long )tmp___51) = 0U;
#line 1656
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 146);
#line 1660
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 89U, 192U,
                                  192U);
#line 1662
      tmp___52 = gpr;
#line 1662
      gpr = gpr + 1;
#line 1662
      *(gpr_map + (unsigned long )tmp___52) = 0U;
#line 1663
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 148);
#line 1667
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 90U, 192U,
                                  192U);
#line 1669
      tmp___53 = gpr;
#line 1669
      gpr = gpr + 1;
#line 1669
      *(gpr_map + (unsigned long )tmp___53) = 0U;
#line 1670
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 150);
#line 1674
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 91U, 192U,
                                  192U);
#line 1676
      tmp___54 = gpr;
#line 1676
      gpr = gpr + 1;
#line 1676
      *(gpr_map + (unsigned long )tmp___54) = 0U;
#line 1677
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 152);
#line 1681
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 92U, 192U,
                                  192U);
#line 1683
      tmp___55 = gpr;
#line 1683
      gpr = gpr + 1;
#line 1683
      *(gpr_map + (unsigned long )tmp___55) = 0U;
#line 1684
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 154);
#line 1688
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 93U, 192U,
                                  192U);
#line 1690
      tmp___56 = gpr;
#line 1690
      gpr = gpr + 1;
#line 1690
      *(gpr_map + (unsigned long )tmp___56) = 0U;
#line 1691
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 156);
#line 1695
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 94U, 192U,
                                  192U);
#line 1697
      tmp___57 = gpr;
#line 1697
      gpr = gpr + 1;
#line 1697
      *(gpr_map + (unsigned long )tmp___57) = 0U;
#line 1698
      snd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, & ptr, tmp, bit_shifter16,
                                                gpr + 1023, 158);
#line 1702
      snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(gpr + 1023), 95U, 192U,
                                  192U);
      }
    }
  } else {
#line 1717
    z = 0;
#line 1717
    goto ldv_30965;
    ldv_30964: 
    {
#line 1718
    snd_emu10k1_audigy_write_op(icode, & ptr, 6U, (u32 )(z + 128), 192U, 192U, (u32 )(z + 64));
#line 1717
    z = z + 1;
    }
    ldv_30965: ;
#line 1717
    if (z <= 15) {
#line 1719
      goto ldv_30964;
    } else {

    }

  }
#line 1727
  if (gpr > 136) {
    {
#line 1728
    __ret_warn_on = 1;
#line 1728
    tmp___58 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 1728
    if (tmp___58 != 0L) {
      {
#line 1728
      warn_slowpath_fmt("sound/pci/emu10k1/emufx.c", 1728, "BUG?\n");
      }
    } else {

    }
    {
#line 1728
    __builtin_expect(__ret_warn_on != 0, 0L);
#line 1729
    err = -5;
    }
#line 1730
    goto __err;
  } else {

  }
#line 1733
  goto ldv_30970;
  ldv_30969: 
  {
#line 1734
  snd_emu10k1_audigy_write_op(icode, & ptr, 15U, 192U, 192U, 207U, 192U);
  }
  ldv_30970: ;
#line 1733
  if (ptr <= 1023U) {
#line 1735
    goto ldv_30969;
  } else {

  }
  {
#line 1736
  seg = snd_enter_user();
#line 1737
  icode->gpr_add_control_count = (unsigned int )nctl;
#line 1738
  icode->gpr_add_controls = controls;
#line 1739
  emu->support_tlv = 1U;
#line 1740
  err = snd_emu10k1_icode_poke(emu, icode);
#line 1741
  emu->support_tlv = 0U;
#line 1742
  snd_leave_user(seg);
  }
  __err: 
  {
#line 1745
  kfree((void const   *)controls);
  }
#line 1746
  if ((unsigned long )icode != (unsigned long )((struct snd_emu10k1_fx8010_code *)0)) {
    {
#line 1747
    kfree((void const   *)icode->gpr_map);
#line 1748
    kfree((void const   *)icode);
    }
  } else {

  }
#line 1750
  return (err);
}
}
#line 1760 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void _volume(struct snd_emu10k1_fx8010_code *icode , u32 *ptr , u32 dst , u32 src ,
                    u32 vol ) 
{ 


  {
  {
#line 1762
  snd_emu10k1_write_op(icode, ptr, 0U, dst, 64U, src, vol);
#line 1763
  snd_emu10k1_write_op(icode, ptr, 8U, 64U, vol, 80U, 79U);
#line 1764
  snd_emu10k1_write_op(icode, ptr, 15U, 87U, 87U, 72U, 65U);
#line 1765
  snd_emu10k1_write_op(icode, ptr, 6U, dst, src, 64U, 64U);
  }
#line 1766
  return;
}
}
#line 1767 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void _volume_add(struct snd_emu10k1_fx8010_code *icode , u32 *ptr , u32 dst ,
                        u32 src , u32 vol ) 
{ 


  {
  {
#line 1769
  snd_emu10k1_write_op(icode, ptr, 8U, 64U, vol, 80U, 79U);
#line 1770
  snd_emu10k1_write_op(icode, ptr, 15U, 87U, 87U, 72U, 66U);
#line 1771
  snd_emu10k1_write_op(icode, ptr, 4U, dst, dst, src, 65U);
#line 1772
  snd_emu10k1_write_op(icode, ptr, 15U, 64U, 79U, 79U, 65U);
#line 1773
  snd_emu10k1_write_op(icode, ptr, 0U, dst, dst, src, vol);
  }
#line 1774
  return;
}
}
#line 1775 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void _volume_out(struct snd_emu10k1_fx8010_code *icode , u32 *ptr , u32 dst ,
                        u32 src , u32 vol ) 
{ 


  {
  {
#line 1777
  snd_emu10k1_write_op(icode, ptr, 8U, 64U, vol, 80U, 79U);
#line 1778
  snd_emu10k1_write_op(icode, ptr, 15U, 87U, 87U, 72U, 66U);
#line 1779
  snd_emu10k1_write_op(icode, ptr, 6U, dst, src, 64U, 64U);
#line 1780
  snd_emu10k1_write_op(icode, ptr, 15U, 64U, 79U, 79U, 65U);
#line 1781
  snd_emu10k1_write_op(icode, ptr, 0U, dst, 64U, src, vol);
  }
#line 1782
  return;
}
}
#line 1806 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int _snd_emu10k1_init_efx(struct snd_emu10k1 *emu ) 
{ 
  int err ;
  int i ;
  int z ;
  int gpr ;
  int tmp ;
  int playback ;
  int capture ;
  u32 ptr ;
  struct snd_emu10k1_fx8010_code *icode ;
  struct snd_emu10k1_fx8010_pcm_rec *ipcm ;
  struct snd_emu10k1_fx8010_control_gpr *controls ;
  struct snd_emu10k1_fx8010_control_gpr *ctl ;
  u32 *gpr_map ;
  mm_segment_t seg ;
  void *tmp___0 ;
  __u32 *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  int j ;
  int j___0 ;
  int k ;
  int l ;
  int d ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int __ret_warn_on ;
  long tmp___60 ;
  int __ret_warn_on___0 ;
  long tmp___61 ;

  {
  {
#line 1811
  ipcm = (struct snd_emu10k1_fx8010_pcm_rec *)0;
#line 1812
  controls = (struct snd_emu10k1_fx8010_control_gpr *)0;
#line 1816
  tmp___0 = kzalloc(432UL, 208U);
#line 1816
  icode = (struct snd_emu10k1_fx8010_code *)tmp___0;
  }
#line 1816
  if ((unsigned long )icode == (unsigned long )((struct snd_emu10k1_fx8010_code *)0)) {
#line 1817
    return (-12);
  } else {

  }
  {
#line 1818
  tmp___2 = kcalloc(1600UL, 4UL, 208U);
#line 1818
  tmp___1 = (__u32 *)tmp___2;
#line 1818
  icode->gpr_map = tmp___1;
  }
#line 1818
  if ((unsigned long )tmp___1 == (unsigned long )((__u32 *)0U)) {
#line 1825
    err = -12;
#line 1826
    goto __err;
  } else {
    {
#line 1818
    tmp___3 = kcalloc(44UL, 288UL, 208U);
#line 1818
    controls = (struct snd_emu10k1_fx8010_control_gpr *)tmp___3;
    }
#line 1818
    if ((unsigned long )controls == (unsigned long )((struct snd_emu10k1_fx8010_control_gpr *)0)) {
#line 1825
      err = -12;
#line 1826
      goto __err;
    } else {
      {
#line 1818
      tmp___4 = kzalloc(72UL, 208U);
#line 1818
      ipcm = (struct snd_emu10k1_fx8010_pcm_rec *)tmp___4;
      }
#line 1818
      if ((unsigned long )ipcm == (unsigned long )((struct snd_emu10k1_fx8010_pcm_rec *)0)) {
#line 1825
        err = -12;
#line 1826
        goto __err;
      } else {

      }
    }
  }
#line 1828
  gpr_map = icode->gpr_map;
#line 1830
  icode->tram_data_map = icode->gpr_map + 256UL;
#line 1831
  icode->tram_addr_map = icode->tram_data_map + 160UL;
#line 1832
  icode->code = icode->tram_addr_map + 160UL;
#line 1835
  i = 0;
#line 1835
  goto ldv_31012;
  ldv_31011: 
  {
#line 1836
  set_bit((unsigned int )i, (unsigned long volatile   *)(& icode->gpr_valid));
#line 1835
  i = i + 1;
  }
  ldv_31012: ;
#line 1835
  if (i <= 255) {
#line 1837
    goto ldv_31011;
  } else {

  }
#line 1839
  i = 0;
#line 1839
  goto ldv_31015;
  ldv_31014: 
  {
#line 1840
  set_bit((unsigned int )i, (unsigned long volatile   *)(& icode->tram_valid));
#line 1839
  i = i + 1;
  }
  ldv_31015: ;
#line 1839
  if (i <= 159) {
#line 1841
    goto ldv_31014;
  } else {

  }
  {
#line 1842
  strcpy((char *)(& icode->name), "SB Live! FX8010 code for ALSA v1.2 by Jaroslav Kysela");
#line 1843
  ptr = 0U;
#line 1843
  i = 0;
#line 1845
  playback = 12;
#line 1847
  capture = playback + 16;
#line 1848
  gpr = capture + 4;
#line 1849
  tmp = 136;
#line 1853
  tmp___5 = 0U;
#line 1853
  emu->fx8010.dbg = tmp___5;
#line 1853
  snd_emu10k1_ptr_write(emu, 82U, 0U, tmp___5 | 32768U);
#line 1858
  snd_emu10k1_write_op(icode, & ptr, 4U, 256U, 64U, 0U, 68U);
#line 1859
  snd_emu10k1_write_op(icode, & ptr, 4U, 257U, 64U, 1U, 68U);
#line 1860
  snd_emu10k1_write_op(icode, & ptr, 4U, 258U, 64U, 4U, 68U);
#line 1861
  snd_emu10k1_write_op(icode, & ptr, 4U, 259U, 64U, 5U, 68U);
#line 1862
  snd_emu10k1_write_op(icode, & ptr, 4U, 260U, 64U, 2U, 68U);
#line 1863
  snd_emu10k1_write_op(icode, & ptr, 4U, 261U, 64U, 3U, 68U);
#line 1864
  snd_emu10k1_write_op(icode, & ptr, 4U, 262U, 64U, 6U, 68U);
#line 1865
  snd_emu10k1_write_op(icode, & ptr, 4U, 263U, 64U, 7U, 68U);
#line 1866
  snd_emu10k1_write_op(icode, & ptr, 4U, 264U, 64U, 64U, 64U);
#line 1867
  snd_emu10k1_write_op(icode, & ptr, 4U, 265U, 64U, 64U, 64U);
#line 1868
  snd_emu10k1_write_op(icode, & ptr, 4U, 266U, 64U, 8U, 68U);
#line 1869
  snd_emu10k1_write_op(icode, & ptr, 4U, 267U, 64U, 9U, 68U);
#line 1872
  ipcm->substream = 0U;
#line 1873
  ipcm->channels = 2U;
#line 1874
  ipcm->tram_start = 0U;
#line 1875
  ipcm->buffer_size = 32768U;
#line 1876
  tmp___6 = gpr;
#line 1876
  gpr = gpr + 1;
#line 1876
  ipcm->gpr_size = (unsigned short )tmp___6;
#line 1877
  tmp___7 = gpr;
#line 1877
  gpr = gpr + 1;
#line 1877
  ipcm->gpr_ptr = (unsigned short )tmp___7;
#line 1878
  tmp___8 = gpr;
#line 1878
  gpr = gpr + 1;
#line 1878
  ipcm->gpr_count = (unsigned short )tmp___8;
#line 1879
  tmp___9 = gpr;
#line 1879
  gpr = gpr + 1;
#line 1879
  ipcm->gpr_tmpcount = (unsigned short )tmp___9;
#line 1880
  tmp___10 = gpr;
#line 1880
  gpr = gpr + 1;
#line 1880
  ipcm->gpr_trigger = (unsigned short )tmp___10;
#line 1881
  tmp___11 = gpr;
#line 1881
  gpr = gpr + 1;
#line 1881
  ipcm->gpr_running = (unsigned short )tmp___11;
#line 1882
  ipcm->etram[0] = 0U;
#line 1883
  ipcm->etram[1] = 1U;
#line 1885
  *(gpr_map + (unsigned long )gpr) = 4294963200U;
#line 1886
  *(gpr_map + ((unsigned long )gpr + 1UL)) = 4294901760U;
#line 1887
  *(gpr_map + ((unsigned long )gpr + 2UL)) = 1879048192U;
#line 1888
  *(gpr_map + ((unsigned long )gpr + 3UL)) = 7U;
#line 1889
  *(gpr_map + ((unsigned long )gpr + 4UL)) = 63488U;
#line 1890
  *(gpr_map + ((unsigned long )gpr + 5UL)) = 57344U;
#line 1891
  *(gpr_map + ((unsigned long )gpr + 6UL)) = 32U;
#line 1892
  *(gpr_map + ((unsigned long )gpr + 7UL)) = 27U;
#line 1893
  *(gpr_map + ((unsigned long )gpr + 8UL)) = 33558528U;
#line 1894
  *(gpr_map + ((unsigned long )gpr + 9UL)) = 67112960U;
#line 1895
  *(gpr_map + ((unsigned long )gpr + 10UL)) = 2048U;
#line 1896
  *(gpr_map + ((unsigned long )gpr + 11UL)) = 25U;
#line 1897
  *(gpr_map + ((unsigned long )gpr + 12UL)) = 0U;
#line 1900
  snd_emu10k1_write_op(icode, & ptr, 0U, 64U, (u32 )((int )ipcm->gpr_trigger + 256),
                       64U, 64U);
#line 1901
  snd_emu10k1_write_op(icode, & ptr, 15U, 87U, 87U, 69U, (u32 )(gpr + 262));
#line 1903
  snd_emu10k1_write_op(icode, & ptr, 0U, 64U, (u32 )((int )ipcm->gpr_running + 256),
                       64U, 64U);
#line 1904
  snd_emu10k1_write_op(icode, & ptr, 15U, 87U, 87U, 72U, 68U);
#line 1906
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )(tmp + 256), 91U, (u32 )(gpr + 260),
                       64U);
#line 1907
  snd_emu10k1_write_op(icode, & ptr, 4U, 64U, (u32 )(tmp + 256), 80U, (u32 )(gpr + 261));
#line 1908
  snd_emu10k1_write_op(icode, & ptr, 15U, 87U, 87U, 72U, (u32 )(gpr + 263));
#line 1909
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(gpr + 268), 70U, 65U, 64U);
#line 1911
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )((int )ipcm->gpr_running + 256), (u32 )((int )ipcm->gpr_running + 256),
                       64U, 65U);
#line 1912
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(gpr + 268), (u32 )(gpr + 268), 80U,
                       64U);
#line 1913
  snd_emu10k1_write_op(icode, & ptr, 15U, 87U, 87U, 72U, (u32 )(gpr + 267));
#line 1914
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(gpr + 268), 65U, 64U, 64U);
#line 1916
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )(tmp + 256), (u32 )((int )ipcm->etram[0] + 640),
                       (u32 )(gpr + 256), 64U);
#line 1917
  snd_emu10k1_write_op(icode, & ptr, 12U, (u32 )(tmp + 256), (u32 )(tmp + 256), (u32 )(gpr + 259),
                       64U);
#line 1918
  snd_emu10k1_write_op(icode, & ptr, 8U, 264U, (u32 )(tmp + 256), (u32 )(gpr + 257),
                       (u32 )(gpr + 258));
#line 1919
  snd_emu10k1_write_op(icode, & ptr, 15U, 64U, 87U, 68U, 65U);
#line 1920
  snd_emu10k1_write_op(icode, & ptr, 8U, 264U, 264U, (u32 )(gpr + 257), (u32 )(gpr + 258));
#line 1922
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )(tmp + 256), (u32 )((int )ipcm->etram[1] + 640),
                       (u32 )(gpr + 256), 64U);
#line 1923
  snd_emu10k1_write_op(icode, & ptr, 12U, (u32 )(tmp + 256), (u32 )(tmp + 256), (u32 )(gpr + 259),
                       64U);
#line 1924
  snd_emu10k1_write_op(icode, & ptr, 8U, 265U, (u32 )(tmp + 256), (u32 )(gpr + 257),
                       (u32 )(gpr + 258));
#line 1925
  snd_emu10k1_write_op(icode, & ptr, 15U, 64U, 87U, 68U, 65U);
#line 1926
  snd_emu10k1_write_op(icode, & ptr, 8U, 265U, 265U, (u32 )(gpr + 257), (u32 )(gpr + 258));
#line 1928
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(tmp + 256), (u32 )((int )ipcm->gpr_ptr + 256),
                       65U, 64U);
#line 1929
  snd_emu10k1_write_op(icode, & ptr, 4U, 64U, (u32 )(tmp + 256), 80U, (u32 )((int )ipcm->gpr_size + 256));
#line 1930
  snd_emu10k1_write_op(icode, & ptr, 15U, 87U, 87U, 68U, 65U);
#line 1931
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(tmp + 256), 64U, 64U, 64U);
#line 1932
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )((int )ipcm->gpr_ptr + 256), (u32 )(tmp + 256),
                       64U, 64U);
#line 1934
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )((int )ipcm->gpr_tmpcount + 256), (u32 )((int )ipcm->gpr_tmpcount + 256),
                       80U, 64U);
#line 1935
  snd_emu10k1_write_op(icode, & ptr, 15U, 87U, 87U, 72U, 66U);
#line 1936
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )((int )ipcm->gpr_tmpcount + 256), (u32 )((int )ipcm->gpr_count + 256),
                       64U, 64U);
#line 1937
  snd_emu10k1_write_op(icode, & ptr, 6U, 90U, 78U, 64U, 64U);
#line 1938
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )((int )ipcm->gpr_running + 256), (u32 )((int )ipcm->gpr_running + 256),
                       65U, 73U);
#line 1940
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )((int )ipcm->gpr_running + 256), (u32 )((int )ipcm->gpr_running + 256),
                       73U, 65U);
#line 1941
  snd_emu10k1_write_op(icode, & ptr, 15U, 64U, 79U, 79U, 66U);
#line 1943
  snd_emu10k1_write_op(icode, & ptr, 5U, (u32 )((int )ipcm->etram[0] + 896), (u32 )(gpr + 264),
                       91U, 80U);
#line 1944
  snd_emu10k1_write_op(icode, & ptr, 5U, (u32 )((int )ipcm->etram[1] + 896), (u32 )(gpr + 265),
                       91U, 80U);
#line 1947
  gpr = gpr + 13;
#line 1950
  z = 0;
  }
#line 1950
  goto ldv_31018;
  ldv_31017: 
  {
#line 1951
  _volume(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 256), (u32 )((gpr + z) + 256));
#line 1950
  z = z + 1;
  }
  ldv_31018: ;
#line 1950
  if (z <= 1) {
#line 1952
    goto ldv_31017;
  } else {

  }
  {
#line 1952
  tmp___12 = i;
#line 1952
  i = i + 1;
#line 1952
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___12, "Wave Playback Volume",
                                  gpr, 100);
#line 1953
  gpr = gpr + 2;
#line 1956
  z = 0;
  }
#line 1956
  goto ldv_31021;
  ldv_31020: 
  {
#line 1957
  _volume(icode, & ptr, (u32 )(((playback + 2) + z) + 256), (u32 )(z + 256), (u32 )((gpr + z) + 256));
#line 1956
  z = z + 1;
  }
  ldv_31021: ;
#line 1956
  if (z <= 1) {
#line 1958
    goto ldv_31020;
  } else {

  }
  {
#line 1958
  tmp___13 = i;
#line 1958
  i = i + 1;
#line 1958
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___13, "Wave Surround Playback Volume",
                                  gpr, 0);
#line 1959
  gpr = gpr + 2;
#line 1962
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(tmp + 256), 0U, 1U, 64U);
#line 1963
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(tmp + 256),
                       66U);
#line 1964
  _volume(icode, & ptr, (u32 )(playback + 260), (u32 )(tmp + 256), (u32 )(gpr + 256));
#line 1965
  tmp___14 = gpr;
#line 1965
  gpr = gpr + 1;
#line 1965
  tmp___15 = i;
#line 1965
  i = i + 1;
#line 1965
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___15, "Wave Center Playback Volume",
                                tmp___14, 0);
#line 1966
  _volume(icode, & ptr, (u32 )(playback + 261), (u32 )(tmp + 256), (u32 )(gpr + 256));
#line 1967
  tmp___16 = gpr;
#line 1967
  gpr = gpr + 1;
#line 1967
  tmp___17 = i;
#line 1967
  i = i + 1;
#line 1967
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___17, "Wave LFE Playback Volume",
                                tmp___16, 0);
#line 1970
  z = 0;
  }
#line 1970
  goto ldv_31024;
  ldv_31023: 
  {
#line 1971
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 256),
                       (u32 )(((gpr + 2) + z) + 256));
#line 1972
  _volume(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 1970
  z = z + 1;
  }
  ldv_31024: ;
#line 1970
  if (z <= 1) {
#line 1972
    goto ldv_31023;
  } else {

  }
  {
#line 1974
  tmp___18 = i;
#line 1974
  i = i + 1;
#line 1974
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___18, "Wave Capture Volume",
                                  gpr, 0);
#line 1975
  tmp___19 = i;
#line 1975
  i = i + 1;
#line 1975
  snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___19, "Wave Capture Switch",
                                        gpr + 2, 0);
#line 1976
  gpr = gpr + 4;
#line 1979
  z = 0;
  }
#line 1979
  goto ldv_31027;
  ldv_31026: 
  {
#line 1980
  _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 258), (u32 )((gpr + z) + 256));
#line 1979
  z = z + 1;
  }
  ldv_31027: ;
#line 1979
  if (z <= 1) {
#line 1981
    goto ldv_31026;
  } else {

  }
  {
#line 1981
  tmp___20 = i;
#line 1981
  i = i + 1;
#line 1981
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___20, "Synth Playback Volume",
                                  gpr, 100);
#line 1982
  gpr = gpr + 2;
#line 1985
  z = 0;
  }
#line 1985
  goto ldv_31030;
  ldv_31029: 
  {
#line 1986
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 258),
                       (u32 )(((gpr + 2) + z) + 256));
#line 1987
  _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 1985
  z = z + 1;
  }
  ldv_31030: ;
#line 1985
  if (z <= 1) {
#line 1987
    goto ldv_31029;
  } else {

  }
  {
#line 1989
  tmp___21 = i;
#line 1989
  i = i + 1;
#line 1989
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___21, "Synth Capture Volume",
                                  gpr, 0);
#line 1990
  tmp___22 = i;
#line 1990
  i = i + 1;
#line 1990
  snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___22, "Synth Capture Switch",
                                        gpr + 2, 0);
#line 1991
  gpr = gpr + 4;
#line 1994
  z = 0;
  }
#line 1994
  goto ldv_31033;
  ldv_31032: 
  {
#line 1995
  _volume_add(icode, & ptr, (u32 )(((playback + 2) + z) + 256), (u32 )(z + 260), (u32 )((gpr + z) + 256));
#line 1994
  z = z + 1;
  }
  ldv_31033: ;
#line 1994
  if (z <= 1) {
#line 1996
    goto ldv_31032;
  } else {

  }
  {
#line 1996
  tmp___23 = i;
#line 1996
  i = i + 1;
#line 1996
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___23, "Surround Digital Playback Volume",
                                  gpr, 100);
#line 1997
  gpr = gpr + 2;
#line 2000
  z = 0;
  }
#line 2000
  goto ldv_31036;
  ldv_31035: 
  {
#line 2001
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 260),
                       (u32 )(((gpr + 2) + z) + 256));
#line 2002
  _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2000
  z = z + 1;
  }
  ldv_31036: ;
#line 2000
  if (z <= 1) {
#line 2002
    goto ldv_31035;
  } else {

  }
  {
#line 2004
  tmp___24 = i;
#line 2004
  i = i + 1;
#line 2004
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___24, "Surround Capture Volume",
                                  gpr, 0);
#line 2005
  tmp___25 = i;
#line 2005
  i = i + 1;
#line 2005
  snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___25, "Surround Capture Switch",
                                        gpr + 2, 0);
#line 2006
  gpr = gpr + 4;
#line 2009
  _volume_add(icode, & ptr, (u32 )(playback + 260), 262U, (u32 )(gpr + 256));
#line 2010
  tmp___26 = gpr;
#line 2010
  gpr = gpr + 1;
#line 2010
  tmp___27 = i;
#line 2010
  i = i + 1;
#line 2010
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___27, "Center Digital Playback Volume",
                                tmp___26, 100);
#line 2013
  _volume_add(icode, & ptr, (u32 )(playback + 261), 263U, (u32 )(gpr + 256));
#line 2014
  tmp___28 = gpr;
#line 2014
  gpr = gpr + 1;
#line 2014
  tmp___29 = i;
#line 2014
  i = i + 1;
#line 2014
  snd_emu10k1_init_mono_control(controls + (unsigned long )tmp___29, "LFE Digital Playback Volume",
                                tmp___28, 100);
#line 2017
  z = 0;
  }
#line 2017
  goto ldv_31039;
  ldv_31038: 
  {
#line 2018
  _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 266), (u32 )((gpr + z) + 256));
#line 2017
  z = z + 1;
  }
  ldv_31039: ;
#line 2017
  if (z <= 1) {
#line 2019
    goto ldv_31038;
  } else {

  }
  {
#line 2019
  tmp___30 = i;
#line 2019
  i = i + 1;
#line 2019
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___30, "Front Playback Volume",
                                  gpr, 100);
#line 2020
  gpr = gpr + 2;
#line 2023
  z = 0;
  }
#line 2023
  goto ldv_31042;
  ldv_31041: 
  {
#line 2024
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 266),
                       (u32 )(gpr + 258));
#line 2025
  _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2023
  z = z + 1;
  }
  ldv_31042: ;
#line 2023
  if (z <= 1) {
#line 2025
    goto ldv_31041;
  } else {

  }
  {
#line 2027
  tmp___31 = i;
#line 2027
  i = i + 1;
#line 2027
  snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___31, "Front Capture Volume",
                                  gpr, 0);
#line 2028
  tmp___32 = i;
#line 2028
  i = i + 1;
#line 2028
  snd_emu10k1_init_mono_onoff_control(controls + (unsigned long )tmp___32, "Front Capture Switch",
                                      gpr + 2, 0);
#line 2029
  gpr = gpr + 3;
  }
#line 2035
  if (((int )emu->fx8010.extin_mask & 3) != 0) {
    {
#line 2037
    _volume_add(icode, & ptr, (u32 )(playback + 256), 16U, (u32 )(gpr + 256));
#line 2037
    gpr = gpr + 1;
#line 2038
    _volume_add(icode, & ptr, (u32 )(playback + 257), 17U, (u32 )(gpr + 256));
#line 2038
    gpr = gpr + 1;
#line 2039
    tmp___33 = i;
#line 2039
    i = i + 1;
#line 2039
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___33, "AC97 Playback Volume",
                                    gpr + -2, 0);
#line 2041
    _volume_add(icode, & ptr, (u32 )(capture + 256), 16U, (u32 )(gpr + 256));
#line 2041
    gpr = gpr + 1;
#line 2042
    _volume_add(icode, & ptr, (u32 )(capture + 257), 17U, (u32 )(gpr + 256));
#line 2042
    gpr = gpr + 1;
#line 2043
    tmp___34 = i;
#line 2043
    i = i + 1;
#line 2043
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___34, "AC97 Capture Volume",
                                    gpr + -2, 100);
    }
  } else {

  }
#line 2046
  if (((int )emu->fx8010.extin_mask & 12) != 0) {
#line 2048
    z = 0;
#line 2048
    goto ldv_31045;
    ldv_31044: 
    {
#line 2049
    _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 18), (u32 )((gpr + z) + 256));
#line 2048
    z = z + 1;
    }
    ldv_31045: ;
#line 2048
    if (z <= 1) {
#line 2050
      goto ldv_31044;
    } else {

    }
    {
#line 2050
    tmp___35 = i;
#line 2050
    i = i + 1;
#line 2050
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___35, "IEC958 TTL Playback Volume",
                                    gpr, 0);
#line 2051
    gpr = gpr + 2;
#line 2054
    z = 0;
    }
#line 2054
    goto ldv_31048;
    ldv_31047: 
    {
#line 2055
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 18),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2056
    _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2054
    z = z + 1;
    }
    ldv_31048: ;
#line 2054
    if (z <= 1) {
#line 2056
      goto ldv_31047;
    } else {

    }
    {
#line 2058
    tmp___36 = i;
#line 2058
    i = i + 1;
#line 2058
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___36, "IEC958 TTL Capture Volume",
                                    gpr, 0);
#line 2059
    tmp___37 = i;
#line 2059
    i = i + 1;
#line 2059
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___37, "IEC958 TTL Capture Switch",
                                          gpr + 2, 0);
#line 2060
    gpr = gpr + 4;
    }
  } else {

  }
#line 2063
  if (((int )emu->fx8010.extin_mask & 48) != 0) {
#line 2065
    z = 0;
#line 2065
    goto ldv_31051;
    ldv_31050: 
    {
#line 2066
    _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 20), (u32 )((gpr + z) + 256));
#line 2065
    z = z + 1;
    }
    ldv_31051: ;
#line 2065
    if (z <= 1) {
#line 2067
      goto ldv_31050;
    } else {

    }
    {
#line 2067
    tmp___38 = i;
#line 2067
    i = i + 1;
#line 2067
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___38, "Zoom Video Playback Volume",
                                    gpr, 0);
#line 2068
    gpr = gpr + 2;
#line 2071
    z = 0;
    }
#line 2071
    goto ldv_31054;
    ldv_31053: 
    {
#line 2072
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 20),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2073
    _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2071
    z = z + 1;
    }
    ldv_31054: ;
#line 2071
    if (z <= 1) {
#line 2073
      goto ldv_31053;
    } else {

    }
    {
#line 2075
    tmp___39 = i;
#line 2075
    i = i + 1;
#line 2075
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___39, "Zoom Video Capture Volume",
                                    gpr, 0);
#line 2076
    tmp___40 = i;
#line 2076
    i = i + 1;
#line 2076
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___40, "Zoom Video Capture Switch",
                                          gpr + 2, 0);
#line 2077
    gpr = gpr + 4;
    }
  } else {

  }
#line 2080
  if (((int )emu->fx8010.extin_mask & 192) != 0) {
#line 2082
    z = 0;
#line 2082
    goto ldv_31057;
    ldv_31056: 
    {
#line 2083
    _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 22), (u32 )((gpr + z) + 256));
#line 2082
    z = z + 1;
    }
    ldv_31057: ;
#line 2082
    if (z <= 1) {
#line 2084
      goto ldv_31056;
    } else {

    }
    {
#line 2084
    tmp___41 = i;
#line 2084
    i = i + 1;
#line 2084
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___41, "IEC958 LiveDrive Playback Volume",
                                    gpr, 0);
#line 2085
    gpr = gpr + 2;
#line 2088
    z = 0;
    }
#line 2088
    goto ldv_31060;
    ldv_31059: 
    {
#line 2089
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 22),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2090
    _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2088
    z = z + 1;
    }
    ldv_31060: ;
#line 2088
    if (z <= 1) {
#line 2090
      goto ldv_31059;
    } else {

    }
    {
#line 2092
    tmp___42 = i;
#line 2092
    i = i + 1;
#line 2092
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___42, "IEC958 LiveDrive Capture Volume",
                                    gpr, 0);
#line 2093
    tmp___43 = i;
#line 2093
    i = i + 1;
#line 2093
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___43, "IEC958 LiveDrive Capture Switch",
                                          gpr + 2, 0);
#line 2094
    gpr = gpr + 4;
    }
  } else {

  }
#line 2097
  if (((int )emu->fx8010.extin_mask & 768) != 0) {
#line 2099
    z = 0;
#line 2099
    goto ldv_31063;
    ldv_31062: 
    {
#line 2100
    _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 24), (u32 )((gpr + z) + 256));
#line 2099
    z = z + 1;
    }
    ldv_31063: ;
#line 2099
    if (z <= 1) {
#line 2101
      goto ldv_31062;
    } else {

    }
    {
#line 2101
    tmp___44 = i;
#line 2101
    i = i + 1;
#line 2101
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___44, "Line LiveDrive Playback Volume",
                                    gpr, 0);
#line 2102
    gpr = gpr + 2;
#line 2105
    z = 0;
    }
#line 2105
    goto ldv_31066;
    ldv_31065: 
    {
#line 2106
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 24),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2107
    _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2105
    z = z + 1;
    }
    ldv_31066: ;
#line 2105
    if (z <= 1) {
#line 2107
      goto ldv_31065;
    } else {

    }
    {
#line 2109
    tmp___45 = i;
#line 2109
    i = i + 1;
#line 2109
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___45, "Line LiveDrive Capture Volume",
                                    gpr, 0);
#line 2110
    tmp___46 = i;
#line 2110
    i = i + 1;
#line 2110
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___46, "Line LiveDrive Capture Switch",
                                          gpr + 2, 0);
#line 2111
    gpr = gpr + 4;
    }
  } else {

  }
#line 2114
  if (((int )emu->fx8010.extin_mask & 3072) != 0) {
#line 2116
    z = 0;
#line 2116
    goto ldv_31069;
    ldv_31068: 
    {
#line 2117
    _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 26), (u32 )((gpr + z) + 256));
#line 2116
    z = z + 1;
    }
    ldv_31069: ;
#line 2116
    if (z <= 1) {
#line 2118
      goto ldv_31068;
    } else {

    }
    {
#line 2118
    tmp___47 = i;
#line 2118
    i = i + 1;
#line 2118
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___47, "IEC958 Coaxial Playback Volume",
                                    gpr, 0);
#line 2119
    gpr = gpr + 2;
#line 2122
    z = 0;
    }
#line 2122
    goto ldv_31072;
    ldv_31071: 
    {
#line 2123
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 26),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2124
    _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2122
    z = z + 1;
    }
    ldv_31072: ;
#line 2122
    if (z <= 1) {
#line 2124
      goto ldv_31071;
    } else {

    }
    {
#line 2126
    tmp___48 = i;
#line 2126
    i = i + 1;
#line 2126
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___48, "IEC958 Coaxial Capture Volume",
                                    gpr, 0);
#line 2127
    tmp___49 = i;
#line 2127
    i = i + 1;
#line 2127
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___49, "IEC958 Coaxial Capture Switch",
                                          gpr + 2, 0);
#line 2128
    gpr = gpr + 4;
    }
  } else {

  }
#line 2131
  if (((int )emu->fx8010.extin_mask & 12288) != 0) {
#line 2133
    z = 0;
#line 2133
    goto ldv_31075;
    ldv_31074: 
    {
#line 2134
    _volume_add(icode, & ptr, (u32 )((playback + z) + 256), (u32 )(z + 28), (u32 )((gpr + z) + 256));
#line 2133
    z = z + 1;
    }
    ldv_31075: ;
#line 2133
    if (z <= 1) {
#line 2135
      goto ldv_31074;
    } else {

    }
    {
#line 2135
    tmp___50 = i;
#line 2135
    i = i + 1;
#line 2135
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___50, "Line2 LiveDrive Playback Volume",
                                    gpr, 0);
#line 2136
    (controls + ((unsigned long )i + 0xffffffffffffffffUL))->id.index = 1U;
#line 2137
    gpr = gpr + 2;
#line 2140
    z = 0;
    }
#line 2140
    goto ldv_31078;
    ldv_31077: 
    {
#line 2141
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 28),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2142
    _volume_add(icode, & ptr, (u32 )((capture + z) + 256), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2140
    z = z + 1;
    }
    ldv_31078: ;
#line 2140
    if (z <= 1) {
#line 2142
      goto ldv_31077;
    } else {

    }
    {
#line 2144
    tmp___51 = i;
#line 2144
    i = i + 1;
#line 2144
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___51, "Line2 LiveDrive Capture Volume",
                                    gpr, 0);
#line 2145
    (controls + ((unsigned long )i + 0xffffffffffffffffUL))->id.index = 1U;
#line 2146
    tmp___52 = i;
#line 2146
    i = i + 1;
#line 2146
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___52, "Line2 LiveDrive Capture Switch",
                                          gpr + 2, 0);
#line 2147
    (controls + ((unsigned long )i + 0xffffffffffffffffUL))->id.index = 1U;
#line 2148
    gpr = gpr + 4;
    }
  } else {

  }
  {
#line 2154
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(playback + 264), (u32 )(playback + 256),
                       64U, 64U);
#line 2155
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(playback + 265), (u32 )(playback + 257),
                       64U, 64U);
#line 2156
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(playback + 266), (u32 )(playback + 258),
                       64U, 64U);
#line 2157
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(playback + 267), (u32 )(playback + 259),
                       64U, 64U);
#line 2158
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(playback + 268), (u32 )(playback + 260),
                       64U, 64U);
#line 2159
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(playback + 269), (u32 )(playback + 261),
                       64U, 64U);
#line 2161
  ctl = controls + (unsigned long )i;
#line 2162
  ctl->id.iface = 2;
#line 2163
  strcpy((char *)(& ctl->id.name), "Tone Control - Bass");
#line 2164
  ctl->vcount = 2U;
#line 2165
  ctl->count = 10U;
#line 2166
  ctl->min = 0U;
#line 2167
  ctl->max = 40U;
#line 2168
  tmp___53 = 20U;
#line 2168
  ctl->value[1] = tmp___53;
#line 2168
  ctl->value[0] = tmp___53;
#line 2169
  ctl->tlv = (unsigned int const   *)(& snd_emu10k1_bass_treble_db_scale);
#line 2170
  ctl->translation = 2U;
#line 2171
  ctl = controls + ((unsigned long )i + 1UL);
#line 2172
  ctl->id.iface = 2;
#line 2173
  strcpy((char *)(& ctl->id.name), "Tone Control - Treble");
#line 2174
  ctl->vcount = 2U;
#line 2175
  ctl->count = 10U;
#line 2176
  ctl->min = 0U;
#line 2177
  ctl->max = 40U;
#line 2178
  tmp___54 = 20U;
#line 2178
  ctl->value[1] = tmp___54;
#line 2178
  ctl->value[0] = tmp___54;
#line 2179
  ctl->tlv = (unsigned int const   *)(& snd_emu10k1_bass_treble_db_scale);
#line 2180
  ctl->translation = 3U;
#line 2185
  z = 0;
  }
#line 2185
  goto ldv_31085;
  ldv_31084: 
#line 2187
  j = 0;
#line 2187
  goto ldv_31082;
  ldv_31081: 
#line 2188
  (controls + (unsigned long )i)->gpr[z * 2 + j] = (unsigned int )((unsigned short )(z + 70)) * 2U + (unsigned int )((unsigned short )j);
#line 2189
  (controls + ((unsigned long )i + 1UL))->gpr[z * 2 + j] = (unsigned int )((unsigned short )(z + 75)) * 2U + (unsigned int )((unsigned short )j);
#line 2187
  j = j + 1;
  ldv_31082: ;
#line 2187
  if (j <= 1) {
#line 2189
    goto ldv_31081;
  } else {

  }
#line 2185
  z = z + 1;
  ldv_31085: ;
#line 2185
  if (z <= 4) {
#line 2187
    goto ldv_31084;
  } else {

  }
#line 2192
  z = 0;
#line 2192
  goto ldv_31095;
  ldv_31094: 
#line 2194
  j___0 = 0;
#line 2194
  goto ldv_31093;
  ldv_31092: 
  {
#line 2195
  k = ((z + 20) * 2 + j___0) * 4;
#line 2196
  l = ((z + 26) * 2 + j___0) * 4;
#line 2197
  d = ((playback + 8) + z * 2) + j___0;
#line 2199
  snd_emu10k1_write_op(icode, & ptr, 0U, 64U, 64U, (u32 )(d + 256), (u32 )(j___0 + 396));
#line 2200
  snd_emu10k1_write_op(icode, & ptr, 7U, (u32 )(k + 257), (u32 )(k + 256), (u32 )(k + 257),
                       (u32 )(j___0 + 400));
#line 2201
  snd_emu10k1_write_op(icode, & ptr, 7U, (u32 )(k + 256), (u32 )(d + 256), (u32 )(k + 256),
                       (u32 )(j___0 + 398));
#line 2202
  snd_emu10k1_write_op(icode, & ptr, 7U, (u32 )(k + 259), (u32 )(k + 258), (u32 )(k + 259),
                       (u32 )(j___0 + 404));
#line 2203
  snd_emu10k1_write_op(icode, & ptr, 0U, (u32 )(k + 258), 86U, (u32 )(k + 258), (u32 )(j___0 + 402));
#line 2204
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(k + 258), (u32 )(k + 258), (u32 )(k + 258),
                       64U);
#line 2206
  snd_emu10k1_write_op(icode, & ptr, 0U, 64U, 64U, (u32 )(k + 258), (u32 )(j___0 + 406));
#line 2207
  snd_emu10k1_write_op(icode, & ptr, 7U, (u32 )(l + 257), (u32 )(l + 256), (u32 )(l + 257),
                       (u32 )(j___0 + 410));
#line 2208
  snd_emu10k1_write_op(icode, & ptr, 7U, (u32 )(l + 256), (u32 )(k + 258), (u32 )(l + 256),
                       (u32 )(j___0 + 408));
#line 2209
  snd_emu10k1_write_op(icode, & ptr, 7U, (u32 )(l + 259), (u32 )(l + 258), (u32 )(l + 259),
                       (u32 )(j___0 + 414));
#line 2210
  snd_emu10k1_write_op(icode, & ptr, 0U, (u32 )(l + 258), 86U, (u32 )(l + 258), (u32 )(j___0 + 412));
#line 2211
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(l + 258), 64U, (u32 )(l + 258), 70U);
#line 2213
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(d + 256), (u32 )(l + 258), 64U, 64U);
  }
#line 2215
  if (z == 2) {
#line 2216
    goto ldv_31091;
  } else {

  }
#line 2194
  j___0 = j___0 + 1;
  ldv_31093: ;
#line 2194
  if (j___0 <= 1) {
#line 2196
    goto ldv_31092;
  } else {

  }
  ldv_31091: 
#line 2192
  z = z + 1;
  ldv_31095: ;
#line 2192
  if (z <= 2) {
#line 2194
    goto ldv_31094;
  } else {

  }
#line 2219
  i = i + 2;
#line 2224
  z = 0;
#line 2224
  goto ldv_31098;
  ldv_31097: 
  {
#line 2225
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(((playback + 8) + z) + 256),
                       (u32 )(gpr + 256));
#line 2226
  snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )(tmp + 257), (u32 )(gpr + 256), 65U,
                       65U);
#line 2227
  snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 257), 64U, (u32 )((playback + z) + 256),
                       (u32 )(tmp + 257));
#line 2228
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(((playback + 8) + z) + 256), (u32 )(tmp + 256),
                       (u32 )(tmp + 257), 64U);
#line 2224
  z = z + 1;
  }
  ldv_31098: ;
#line 2224
  if (z <= 5) {
#line 2226
    goto ldv_31097;
  } else {

  }
  {
#line 2230
  tmp___55 = i;
#line 2230
  i = i + 1;
#line 2230
  snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___55, "Tone Control - Switch",
                                        gpr, 0);
#line 2231
  gpr = gpr + 2;
  }
#line 2236
  if (((int )emu->fx8010.extout_mask & 3) != 0) {
#line 2239
    z = 0;
#line 2239
    goto ldv_31101;
    ldv_31100: 
    {
#line 2240
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 32), (u32 )(((playback + 8) + z) + 256),
                         64U, 64U);
#line 2239
    z = z + 1;
    }
    ldv_31101: ;
#line 2239
    if (z <= 1) {
#line 2241
      goto ldv_31100;
    } else {

    }

  } else {

  }
#line 2243
  if (((int )emu->fx8010.extout_mask & 12) != 0) {
#line 2246
    z = 0;
#line 2246
    goto ldv_31104;
    ldv_31103: 
    {
#line 2247
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(z + 264),
                         (u32 )((gpr + z) + 256));
#line 2248
    snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )(tmp + 257), (u32 )((gpr + z) + 256),
                         65U, 65U);
#line 2249
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 257), 64U, (u32 )(((playback + 8) + z) + 256),
                         (u32 )(tmp + 257));
#line 2250
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 34), (u32 )(tmp + 256), (u32 )(tmp + 257),
                         64U);
#line 2246
    z = z + 1;
    }
    ldv_31104: ;
#line 2246
    if (z <= 1) {
#line 2248
      goto ldv_31103;
    } else {

    }
    {
#line 2256
    tmp___56 = i;
#line 2256
    i = i + 1;
#line 2256
    snd_emu10k1_init_stereo_onoff_control(controls + (unsigned long )tmp___56, "IEC958 Optical Raw Playback Switch",
                                          gpr, 0);
#line 2257
    gpr = gpr + 2;
    }
  } else {

  }
#line 2260
  if (((int )emu->fx8010.extout_mask & 192) != 0) {
#line 2263
    z = 0;
#line 2263
    goto ldv_31107;
    ldv_31106: 
    {
#line 2264
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 256), 64U, (u32 )(((playback + 12) + z) + 256),
                         (u32 )(((gpr + 2) + z) + 256));
#line 2265
    snd_emu10k1_write_op(icode, & ptr, 8U, (u32 )(tmp + 257), (u32 )(((gpr + 2) + z) + 256),
                         65U, 65U);
#line 2266
    snd_emu10k1_write_op(icode, & ptr, 4U, (u32 )(tmp + 257), 64U, (u32 )(((playback + 8) + z) + 256),
                         (u32 )(tmp + 257));
#line 2267
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(tmp + 256), (u32 )(tmp + 256), (u32 )(tmp + 257),
                         64U);
#line 2268
    _volume_out(icode, & ptr, (u32 )(z + 38), (u32 )(tmp + 256), (u32 )((gpr + z) + 256));
#line 2263
    z = z + 1;
    }
    ldv_31107: ;
#line 2263
    if (z <= 1) {
#line 2265
      goto ldv_31106;
    } else {

    }
    {
#line 2271
    tmp___57 = i;
#line 2271
    i = i + 1;
#line 2271
    snd_emu10k1_init_stereo_control(controls + (unsigned long )tmp___57, "Headphone Playback Volume",
                                    gpr, 0);
#line 2272
    (controls + ((unsigned long )i + 0xffffffffffffffffUL))->id.index = 1U;
#line 2273
    tmp___58 = i;
#line 2273
    i = i + 1;
#line 2273
    snd_emu10k1_init_mono_onoff_control(controls + (unsigned long )tmp___58, "Headphone Center Playback Switch",
                                        gpr + 2, 0);
#line 2274
    (controls + ((unsigned long )i + 0xffffffffffffffffUL))->id.index = 1U;
#line 2275
    tmp___59 = i;
#line 2275
    i = i + 1;
#line 2275
    snd_emu10k1_init_mono_onoff_control(controls + (unsigned long )tmp___59, "Headphone LFE Playback Switch",
                                        gpr + 3, 0);
#line 2276
    (controls + ((unsigned long )i + 0xffffffffffffffffUL))->id.index = 1U;
#line 2278
    gpr = gpr + 4;
    }
  } else {

  }
#line 2281
  if (((int )emu->fx8010.extout_mask & 768) != 0) {
#line 2282
    z = 0;
#line 2282
    goto ldv_31110;
    ldv_31109: 
    {
#line 2283
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 40), (u32 )(((playback + 10) + z) + 256),
                         64U, 64U);
#line 2282
    z = z + 1;
    }
    ldv_31110: ;
#line 2282
    if (z <= 1) {
#line 2284
      goto ldv_31109;
    } else {

    }

  } else {

  }
#line 2285
  if (((int )emu->fx8010.extout_mask & 24576) != 0) {
#line 2286
    z = 0;
#line 2286
    goto ldv_31113;
    ldv_31112: 
    {
#line 2287
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 45), (u32 )(((playback + 10) + z) + 256),
                         64U, 64U);
#line 2286
    z = z + 1;
    }
    ldv_31113: ;
#line 2286
    if (z <= 1) {
#line 2288
      goto ldv_31112;
    } else {

    }

  } else {

  }
#line 2289
  if (((int )emu->fx8010.extout_mask & 16) != 0) {
    {
#line 2291
    snd_emu10k1_write_op(icode, & ptr, 6U, 36U, (u32 )(playback + 268), 64U, 64U);
#line 2292
    snd_emu10k1_write_op(icode, & ptr, 6U, 49U, (u32 )(playback + 268), 64U, 64U);
    }
  } else {

  }
#line 2299
  if (((int )emu->fx8010.extout_mask & 32) != 0) {
    {
#line 2301
    snd_emu10k1_write_op(icode, & ptr, 6U, 37U, (u32 )(playback + 269), 64U, 64U);
#line 2302
    snd_emu10k1_write_op(icode, & ptr, 6U, 50U, (u32 )(playback + 269), 64U, 64U);
    }
  } else {

  }
#line 2310
  z = 0;
#line 2310
  goto ldv_31116;
  ldv_31115: 
  {
#line 2311
  snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 42), (u32 )((capture + z) + 256),
                       64U, 64U);
#line 2310
  z = z + 1;
  }
  ldv_31116: ;
#line 2310
  if (z <= 1) {
#line 2312
    goto ldv_31115;
  } else {

  }

#line 2314
  if (((int )emu->fx8010.extout_mask & 4096) != 0) {
    {
#line 2315
    snd_emu10k1_write_op(icode, & ptr, 6U, 44U, (u32 )(capture + 258), 64U, 64U);
    }
  } else {

  }
#line 2318
  if ((unsigned int )((unsigned char )(emu->card_capabilities)->sblive51) != 0U) {
    {
#line 2328
    snd_emu10k1_write_op(icode, & ptr, 6U, 62U, 64U, 64U, 16U);
#line 2329
    snd_emu10k1_write_op(icode, & ptr, 6U, 63U, 64U, 64U, 17U);
#line 2330
    snd_emu10k1_write_op(icode, & ptr, 6U, 48U, 64U, 64U, 18U);
#line 2331
    snd_emu10k1_write_op(icode, & ptr, 6U, 51U, 64U, 64U, 19U);
#line 2332
    z = 4;
    }
#line 2332
    goto ldv_31119;
    ldv_31118: 
    {
#line 2333
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 48), 64U, 64U, (u32 )(z + 16));
#line 2332
    z = z + 1;
    }
    ldv_31119: ;
#line 2332
    if (z <= 13) {
#line 2334
      goto ldv_31118;
    } else {

    }

  } else {
#line 2335
    z = 0;
#line 2335
    goto ldv_31122;
    ldv_31121: 
    {
#line 2336
    snd_emu10k1_write_op(icode, & ptr, 6U, (u32 )(z + 48), 64U, 64U, (u32 )(z + 16));
#line 2335
    z = z + 1;
    }
    ldv_31122: ;
#line 2335
    if (z <= 15) {
#line 2337
      goto ldv_31121;
    } else {

    }

  }
#line 2340
  if (gpr > tmp) {
    {
#line 2341
    __ret_warn_on = 1;
#line 2341
    tmp___60 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 2341
    if (tmp___60 != 0L) {
      {
#line 2341
      warn_slowpath_fmt("sound/pci/emu10k1/emufx.c", 2341, "BUG?\n");
      }
    } else {

    }
    {
#line 2341
    __builtin_expect(__ret_warn_on != 0, 0L);
#line 2342
    err = -5;
    }
#line 2343
    goto __err;
  } else {

  }
#line 2345
  if (i > 44) {
    {
#line 2346
    __ret_warn_on___0 = 1;
#line 2346
    tmp___61 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
    }
#line 2346
    if (tmp___61 != 0L) {
      {
#line 2346
      warn_slowpath_fmt("sound/pci/emu10k1/emufx.c", 2346, "BUG?\n");
      }
    } else {

    }
    {
#line 2346
    __builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 2347
    err = -5;
    }
#line 2348
    goto __err;
  } else {

  }
#line 2352
  goto ldv_31129;
  ldv_31128: 
  {
#line 2353
  snd_emu10k1_write_op(icode, & ptr, 6U, 64U, 64U, 64U, 64U);
  }
  ldv_31129: ;
#line 2352
  if (ptr <= 511U) {
#line 2354
    goto ldv_31128;
  } else {

  }
  {
#line 2355
  err = snd_emu10k1_fx8010_tram_setup(emu, ipcm->buffer_size);
  }
#line 2355
  if (err < 0) {
#line 2356
    goto __err;
  } else {

  }
  {
#line 2357
  seg = snd_enter_user();
#line 2358
  icode->gpr_add_control_count = (unsigned int )i;
#line 2359
  icode->gpr_add_controls = controls;
#line 2360
  emu->support_tlv = 1U;
#line 2361
  err = snd_emu10k1_icode_poke(emu, icode);
#line 2362
  emu->support_tlv = 0U;
#line 2363
  snd_leave_user(seg);
  }
#line 2364
  if (err >= 0) {
    {
#line 2365
    err = snd_emu10k1_ipcm_poke(emu, ipcm);
    }
  } else {

  }
  __err: 
  {
#line 2367
  kfree((void const   *)ipcm);
#line 2368
  kfree((void const   *)controls);
  }
#line 2369
  if ((unsigned long )icode != (unsigned long )((struct snd_emu10k1_fx8010_code *)0)) {
    {
#line 2370
    kfree((void const   *)icode->gpr_map);
#line 2371
    kfree((void const   *)icode);
    }
  } else {

  }
#line 2373
  return (err);
}
}
#line 2376 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
int snd_emu10k1_init_efx(struct snd_emu10k1 *emu ) 
{ 
  struct lock_class_key __key ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2378
  spinlock_check(& emu->fx8010.irq_lock);
#line 2378
  __raw_spin_lock_init(& emu->fx8010.irq_lock.__annonCompField19.rlock, "&(&emu->fx8010.irq_lock)->rlock",
                       & __key);
#line 2379
  INIT_LIST_HEAD(& emu->fx8010.gpr_ctl);
  }
#line 2380
  if (emu->audigy != 0U) {
    {
#line 2381
    tmp = _snd_emu10k1_audigy_init_efx(emu);
    }
#line 2381
    return (tmp);
  } else {
    {
#line 2383
    tmp___0 = _snd_emu10k1_init_efx(emu);
    }
#line 2383
    return (tmp___0);
  }
}
}
#line 2386 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
void snd_emu10k1_free_efx(struct snd_emu10k1 *emu ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 2389
  if (emu->audigy != 0U) {
    {
#line 2390
    tmp = 131072U;
#line 2390
    emu->fx8010.dbg = tmp;
#line 2390
    snd_emu10k1_ptr_write(emu, 83U, 0U, tmp);
    }
  } else {
    {
#line 2392
    tmp___0 = 32768U;
#line 2392
    emu->fx8010.dbg = tmp___0;
#line 2392
    snd_emu10k1_ptr_write(emu, 82U, 0U, tmp___0);
    }
  }
#line 2393
  return;
}
}
#line 2413 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
int snd_emu10k1_fx8010_tram_setup(struct snd_emu10k1 *emu , u32 size ) 
{ 
  u8 size_reg ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 2415
  size_reg = 0U;
#line 2418
  if (size != 0U) {
#line 2419
    size = (size - 1U) >> 13;
#line 2421
    goto ldv_31144;
    ldv_31143: 
#line 2422
    size = size >> 1;
#line 2423
    size_reg = (u8 )((int )size_reg + 1);
    ldv_31144: ;
#line 2421
    if (size != 0U) {
#line 2423
      goto ldv_31143;
    } else {

    }
#line 2425
    size = (u32 )(8192 << (int )size_reg);
  } else {

  }
#line 2427
  if (emu->fx8010.etram_pages.bytes / 2UL == (size_t )size) {
#line 2428
    return (0);
  } else {

  }
  {
#line 2429
  ldv_spin_lock_irq_45___0(& emu->emu_lock);
#line 2430
  tmp = inl((int )((unsigned int )emu->port + 20U));
#line 2430
  outl(tmp | 4U, (int )((unsigned int )emu->port + 20U));
#line 2431
  ldv_spin_unlock_irq_46___0(& emu->emu_lock);
#line 2432
  snd_emu10k1_ptr_write(emu, 65U, 0U, 0U);
#line 2433
  snd_emu10k1_ptr_write(emu, 68U, 0U, 0U);
  }
#line 2434
  if ((unsigned long )emu->fx8010.etram_pages.area != (unsigned long )((unsigned char *)0U)) {
    {
#line 2435
    snd_dma_free_pages(& emu->fx8010.etram_pages);
#line 2436
    emu->fx8010.etram_pages.area = (unsigned char *)0U;
#line 2437
    emu->fx8010.etram_pages.bytes = 0UL;
    }
  } else {

  }
#line 2440
  if (size != 0U) {
    {
#line 2441
    tmp___0 = snd_dma_alloc_pages(2, & (emu->pci)->dev, (size_t )(size * 2U), & emu->fx8010.etram_pages);
    }
#line 2441
    if (tmp___0 < 0) {
#line 2443
      return (-12);
    } else {

    }
    {
#line 2444
    memset((void *)emu->fx8010.etram_pages.area, 0, (size_t )(size * 2U));
#line 2445
    snd_emu10k1_ptr_write(emu, 65U, 0U, (unsigned int )emu->fx8010.etram_pages.addr);
#line 2446
    snd_emu10k1_ptr_write(emu, 68U, 0U, (unsigned int )size_reg);
#line 2447
    ldv_spin_lock_irq_45___0(& emu->emu_lock);
#line 2448
    tmp___1 = inl((int )((unsigned int )emu->port + 20U));
#line 2448
    outl(tmp___1 & 4294967291U, (int )((unsigned int )emu->port + 20U));
#line 2449
    ldv_spin_unlock_irq_46___0(& emu->emu_lock);
    }
  } else {

  }
#line 2452
  return (0);
}
}
#line 2455 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_fx8010_open(struct snd_hwdep *hw , struct file *file ) 
{ 


  {
#line 2457
  return (0);
}
}
#line 2460 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void copy_string(char *dst , char *src , char *null , int idx ) 
{ 


  {
#line 2462
  if ((unsigned long )src == (unsigned long )((char *)0)) {
    {
#line 2463
    sprintf(dst, "%s %02X", null, idx);
    }
  } else {
    {
#line 2465
    strcpy(dst, (char const   *)src);
    }
  }
#line 2466
  return;
}
}
#line 2468 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static void snd_emu10k1_fx8010_info(struct snd_emu10k1 *emu , struct snd_emu10k1_fx8010_info *info ) 
{ 
  char **fxbus ;
  char **extin___0 ;
  char **extout___0 ;
  unsigned short fxbus_mask ;
  unsigned short extin_mask ;
  unsigned short extout_mask ;
  int res ;

  {
#line 2475
  info->internal_tram_size = emu->fx8010.itram_size;
#line 2476
  info->external_tram_size = (unsigned int )(emu->fx8010.etram_pages.bytes / 2UL);
#line 2477
  fxbus = (char **)(& fxbuses);
#line 2478
  extin___0 = emu->audigy != 0U ? (char **)(& audigy_ins) : (char **)(& creative_ins);
#line 2479
  extout___0 = emu->audigy != 0U ? (char **)(& audigy_outs) : (char **)(& creative_outs);
#line 2480
  fxbus_mask = emu->fx8010.fxbus_mask;
#line 2481
  extin_mask = emu->fx8010.extin_mask;
#line 2482
  extout_mask = emu->fx8010.extout_mask;
#line 2483
  res = 0;
#line 2483
  goto ldv_31168;
  ldv_31167: 
  {
#line 2484
  copy_string((char *)((char (*)[32])(& info->fxbus_names) + (unsigned long )res),
              ((int )fxbus_mask >> res) & 1 ? *fxbus : (char *)0, (char *)"FXBUS",
              res);
#line 2485
  copy_string((char *)((char (*)[32])(& info->extin_names) + (unsigned long )res),
              ((int )extin_mask >> res) & 1 ? *extin___0 : (char *)0, (char *)"Unused",
              res);
#line 2486
  copy_string((char *)((char (*)[32])(& info->extout_names) + (unsigned long )res),
              ((int )extout_mask >> res) & 1 ? *extout___0 : (char *)0, (char *)"Unused",
              res);
#line 2483
  res = res + 1;
#line 2483
  fxbus = fxbus + 1;
#line 2483
  extin___0 = extin___0 + 1;
#line 2483
  extout___0 = extout___0 + 1;
  }
  ldv_31168: ;
#line 2483
  if (res <= 15) {
#line 2485
    goto ldv_31167;
  } else {

  }
#line 2488
  res = 16;
#line 2488
  goto ldv_31171;
  ldv_31170: 
  {
#line 2489
  copy_string((char *)((char (*)[32])(& info->extout_names) + (unsigned long )res),
              ((int )extout_mask >> res) & 1 ? *extout___0 : (char *)0, (char *)"Unused",
              res);
#line 2488
  res = res + 1;
#line 2488
  extout___0 = extout___0 + 1;
  }
  ldv_31171: ;
#line 2488
  if (res <= 31) {
#line 2490
    goto ldv_31170;
  } else {

  }
#line 2490
  info->gpr_controls = (unsigned int )emu->fx8010.gpr_count;
#line 2491
  return;
}
}
#line 2493 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_fx8010_ioctl(struct snd_hwdep *hw , struct file *file , unsigned int cmd ,
                                    unsigned long arg ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_fx8010_info *info ;
  struct snd_emu10k1_fx8010_code *icode ;
  struct snd_emu10k1_fx8010_pcm_rec *ipcm ;
  unsigned int addr ;
  void *argp ;
  int res ;
  int __ret_pu ;
  int __pu_val ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  bool tmp___19 ;
  int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  bool tmp___23 ;
  int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  bool tmp___27 ;
  int tmp___28 ;
  bool tmp___29 ;
  int tmp___30 ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  int __ret_pu___0 ;
  unsigned int __pu_val___0 ;

  {
#line 2495
  emu = (struct snd_emu10k1 *)hw->private_data;
#line 2500
  argp = (void *)arg;
  {
#line 2504
  if (cmd == 2147764288U) {
#line 2504
    goto case_2147764288;
  } else {

  }
#line 2507
  if (cmd == 2282506256U) {
#line 2507
    goto case_2282506256;
  } else {

  }
#line 2518
  if (cmd == 1102071825U) {
#line 2518
    goto case_1102071825;
  } else {

  }
#line 2528
  if (cmd == 3249555474U) {
#line 2528
    goto case_3249555474;
  } else {

  }
#line 2539
  if (cmd == 1078478896U) {
#line 2539
    goto case_1078478896;
  } else {

  }
#line 2546
  if (cmd == 3225962545U) {
#line 2546
    goto case_3225962545;
  } else {

  }
#line 2557
  if (cmd == 1074022432U) {
#line 2557
    goto case_1074022432;
  } else {

  }
#line 2566
  if (cmd == 18560U) {
#line 2566
    goto case_18560;
  } else {

  }
#line 2574
  if (cmd == 18561U) {
#line 2574
    goto case_18561;
  } else {

  }
#line 2582
  if (cmd == 18562U) {
#line 2582
    goto case_18562;
  } else {

  }
#line 2595
  if (cmd == 1074022531U) {
#line 2595
    goto case_1074022531;
  } else {

  }
#line 2612
  if (cmd == 2147764356U) {
#line 2612
    goto case_2147764356;
  } else {

  }
#line 2503
  goto switch_break;
  case_2147764288: /* CIL Label */ 
  {
#line 2505
  emu->support_tlv = 1U;
#line 2506
  might_fault();
#line 2506
  __pu_val = 65537;
  }
  {
#line 2506
  if (4UL == 1UL) {
#line 2506
    goto case_1;
  } else {

  }
#line 2506
  if (4UL == 2UL) {
#line 2506
    goto case_2;
  } else {

  }
#line 2506
  if (4UL == 4UL) {
#line 2506
    goto case_4;
  } else {

  }
#line 2506
  if (4UL == 8UL) {
#line 2506
    goto case_8;
  } else {

  }
#line 2506
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2506
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" ((int *)argp): "ebx");
#line 2506
  goto ldv_31190;
  case_2: /* CIL Label */ 
#line 2506
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" ((int *)argp): "ebx");
#line 2506
  goto ldv_31190;
  case_4: /* CIL Label */ 
#line 2506
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" ((int *)argp): "ebx");
#line 2506
  goto ldv_31190;
  case_8: /* CIL Label */ 
#line 2506
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" ((int *)argp): "ebx");
#line 2506
  goto ldv_31190;
  switch_default: /* CIL Label */ 
#line 2506
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" ((int *)argp): "ebx");
#line 2506
  goto ldv_31190;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_31190: ;
#line 2506
  return (__ret_pu);
  case_2282506256: /* CIL Label */ 
  {
#line 2508
  tmp = kmalloc(2060UL, 208U);
#line 2508
  info = (struct snd_emu10k1_fx8010_info *)tmp;
  }
#line 2509
  if ((unsigned long )info == (unsigned long )((struct snd_emu10k1_fx8010_info *)0)) {
#line 2510
    return (-12);
  } else {

  }
  {
#line 2511
  snd_emu10k1_fx8010_info(emu, info);
#line 2512
  tmp___0 = copy_to_user(argp, (void const   *)info, 2060U);
  }
#line 2512
  if (tmp___0 != 0) {
    {
#line 2513
    kfree((void const   *)info);
    }
#line 2514
    return (-14);
  } else {

  }
  {
#line 2516
  kfree((void const   *)info);
  }
#line 2517
  return (0);
  case_1102071825: /* CIL Label */ 
  {
#line 2519
  tmp___1 = capable(21);
  }
#line 2519
  if (tmp___1) {
#line 2519
    tmp___2 = 0;
  } else {
#line 2519
    tmp___2 = 1;
  }
#line 2519
  if (tmp___2) {
#line 2520
    return (-1);
  } else {

  }
  {
#line 2522
  tmp___3 = memdup_user((void const   *)argp, 432UL);
#line 2522
  icode = (struct snd_emu10k1_fx8010_code *)tmp___3;
#line 2523
  tmp___5 = IS_ERR((void const   *)icode);
  }
#line 2523
  if (tmp___5 != 0L) {
    {
#line 2524
    tmp___4 = PTR_ERR((void const   *)icode);
    }
#line 2524
    return ((int )tmp___4);
  } else {

  }
  {
#line 2525
  res = snd_emu10k1_icode_poke(emu, icode);
#line 2526
  kfree((void const   *)icode);
  }
#line 2527
  return (res);
  case_3249555474: /* CIL Label */ 
  {
#line 2529
  tmp___6 = memdup_user((void const   *)argp, 432UL);
#line 2529
  icode = (struct snd_emu10k1_fx8010_code *)tmp___6;
#line 2530
  tmp___8 = IS_ERR((void const   *)icode);
  }
#line 2530
  if (tmp___8 != 0L) {
    {
#line 2531
    tmp___7 = PTR_ERR((void const   *)icode);
    }
#line 2531
    return ((int )tmp___7);
  } else {

  }
  {
#line 2532
  res = snd_emu10k1_icode_peek(emu, icode);
  }
#line 2533
  if (res == 0) {
    {
#line 2533
    tmp___9 = copy_to_user(argp, (void const   *)icode, 432U);
    }
#line 2533
    if (tmp___9 != 0) {
      {
#line 2534
      kfree((void const   *)icode);
      }
#line 2535
      return (-14);
    } else {

    }
  } else {

  }
  {
#line 2537
  kfree((void const   *)icode);
  }
#line 2538
  return (res);
  case_1078478896: /* CIL Label */ 
  {
#line 2540
  tmp___10 = memdup_user((void const   *)argp, 72UL);
#line 2540
  ipcm = (struct snd_emu10k1_fx8010_pcm_rec *)tmp___10;
#line 2541
  tmp___12 = IS_ERR((void const   *)ipcm);
  }
#line 2541
  if (tmp___12 != 0L) {
    {
#line 2542
    tmp___11 = PTR_ERR((void const   *)ipcm);
    }
#line 2542
    return ((int )tmp___11);
  } else {

  }
  {
#line 2543
  res = snd_emu10k1_ipcm_poke(emu, ipcm);
#line 2544
  kfree((void const   *)ipcm);
  }
#line 2545
  return (res);
  case_3225962545: /* CIL Label */ 
  {
#line 2547
  tmp___13 = memdup_user((void const   *)argp, 72UL);
#line 2547
  ipcm = (struct snd_emu10k1_fx8010_pcm_rec *)tmp___13;
#line 2548
  tmp___15 = IS_ERR((void const   *)ipcm);
  }
#line 2548
  if (tmp___15 != 0L) {
    {
#line 2549
    tmp___14 = PTR_ERR((void const   *)ipcm);
    }
#line 2549
    return ((int )tmp___14);
  } else {

  }
  {
#line 2550
  res = snd_emu10k1_ipcm_peek(emu, ipcm);
  }
#line 2551
  if (res == 0) {
    {
#line 2551
    tmp___16 = copy_to_user(argp, (void const   *)ipcm, 72U);
    }
#line 2551
    if (tmp___16 != 0) {
      {
#line 2552
      kfree((void const   *)ipcm);
      }
#line 2553
      return (-14);
    } else {

    }
  } else {

  }
  {
#line 2555
  kfree((void const   *)ipcm);
  }
#line 2556
  return (res);
  case_1074022432: /* CIL Label */ 
  {
#line 2558
  tmp___17 = capable(21);
  }
#line 2558
  if (tmp___17) {
#line 2558
    tmp___18 = 0;
  } else {
#line 2558
    tmp___18 = 1;
  }
#line 2558
  if (tmp___18) {
#line 2559
    return (-1);
  } else {

  }
  {
#line 2560
  might_fault();
  }
  {
#line 2560
  if (4UL == 1UL) {
#line 2560
    goto case_1___0;
  } else {

  }
#line 2560
  if (4UL == 2UL) {
#line 2560
    goto case_2___0;
  } else {

  }
#line 2560
  if (4UL == 4UL) {
#line 2560
    goto case_4___0;
  } else {

  }
#line 2560
  if (4UL == 8UL) {
#line 2560
    goto case_8___0;
  } else {

  }
#line 2560
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 2560
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)argp));
#line 2560
  goto ldv_31205;
  case_2___0: /* CIL Label */ 
#line 2560
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)argp));
#line 2560
  goto ldv_31205;
  case_4___0: /* CIL Label */ 
#line 2560
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)argp));
#line 2560
  goto ldv_31205;
  case_8___0: /* CIL Label */ 
#line 2560
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)argp));
#line 2560
  goto ldv_31205;
  switch_default___0: /* CIL Label */ 
#line 2560
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)argp));
#line 2560
  goto ldv_31205;
  switch_break___1: /* CIL Label */ ;
  }
  ldv_31205: 
#line 2560
  addr = (unsigned int )__val_gu;
#line 2560
  if (__ret_gu != 0) {
#line 2561
    return (-14);
  } else {

  }
  {
#line 2562
  mutex_lock_nested(& emu->fx8010.lock, 0U);
#line 2563
  res = snd_emu10k1_fx8010_tram_setup(emu, addr);
#line 2564
  mutex_unlock(& emu->fx8010.lock);
  }
#line 2565
  return (res);
  case_18560: /* CIL Label */ 
  {
#line 2567
  tmp___19 = capable(21);
  }
#line 2567
  if (tmp___19) {
#line 2567
    tmp___20 = 0;
  } else {
#line 2567
    tmp___20 = 1;
  }
#line 2567
  if (tmp___20) {
#line 2568
    return (-1);
  } else {

  }
#line 2569
  if (emu->audigy != 0U) {
    {
#line 2570
    tmp___21 = emu->fx8010.dbg | 131072U;
#line 2570
    emu->fx8010.dbg = tmp___21;
#line 2570
    snd_emu10k1_ptr_write(emu, 83U, 0U, tmp___21);
    }
  } else {
    {
#line 2572
    tmp___22 = emu->fx8010.dbg | 32768U;
#line 2572
    emu->fx8010.dbg = tmp___22;
#line 2572
    snd_emu10k1_ptr_write(emu, 82U, 0U, tmp___22);
    }
  }
#line 2573
  return (0);
  case_18561: /* CIL Label */ 
  {
#line 2575
  tmp___23 = capable(21);
  }
#line 2575
  if (tmp___23) {
#line 2575
    tmp___24 = 0;
  } else {
#line 2575
    tmp___24 = 1;
  }
#line 2575
  if (tmp___24) {
#line 2576
    return (-1);
  } else {

  }
#line 2577
  if (emu->audigy != 0U) {
    {
#line 2578
    tmp___25 = 0U;
#line 2578
    emu->fx8010.dbg = tmp___25;
#line 2578
    snd_emu10k1_ptr_write(emu, 83U, 0U, tmp___25);
    }
  } else {
    {
#line 2580
    tmp___26 = 0U;
#line 2580
    emu->fx8010.dbg = tmp___26;
#line 2580
    snd_emu10k1_ptr_write(emu, 82U, 0U, tmp___26);
    }
  }
#line 2581
  return (0);
  case_18562: /* CIL Label */ 
  {
#line 2583
  tmp___27 = capable(21);
  }
#line 2583
  if (tmp___27) {
#line 2583
    tmp___28 = 0;
  } else {
#line 2583
    tmp___28 = 1;
  }
#line 2583
  if (tmp___28) {
#line 2584
    return (-1);
  } else {

  }
#line 2585
  if (emu->audigy != 0U) {
    {
#line 2586
    snd_emu10k1_ptr_write(emu, 83U, 0U, emu->fx8010.dbg | 1073741824U);
    }
  } else {
    {
#line 2588
    snd_emu10k1_ptr_write(emu, 82U, 0U, emu->fx8010.dbg | 2147483648U);
    }
  }
  {
#line 2589
  __const_udelay(42950UL);
  }
#line 2590
  if (emu->audigy != 0U) {
    {
#line 2591
    snd_emu10k1_ptr_write(emu, 83U, 0U, emu->fx8010.dbg);
    }
  } else {
    {
#line 2593
    snd_emu10k1_ptr_write(emu, 82U, 0U, emu->fx8010.dbg);
    }
  }
#line 2594
  return (0);
  case_1074022531: /* CIL Label */ 
  {
#line 2596
  tmp___29 = capable(21);
  }
#line 2596
  if (tmp___29) {
#line 2596
    tmp___30 = 0;
  } else {
#line 2596
    tmp___30 = 1;
  }
#line 2596
  if (tmp___30) {
#line 2597
    return (-1);
  } else {

  }
  {
#line 2598
  might_fault();
  }
  {
#line 2598
  if (4UL == 1UL) {
#line 2598
    goto case_1___1;
  } else {

  }
#line 2598
  if (4UL == 2UL) {
#line 2598
    goto case_2___1;
  } else {

  }
#line 2598
  if (4UL == 4UL) {
#line 2598
    goto case_4___1;
  } else {

  }
#line 2598
  if (4UL == 8UL) {
#line 2598
    goto case_8___1;
  } else {

  }
#line 2598
  goto switch_default___1;
  case_1___1: /* CIL Label */ 
#line 2598
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" ((unsigned int *)argp));
#line 2598
  goto ldv_31218;
  case_2___1: /* CIL Label */ 
#line 2598
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" ((unsigned int *)argp));
#line 2598
  goto ldv_31218;
  case_4___1: /* CIL Label */ 
#line 2598
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" ((unsigned int *)argp));
#line 2598
  goto ldv_31218;
  case_8___1: /* CIL Label */ 
#line 2598
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" ((unsigned int *)argp));
#line 2598
  goto ldv_31218;
  switch_default___1: /* CIL Label */ 
#line 2598
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" ((unsigned int *)argp));
#line 2598
  goto ldv_31218;
  switch_break___2: /* CIL Label */ ;
  }
  ldv_31218: 
#line 2598
  addr = (unsigned int )__val_gu___0;
#line 2598
  if (__ret_gu___0 != 0) {
#line 2599
    return (-14);
  } else {

  }
#line 2600
  if (addr > 511U) {
#line 2601
    return (-22);
  } else {

  }
#line 2602
  if (emu->audigy != 0U) {
    {
#line 2603
    tmp___31 = (emu->fx8010.dbg | addr) | 131072U;
#line 2603
    emu->fx8010.dbg = tmp___31;
#line 2603
    snd_emu10k1_ptr_write(emu, 83U, 0U, tmp___31);
    }
  } else {
    {
#line 2605
    tmp___32 = (emu->fx8010.dbg | addr) | 32768U;
#line 2605
    emu->fx8010.dbg = tmp___32;
#line 2605
    snd_emu10k1_ptr_write(emu, 82U, 0U, tmp___32);
    }
  }
  {
#line 2606
  __const_udelay(42950UL);
  }
#line 2607
  if (emu->audigy != 0U) {
    {
#line 2608
    tmp___33 = (emu->fx8010.dbg | addr) | 132095U;
#line 2608
    emu->fx8010.dbg = tmp___33;
#line 2608
    snd_emu10k1_ptr_write(emu, 83U, 0U, tmp___33);
    }
  } else {
    {
#line 2610
    tmp___34 = (emu->fx8010.dbg | addr) | 49152U;
#line 2610
    emu->fx8010.dbg = tmp___34;
#line 2610
    snd_emu10k1_ptr_write(emu, 82U, 0U, tmp___34);
    }
  }
#line 2611
  return (0);
  case_2147764356: /* CIL Label */ ;
#line 2613
  if (emu->audigy != 0U) {
    {
#line 2614
    addr = snd_emu10k1_ptr_read(emu, 83U, 0U);
    }
  } else {
    {
#line 2616
    addr = snd_emu10k1_ptr_read(emu, 82U, 0U);
    }
  }
  {
#line 2617
  might_fault();
#line 2617
  __pu_val___0 = addr;
  }
  {
#line 2617
  if (4UL == 1UL) {
#line 2617
    goto case_1___2;
  } else {

  }
#line 2617
  if (4UL == 2UL) {
#line 2617
    goto case_2___2;
  } else {

  }
#line 2617
  if (4UL == 4UL) {
#line 2617
    goto case_4___2;
  } else {

  }
#line 2617
  if (4UL == 8UL) {
#line 2617
    goto case_8___2;
  } else {

  }
#line 2617
  goto switch_default___2;
  case_1___2: /* CIL Label */ 
#line 2617
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((unsigned int *)argp): "ebx");
#line 2617
  goto ldv_31228;
  case_2___2: /* CIL Label */ 
#line 2617
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((unsigned int *)argp): "ebx");
#line 2617
  goto ldv_31228;
  case_4___2: /* CIL Label */ 
#line 2617
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((unsigned int *)argp): "ebx");
#line 2617
  goto ldv_31228;
  case_8___2: /* CIL Label */ 
#line 2617
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((unsigned int *)argp): "ebx");
#line 2617
  goto ldv_31228;
  switch_default___2: /* CIL Label */ 
#line 2617
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((unsigned int *)argp): "ebx");
#line 2617
  goto ldv_31228;
  switch_break___3: /* CIL Label */ ;
  }
  ldv_31228: ;
#line 2617
  if (__ret_pu___0 != 0) {
#line 2618
    return (-14);
  } else {

  }
#line 2619
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 2621
  return (-25);
}
}
#line 2624 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
static int snd_emu10k1_fx8010_release(struct snd_hwdep *hw , struct file *file ) 
{ 


  {
#line 2626
  return (0);
}
}
#line 2629 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
int snd_emu10k1_fx8010_new(struct snd_emu10k1 *emu , int device , struct snd_hwdep **rhwdep ) 
{ 
  struct snd_hwdep *hw ;
  int err ;

  {
#line 2634
  if ((unsigned long )rhwdep != (unsigned long )((struct snd_hwdep **)0)) {
#line 2635
    *rhwdep = (struct snd_hwdep *)0;
  } else {

  }
  {
#line 2636
  err = snd_hwdep_new(emu->card, (char *)"FX8010", device, & hw);
  }
#line 2636
  if (err < 0) {
#line 2637
    return (err);
  } else {

  }
  {
#line 2638
  strcpy((char *)(& hw->name), "EMU10K1 (FX8010)");
#line 2639
  hw->iface = 4;
#line 2640
  hw->ops.open = & snd_emu10k1_fx8010_open;
#line 2641
  hw->ops.ioctl = & snd_emu10k1_fx8010_ioctl;
#line 2642
  hw->ops.release = & snd_emu10k1_fx8010_release;
#line 2643
  hw->private_data = (void *)emu;
  }
#line 2644
  if ((unsigned long )rhwdep != (unsigned long )((struct snd_hwdep **)0)) {
#line 2645
    *rhwdep = hw;
  } else {

  }
#line 2646
  return (0);
}
}
#line 2650 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
int snd_emu10k1_efx_alloc_pm_buffer(struct snd_emu10k1 *emu ) 
{ 
  int len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 2654
  len = emu->audigy != 0U ? 512 : 256;
#line 2655
  tmp = kmalloc((size_t )(len * 4), 208U);
#line 2655
  emu->saved_gpr = (unsigned int *)tmp;
  }
#line 2656
  if ((unsigned long )emu->saved_gpr == (unsigned long )((unsigned int *)0U)) {
#line 2657
    return (-12);
  } else {

  }
  {
#line 2658
  len = emu->audigy != 0U ? 256 : 160;
#line 2659
  tmp___0 = kmalloc((size_t )(len * 4), 208U);
#line 2659
  emu->tram_val_saved = (unsigned int *)tmp___0;
#line 2660
  tmp___1 = kmalloc((size_t )(len * 4), 208U);
#line 2660
  emu->tram_addr_saved = (unsigned int *)tmp___1;
  }
#line 2661
  if ((unsigned long )emu->tram_val_saved == (unsigned long )((unsigned int *)0U) || (unsigned long )emu->tram_addr_saved == (unsigned long )((unsigned int *)0U)) {
#line 2662
    return (-12);
  } else {

  }
  {
#line 2663
  len = emu->audigy != 0U ? 2048 : 1024;
#line 2664
  tmp___2 = vmalloc((unsigned long )(len * 4));
#line 2664
  emu->saved_icode = (unsigned int *)tmp___2;
  }
#line 2665
  if ((unsigned long )emu->saved_icode == (unsigned long )((unsigned int *)0U)) {
#line 2666
    return (-12);
  } else {

  }
#line 2667
  return (0);
}
}
#line 2670 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
void snd_emu10k1_efx_free_pm_buffer(struct snd_emu10k1 *emu ) 
{ 


  {
  {
#line 2672
  kfree((void const   *)emu->saved_gpr);
#line 2673
  kfree((void const   *)emu->tram_val_saved);
#line 2674
  kfree((void const   *)emu->tram_addr_saved);
#line 2675
  vfree((void const   *)emu->saved_icode);
  }
#line 2676
  return;
}
}
#line 2681 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
void snd_emu10k1_efx_suspend(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  int len ;
  unsigned int tmp ;

  {
#line 2685
  len = emu->audigy != 0U ? 512 : 256;
#line 2686
  i = 0;
#line 2686
  goto ldv_31258;
  ldv_31257: 
  {
#line 2687
  *(emu->saved_gpr + (unsigned long )i) = snd_emu10k1_ptr_read(emu, (unsigned int )(emu->gpr_base + i),
                                                               0U);
#line 2686
  i = i + 1;
  }
  ldv_31258: ;
#line 2686
  if (i < len) {
#line 2688
    goto ldv_31257;
  } else {

  }
#line 2689
  len = emu->audigy != 0U ? 256 : 160;
#line 2690
  i = 0;
#line 2690
  goto ldv_31261;
  ldv_31260: 
  {
#line 2691
  *(emu->tram_val_saved + (unsigned long )i) = snd_emu10k1_ptr_read(emu, (unsigned int )(i + 512),
                                                                    0U);
#line 2692
  *(emu->tram_addr_saved + (unsigned long )i) = snd_emu10k1_ptr_read(emu, (unsigned int )(i + 768),
                                                                     0U);
  }
#line 2693
  if (emu->audigy != 0U) {
    {
#line 2694
    *(emu->tram_addr_saved + (unsigned long )i) = *(emu->tram_addr_saved + (unsigned long )i) >> 12;
#line 2695
    tmp = snd_emu10k1_ptr_read(emu, (unsigned int )(i + 256), 0U);
#line 2695
    *(emu->tram_addr_saved + (unsigned long )i) = *(emu->tram_addr_saved + (unsigned long )i) | (tmp << 20);
    }
  } else {

  }
#line 2690
  i = i + 1;
  ldv_31261: ;
#line 2690
  if (i < len) {
#line 2692
    goto ldv_31260;
  } else {

  }
#line 2700
  len = emu->audigy != 0U ? 2048 : 1024;
#line 2701
  i = 0;
#line 2701
  goto ldv_31264;
  ldv_31263: 
  {
#line 2702
  *(emu->saved_icode + (unsigned long )i) = snd_emu10k1_efx_read(emu, (unsigned int )i);
#line 2701
  i = i + 1;
  }
  ldv_31264: ;
#line 2701
  if (i < len) {
#line 2703
    goto ldv_31263;
  } else {

  }

#line 2708
  return;
}
}
#line 2705 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/emufx.c"
void snd_emu10k1_efx_resume(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  int len ;
  unsigned int size ;
  unsigned int size_reg ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 2710
  if (emu->fx8010.etram_pages.bytes != 0UL) {
#line 2711
    size_reg = 0U;
#line 2712
    size = (unsigned int )(emu->fx8010.etram_pages.bytes / 2UL);
#line 2713
    size = (size - 1U) >> 13;
#line 2714
    goto ldv_31274;
    ldv_31273: 
#line 2715
    size = size >> 1;
#line 2716
    size_reg = size_reg + 1U;
    ldv_31274: ;
#line 2714
    if (size != 0U) {
#line 2716
      goto ldv_31273;
    } else {

    }
    {
#line 2718
    tmp = inl((int )((unsigned int )emu->port + 20U));
#line 2718
    outl(tmp | 4U, (int )((unsigned int )emu->port + 20U));
#line 2719
    snd_emu10k1_ptr_write(emu, 65U, 0U, (unsigned int )emu->fx8010.etram_pages.addr);
#line 2720
    snd_emu10k1_ptr_write(emu, 68U, 0U, size_reg);
#line 2721
    tmp___0 = inl((int )((unsigned int )emu->port + 20U));
#line 2721
    outl(tmp___0 & 4294967291U, (int )((unsigned int )emu->port + 20U));
    }
  } else {

  }
#line 2724
  if (emu->audigy != 0U) {
    {
#line 2725
    snd_emu10k1_ptr_write(emu, 83U, 0U, emu->fx8010.dbg | 131072U);
    }
  } else {
    {
#line 2727
    snd_emu10k1_ptr_write(emu, 82U, 0U, emu->fx8010.dbg | 32768U);
    }
  }
#line 2729
  len = emu->audigy != 0U ? 512 : 256;
#line 2730
  i = 0;
#line 2730
  goto ldv_31277;
  ldv_31276: 
  {
#line 2731
  snd_emu10k1_ptr_write(emu, (unsigned int )(emu->gpr_base + i), 0U, *(emu->saved_gpr + (unsigned long )i));
#line 2730
  i = i + 1;
  }
  ldv_31277: ;
#line 2730
  if (i < len) {
#line 2732
    goto ldv_31276;
  } else {

  }
#line 2733
  len = emu->audigy != 0U ? 256 : 160;
#line 2734
  i = 0;
#line 2734
  goto ldv_31280;
  ldv_31279: 
  {
#line 2735
  snd_emu10k1_ptr_write(emu, (unsigned int )(i + 512), 0U, *(emu->tram_val_saved + (unsigned long )i));
  }
#line 2737
  if (emu->audigy == 0U) {
    {
#line 2738
    snd_emu10k1_ptr_write(emu, (unsigned int )(i + 768), 0U, *(emu->tram_addr_saved + (unsigned long )i));
    }
  } else {
    {
#line 2741
    snd_emu10k1_ptr_write(emu, (unsigned int )(i + 768), 0U, *(emu->tram_addr_saved + (unsigned long )i) << 12);
#line 2743
    snd_emu10k1_ptr_write(emu, (unsigned int )(i + 768), 0U, *(emu->tram_addr_saved + (unsigned long )i) >> 20);
    }
  }
#line 2734
  i = i + 1;
  ldv_31280: ;
#line 2734
  if (i < len) {
#line 2736
    goto ldv_31279;
  } else {

  }
#line 2748
  len = emu->audigy != 0U ? 2048 : 1024;
#line 2749
  i = 0;
#line 2749
  goto ldv_31283;
  ldv_31282: 
  {
#line 2750
  snd_emu10k1_efx_write(emu, (unsigned int )i, *(emu->saved_icode + (unsigned long )i));
#line 2749
  i = i + 1;
  }
  ldv_31283: ;
#line 2749
  if (i < len) {
#line 2751
    goto ldv_31282;
  } else {

  }

#line 2753
  if (emu->audigy != 0U) {
    {
#line 2754
    snd_emu10k1_ptr_write(emu, 83U, 0U, emu->fx8010.dbg);
    }
  } else {
    {
#line 2756
    snd_emu10k1_ptr_write(emu, 82U, 0U, emu->fx8010.dbg);
    }
  }
#line 2757
  return;
}
}
#line 215 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 218
  tmp = ldv_ptr_err(ptr);
  }
#line 218
  return (tmp);
}
}
#line 222 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
__inline static long IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 225
  tmp = ldv_is_err(ptr);
  }
#line 225
  return (tmp);
}
}
#line 298 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 301
  tmp = ldv_kcalloc(n, size, flags);
  }
#line 301
  return (tmp);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
static void ldv___ldv_spin_lock_33___7(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
static void ldv___ldv_spin_lock_35___4(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 515 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
static void ldv___ldv_spin_lock_37___3(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 518
  ldv_spin_lock_irq_lock_of_snd_emu10k1_fx8010();
#line 520
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 521
  return;
}
}
#line 524 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
__inline static void ldv_spin_unlock_irqrestore_38___3(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 527
  ldv_spin_unlock_irq_lock_of_snd_emu10k1_fx8010();
#line 529
  spin_unlock_irqrestore(lock, flags);
  }
#line 530
  return;
}
}
#line 533 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
static void ldv___ldv_spin_lock_39___3(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 536
  ldv_spin_lock_irq_lock_of_snd_emu10k1_fx8010();
#line 538
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 539
  return;
}
}
#line 587 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
__inline static void ldv_spin_lock_irq_45___0(spinlock_t *lock ) 
{ 


  {
  {
#line 590
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 592
  spin_lock_irq(lock);
  }
#line 593
  return;
}
}
#line 596 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_emufx.c.aux"
__inline static void ldv_spin_unlock_irq_46___0(spinlock_t *lock ) 
{ 


  {
  {
#line 599
  ldv_spin_unlock_emu_lock_of_snd_emu10k1();
#line 601
  spin_unlock_irq(lock);
  }
#line 602
  return;
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_timer.c.aux"
static void ldv___ldv_spin_lock_33___8(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___5(spinlock_t *ldv_func_arg1 ) ;
#line 390 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34___3(spinlock_t *lock , unsigned long flags ) ;
#line 127 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/timer.h"
extern int snd_timer_new(struct snd_card * , char * , struct snd_timer_id * , struct snd_timer ** ) ;
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/timer.c"
static int snd_emu10k1_timer_start(struct snd_timer *timer ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long flags ;
  unsigned int delay ;

  {
#line 38
  emu = (struct snd_emu10k1 *)timer->private_data;
#line 39
  delay = (unsigned int )timer->sticks - 1U;
#line 40
  if (delay <= 4U) {
#line 41
    delay = 5U;
  } else {

  }
  {
#line 42
  ldv___ldv_spin_lock_33___8(& emu->reg_lock);
#line 43
  snd_emu10k1_intr_enable(emu, 4U);
#line 44
  outw((int )((unsigned short )delay) & 1023, (int )((unsigned int )emu->port + 26U));
#line 45
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 46
  return (0);
}
}
#line 49 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/timer.c"
static int snd_emu10k1_timer_stop(struct snd_timer *timer ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned long flags ;

  {
  {
#line 54
  emu = (struct snd_emu10k1 *)timer->private_data;
#line 55
  ldv___ldv_spin_lock_35___5(& emu->reg_lock);
#line 56
  snd_emu10k1_intr_disable(emu, 4U);
#line 57
  ldv_spin_unlock_irqrestore_34___3(& emu->reg_lock, flags);
  }
#line 58
  return (0);
}
}
#line 61 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/timer.c"
static int snd_emu10k1_timer_precise_resolution(struct snd_timer *timer , unsigned long *num ,
                                                unsigned long *den ) 
{ 


  {
#line 64
  *num = 1UL;
#line 65
  *den = 48000UL;
#line 66
  return (0);
}
}
#line 69 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/timer.c"
static struct snd_timer_hardware snd_emu10k1_timer_hw  = 
#line 69
     {1U, 20833UL, 0UL, 0UL, 1024UL, 0, 0, 0, & snd_emu10k1_timer_start, & snd_emu10k1_timer_stop,
    0, & snd_emu10k1_timer_precise_resolution};
#line 78 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/timer.c"
int snd_emu10k1_timer(struct snd_emu10k1 *emu , int device ) 
{ 
  struct snd_timer *timer ;
  struct snd_timer_id tid ;
  int err ;

  {
  {
#line 80
  timer = (struct snd_timer *)0;
#line 84
  tid.dev_class = 2;
#line 85
  tid.dev_sclass = 0;
#line 86
  tid.card = (emu->card)->number;
#line 87
  tid.device = device;
#line 88
  tid.subdevice = 0;
#line 89
  err = snd_timer_new(emu->card, (char *)"EMU10K1", & tid, & timer);
  }
#line 89
  if (err >= 0) {
    {
#line 90
    strcpy((char *)(& timer->name), "EMU10K1 timer");
#line 91
    timer->private_data = (void *)emu;
#line 92
    timer->hw = snd_emu10k1_timer_hw;
    }
  } else {

  }
#line 94
  emu->timer = timer;
#line 95
  return (err);
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_timer.c.aux"
static void ldv___ldv_spin_lock_33___8(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_timer.c.aux"
static void ldv___ldv_spin_lock_35___5(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_reg_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_p16v.c.aux"
static void ldv___ldv_spin_lock_33___9(spinlock_t *ldv_func_arg1 ) ;
#line 29
static void ldv___ldv_spin_lock_35___6(spinlock_t *ldv_func_arg1 ) ;
#line 390 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 394
__inline static void ldv_spin_unlock_irqrestore_34___0(spinlock_t *lock , unsigned long flags ) ;
#line 349 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 722 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/include/sound/pcm.h"
__inline static void snd_pcm_trigger_done(struct snd_pcm_substream *substream , struct snd_pcm_substream *master ) 
{ 


  {
#line 725
  (substream->runtime)->trigger_master = master;
#line 726
  return;
}
}
#line 125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static struct snd_pcm_hardware snd_p16v_playback_hw  = 
#line 125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
     {4522243U, 1024ULL, 5312U, 44100U, 192000U, 8U, 8U, 523776UL, 64UL, 65472UL, 2U,
    8U, 0UL};
#line 146 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static struct snd_pcm_hardware snd_p16v_capture_hw  = 
#line 146
     {327939U, 1024ULL, 5312U, 44100U, 192000U, 2U, 2U, 65472UL, 64UL, 32704UL, 2U,
    2U, 0UL};
#line 166 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static void snd_p16v_pcm_free_substream(struct snd_pcm_runtime *runtime ) 
{ 
  struct snd_emu10k1_pcm *epcm ;

  {
#line 168
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 170
  if ((unsigned long )epcm != (unsigned long )((struct snd_emu10k1_pcm *)0)) {
    {
#line 172
    kfree((void const   *)epcm);
    }
  } else {

  }
#line 173
  return;
}
}
#line 177 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_open_playback_channel(struct snd_pcm_substream *substream ,
                                              int channel_id ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_voice *channel ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_pcm_runtime *runtime ;
  int err ;
  void *tmp ;

  {
  {
#line 179
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 180
  channel = (struct snd_emu10k1_voice *)(& emu->p16v_voices) + (unsigned long )channel_id;
#line 182
  runtime = substream->runtime;
#line 185
  tmp = kzalloc(224UL, 208U);
#line 185
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 188
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 189
    return (-12);
  } else {

  }
  {
#line 190
  epcm->emu = emu;
#line 191
  epcm->substream = substream;
#line 196
  runtime->private_data = (void *)epcm;
#line 197
  runtime->private_free = & snd_p16v_pcm_free_substream;
#line 199
  runtime->hw = snd_p16v_playback_hw;
#line 201
  channel->emu = emu;
#line 202
  channel->number = channel_id;
#line 204
  channel->use = 1U;
#line 213
  channel->epcm = epcm;
#line 214
  err = snd_pcm_hw_constraint_integer(runtime, 15);
  }
#line 214
  if (err < 0) {
#line 215
    return (err);
  } else {

  }
#line 217
  runtime->sync.id32[0] = (unsigned int )((substream->pcm)->card)->number;
#line 218
  runtime->sync.id32[1] = 80U;
#line 219
  runtime->sync.id32[2] = 16U;
#line 220
  runtime->sync.id32[3] = 86U;
#line 222
  return (0);
}
}
#line 225 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_open_capture_channel(struct snd_pcm_substream *substream ,
                                             int channel_id ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_emu10k1_voice *channel ;
  struct snd_emu10k1_pcm *epcm ;
  struct snd_pcm_runtime *runtime ;
  int err ;
  void *tmp ;

  {
  {
#line 227
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 228
  channel = & emu->p16v_capture_voice;
#line 230
  runtime = substream->runtime;
#line 233
  tmp = kzalloc(224UL, 208U);
#line 233
  epcm = (struct snd_emu10k1_pcm *)tmp;
  }
#line 236
  if ((unsigned long )epcm == (unsigned long )((struct snd_emu10k1_pcm *)0)) {
#line 237
    return (-12);
  } else {

  }
  {
#line 238
  epcm->emu = emu;
#line 239
  epcm->substream = substream;
#line 244
  runtime->private_data = (void *)epcm;
#line 245
  runtime->private_free = & snd_p16v_pcm_free_substream;
#line 247
  runtime->hw = snd_p16v_capture_hw;
#line 249
  channel->emu = emu;
#line 250
  channel->number = channel_id;
#line 252
  channel->use = 1U;
#line 261
  channel->epcm = epcm;
#line 262
  err = snd_pcm_hw_constraint_integer(runtime, 15);
  }
#line 262
  if (err < 0) {
#line 263
    return (err);
  } else {

  }
#line 265
  return (0);
}
}
#line 270 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_close_playback(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 272
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 275
  emu->p16v_voices[(substream->pcm)->device - emu->p16v_device_offset].use = 0U;
#line 277
  return (0);
}
}
#line 281 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_close_capture(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 283
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 286
  emu->p16v_capture_voice.use = 0U;
#line 288
  return (0);
}
}
#line 291 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_open_playback_front(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  {
#line 293
  tmp = snd_p16v_pcm_open_playback_channel(substream, 0);
  }
#line 293
  return (tmp);
}
}
#line 296 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_open_capture(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  {
#line 299
  tmp = snd_p16v_pcm_open_capture_channel(substream, 0);
  }
#line 299
  return (tmp);
}
}
#line 303 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_hw_params_playback(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  int result ;
  struct snd_interval  const  *tmp ;

  {
  {
#line 307
  tmp = hw_param_interval_c((struct snd_pcm_hw_params  const  *)hw_params, 18);
#line 307
  result = snd_pcm_lib_malloc_pages(substream, (size_t )tmp->min);
  }
#line 309
  return (result);
}
}
#line 313 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_hw_params_capture(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  int result ;
  struct snd_interval  const  *tmp ;

  {
  {
#line 317
  tmp = hw_param_interval_c((struct snd_pcm_hw_params  const  *)hw_params, 18);
#line 317
  result = snd_pcm_lib_malloc_pages(substream, (size_t )tmp->min);
  }
#line 319
  return (result);
}
}
#line 324 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_hw_free_playback(struct snd_pcm_substream *substream ) 
{ 
  int result ;

  {
  {
#line 327
  result = snd_pcm_lib_free_pages(substream);
  }
#line 328
  return (result);
}
}
#line 332 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_hw_free_capture(struct snd_pcm_substream *substream ) 
{ 
  int result ;

  {
  {
#line 335
  result = snd_pcm_lib_free_pages(substream);
  }
#line 336
  return (result);
}
}
#line 341 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_prepare_playback(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  int channel ;
  u32 *table_base ;
  u32 period_size_bytes ;
  ssize_t tmp ;
  int i ;
  u32 tmp___0 ;

  {
  {
#line 343
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 344
  runtime = substream->runtime;
#line 345
  channel = (substream->pcm)->device - emu->p16v_device_offset;
#line 346
  table_base = (u32 *)(emu->p16v_buffer.area + (unsigned long )(channel * 128));
#line 347
  tmp = frames_to_bytes(runtime, (snd_pcm_sframes_t )runtime->period_size);
#line 347
  period_size_bytes = (u32 )tmp;
#line 364
  tmp___0 = snd_emu10k1_ptr_read(emu, 118U, (unsigned int )channel);
  }
  {
#line 366
  if (runtime->rate == 44100U) {
#line 366
    goto case_44100;
  } else {

  }
#line 369
  if (runtime->rate == 96000U) {
#line 369
    goto case_96000;
  } else {

  }
#line 372
  if (runtime->rate == 192000U) {
#line 372
    goto case_192000;
  } else {

  }
#line 375
  if (runtime->rate == 48000U) {
#line 375
    goto case_48000;
  } else {

  }
#line 376
  goto switch_default;
  case_44100: /* CIL Label */ 
  {
#line 367
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, (tmp___0 & 4294909727U) | 32896U);
  }
#line 368
  goto ldv_30455;
  case_96000: /* CIL Label */ 
  {
#line 370
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, (tmp___0 & 4294909727U) | 16448U);
  }
#line 371
  goto ldv_30455;
  case_192000: /* CIL Label */ 
  {
#line 373
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, (tmp___0 & 4294909727U) | 8224U);
  }
#line 374
  goto ldv_30455;
  case_48000: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
  {
#line 377
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, tmp___0 & 4294909727U);
  }
#line 378
  goto ldv_30455;
  switch_break: /* CIL Label */ ;
  }
  ldv_30455: 
#line 381
  i = 0;
#line 381
  goto ldv_30461;
  ldv_30460: 
#line 382
  *(table_base + (unsigned long )(i * 2)) = (u32 )runtime->dma_addr + (u32 )i * period_size_bytes;
#line 383
  *(table_base + ((unsigned long )(i * 2) + 1UL)) = period_size_bytes << 16;
#line 381
  i = i + 1;
  ldv_30461: ;
#line 381
  if ((unsigned int )i < runtime->periods) {
#line 383
    goto ldv_30460;
  } else {

  }
  {
#line 386
  snd_emu10k1_ptr20_write(emu, 0U, (unsigned int )channel, (unsigned int )emu->p16v_buffer.addr + (unsigned int )(channel * 128));
#line 387
  snd_emu10k1_ptr20_write(emu, 1U, (unsigned int )channel, (runtime->periods - 1U) << 19);
#line 388
  snd_emu10k1_ptr20_write(emu, 2U, (unsigned int )channel, 0U);
#line 389
  snd_emu10k1_ptr20_write(emu, 4U, (unsigned int )channel, (unsigned int )runtime->dma_addr);
#line 391
  snd_emu10k1_ptr20_write(emu, 5U, (unsigned int )channel, 0U);
#line 392
  snd_emu10k1_ptr20_write(emu, 6U, (unsigned int )channel, 0U);
#line 393
  snd_emu10k1_ptr20_write(emu, 7U, (unsigned int )channel, 0U);
#line 394
  snd_emu10k1_ptr20_write(emu, 8U, (unsigned int )channel, 0U);
  }
#line 396
  return (0);
}
}
#line 400 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_prepare_capture(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  int channel ;
  u32 tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 402
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 403
  runtime = substream->runtime;
#line 404
  channel = (substream->pcm)->device - emu->p16v_device_offset;
#line 415
  tmp = snd_emu10k1_ptr_read(emu, 118U, (unsigned int )channel);
  }
  {
#line 417
  if (runtime->rate == 44100U) {
#line 417
    goto case_44100;
  } else {

  }
#line 420
  if (runtime->rate == 96000U) {
#line 420
    goto case_96000;
  } else {

  }
#line 423
  if (runtime->rate == 192000U) {
#line 423
    goto case_192000;
  } else {

  }
#line 426
  if (runtime->rate == 48000U) {
#line 426
    goto case_48000;
  } else {

  }
#line 427
  goto switch_default;
  case_44100: /* CIL Label */ 
  {
#line 418
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, (tmp & 4294963711U) | 2048U);
  }
#line 419
  goto ldv_30471;
  case_96000: /* CIL Label */ 
  {
#line 421
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, (tmp & 4294963711U) | 1024U);
  }
#line 422
  goto ldv_30471;
  case_192000: /* CIL Label */ 
  {
#line 424
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, (tmp & 4294963711U) | 512U);
  }
#line 425
  goto ldv_30471;
  case_48000: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
  {
#line 428
  snd_emu10k1_ptr_write(emu, 118U, (unsigned int )channel, tmp & 4294963711U);
  }
#line 429
  goto ldv_30471;
  switch_break: /* CIL Label */ ;
  }
  ldv_30471: 
  {
#line 432
  snd_emu10k1_ptr20_write(emu, 19U, (unsigned int )channel, 0U);
#line 433
  snd_emu10k1_ptr20_write(emu, 16U, (unsigned int )channel, (unsigned int )runtime->dma_addr);
#line 434
  tmp___0 = frames_to_bytes(runtime, (snd_pcm_sframes_t )runtime->buffer_size);
#line 434
  snd_emu10k1_ptr20_write(emu, 17U, (unsigned int )channel, (unsigned int )tmp___0 << 16U);
#line 435
  snd_emu10k1_ptr20_write(emu, 18U, (unsigned int )channel, 0U);
  }
#line 439
  return (0);
}
}
#line 442 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static void snd_p16v_intr_enable(struct snd_emu10k1 *emu , unsigned int intrenb ) 
{ 
  unsigned long flags ;
  unsigned int enable___0 ;
  unsigned int tmp ;

  {
  {
#line 447
  ldv___ldv_spin_lock_33___9(& emu->emu_lock);
#line 448
  tmp = inl((int )((unsigned int )emu->port + 44U));
#line 448
  enable___0 = tmp | intrenb;
#line 449
  outl(enable___0, (int )((unsigned int )emu->port + 44U));
#line 450
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 451
  return;
}
}
#line 453 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static void snd_p16v_intr_disable(struct snd_emu10k1 *emu , unsigned int intrenb ) 
{ 
  unsigned long flags ;
  unsigned int disable ;
  unsigned int tmp ;

  {
  {
#line 458
  ldv___ldv_spin_lock_35___6(& emu->emu_lock);
#line 459
  tmp = inl((int )((unsigned int )emu->port + 44U));
#line 459
  disable = tmp & ~ intrenb;
#line 460
  outl(disable, (int )((unsigned int )emu->port + 44U));
#line 461
  ldv_spin_unlock_irqrestore_34___0(& emu->emu_lock, flags);
  }
#line 462
  return;
}
}
#line 465 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_trigger_playback(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int channel ;
  int result ;
  struct snd_pcm_substream *s ;
  u32 basic ;
  u32 inte ;
  int running ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 468
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 472
  result = 0;
#line 474
  basic = 0U;
#line 475
  inte = 0U;
#line 476
  running = 0;
  {
#line 479
  if (cmd == 1) {
#line 479
    goto case_1;
  } else {

  }
#line 482
  if (cmd == 0) {
#line 482
    goto case_0;
  } else {

  }
#line 483
  goto switch_default;
  case_1: /* CIL Label */ 
#line 480
  running = 1;
#line 481
  goto ldv_30502;
  case_0: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
#line 484
  running = 0;
#line 485
  goto ldv_30502;
  switch_break: /* CIL Label */ ;
  }
  ldv_30502: 
#line 487
  __mptr = (struct list_head  const  *)(substream->group)->substreams.next;
#line 487
  s = (struct snd_pcm_substream *)((char *)__mptr + 0xffffffffffffff20UL);
#line 487
  goto ldv_30511;
  ldv_30510: ;
#line 488
  if ((unsigned long )s->private_data != (unsigned long )((void *)emu) || s->stream != 0) {
#line 490
    goto ldv_30509;
  } else {

  }
  {
#line 491
  runtime = s->runtime;
#line 492
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 493
  channel = (substream->pcm)->device - emu->p16v_device_offset;
#line 495
  epcm->running = (unsigned short )running;
#line 496
  basic = basic | (u32 )(1 << channel);
#line 497
  inte = inte | (u32 )(4096 << channel);
#line 498
  snd_pcm_trigger_done(s, substream);
  }
  ldv_30509: 
#line 487
  __mptr___0 = (struct list_head  const  *)s->link_list.next;
#line 487
  s = (struct snd_pcm_substream *)((char *)__mptr___0 + 0xffffffffffffff20UL);
  ldv_30511: ;
#line 487
  if ((unsigned long )(& s->link_list) != (unsigned long )(& (substream->group)->substreams)) {
#line 489
    goto ldv_30510;
  } else {

  }

  {
#line 503
  if (cmd == 1) {
#line 503
    goto case_1___0;
  } else {

  }
#line 507
  if (cmd == 0) {
#line 507
    goto case_0___0;
  } else {

  }
#line 511
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 504
  snd_p16v_intr_enable(emu, inte);
#line 505
  tmp = snd_emu10k1_ptr20_read(emu, 64U, 0U);
#line 505
  snd_emu10k1_ptr20_write(emu, 64U, 0U, tmp | basic);
  }
#line 506
  goto ldv_30514;
  case_0___0: /* CIL Label */ 
  {
#line 508
  tmp___0 = snd_emu10k1_ptr20_read(emu, 64U, 0U);
#line 508
  snd_emu10k1_ptr20_write(emu, 64U, 0U, tmp___0 & ~ basic);
#line 509
  snd_p16v_intr_disable(emu, inte);
  }
#line 510
  goto ldv_30514;
  switch_default___0: /* CIL Label */ 
#line 512
  result = -22;
#line 513
  goto ldv_30514;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_30514: ;
#line 515
  return (result);
}
}
#line 519 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_pcm_trigger_capture(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  int channel ;
  int result ;
  u32 inte ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 522
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 523
  runtime = substream->runtime;
#line 524
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 525
  channel = 0;
#line 526
  result = 0;
#line 527
  inte = 1114112U;
  {
#line 530
  if (cmd == 1) {
#line 530
    goto case_1;
  } else {

  }
#line 535
  if (cmd == 0) {
#line 535
    goto case_0;
  } else {

  }
#line 541
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 531
  snd_p16v_intr_enable(emu, inte);
#line 532
  tmp = snd_emu10k1_ptr20_read(emu, 64U, 0U);
#line 532
  snd_emu10k1_ptr20_write(emu, 64U, 0U, tmp | (unsigned int )(256 << channel));
#line 533
  epcm->running = 1U;
  }
#line 534
  goto ldv_30528;
  case_0: /* CIL Label */ 
  {
#line 536
  tmp___0 = snd_emu10k1_ptr20_read(emu, 64U, 0U);
#line 536
  snd_emu10k1_ptr20_write(emu, 64U, 0U, tmp___0 & (unsigned int )(~ (256 << channel)));
#line 537
  snd_p16v_intr_disable(emu, inte);
#line 539
  epcm->running = 0U;
  }
#line 540
  goto ldv_30528;
  switch_default: /* CIL Label */ 
#line 542
  result = -22;
#line 543
  goto ldv_30528;
  switch_break: /* CIL Label */ ;
  }
  ldv_30528: ;
#line 545
  return (result);
}
}
#line 550 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static snd_pcm_uframes_t snd_p16v_pcm_pointer_playback(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  snd_pcm_uframes_t ptr ;
  snd_pcm_uframes_t ptr1 ;
  snd_pcm_uframes_t ptr2 ;
  snd_pcm_uframes_t ptr3 ;
  snd_pcm_uframes_t ptr4 ;
  int channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  snd_pcm_sframes_t tmp___3 ;

  {
#line 552
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 553
  runtime = substream->runtime;
#line 554
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 555
  ptr4 = 0UL;
#line 556
  channel = (substream->pcm)->device - emu->p16v_device_offset;
#line 557
  if ((unsigned int )epcm->running == 0U) {
#line 558
    return (0UL);
  } else {

  }
  {
#line 560
  tmp = snd_emu10k1_ptr20_read(emu, 2U, (unsigned int )channel);
#line 560
  ptr3 = (snd_pcm_uframes_t )tmp;
#line 561
  tmp___0 = snd_emu10k1_ptr20_read(emu, 6U, (unsigned int )channel);
#line 561
  ptr1 = (snd_pcm_uframes_t )tmp___0;
#line 562
  tmp___1 = snd_emu10k1_ptr20_read(emu, 2U, (unsigned int )channel);
#line 562
  ptr4 = (snd_pcm_uframes_t )tmp___1;
  }
#line 563
  if (ptr3 != ptr4) {
    {
#line 563
    tmp___2 = snd_emu10k1_ptr20_read(emu, 6U, (unsigned int )channel);
#line 563
    ptr1 = (snd_pcm_uframes_t )tmp___2;
    }
  } else {

  }
  {
#line 564
  tmp___3 = bytes_to_frames(runtime, (ssize_t )ptr1);
#line 564
  ptr2 = (snd_pcm_uframes_t )tmp___3;
#line 565
  ptr2 = ptr2 + (ptr4 >> 3) * runtime->period_size;
#line 566
  ptr = ptr2;
  }
#line 567
  if (ptr >= runtime->buffer_size) {
#line 568
    ptr = ptr - runtime->buffer_size;
  } else {

  }
#line 570
  return (ptr);
}
}
#line 575 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static snd_pcm_uframes_t snd_p16v_pcm_pointer_capture(struct snd_pcm_substream *substream ) 
{ 
  struct snd_emu10k1 *emu ;
  struct snd_pcm_runtime *runtime ;
  struct snd_emu10k1_pcm *epcm ;
  snd_pcm_uframes_t ptr ;
  snd_pcm_uframes_t ptr1 ;
  snd_pcm_uframes_t ptr2 ;
  int channel ;
  unsigned int tmp ;
  snd_pcm_sframes_t tmp___0 ;

  {
#line 577
  emu = (struct snd_emu10k1 *)substream->private_data;
#line 578
  runtime = substream->runtime;
#line 579
  epcm = (struct snd_emu10k1_pcm *)runtime->private_data;
#line 580
  ptr2 = 0UL;
#line 581
  channel = 0;
#line 583
  if ((unsigned int )epcm->running == 0U) {
#line 584
    return (0UL);
  } else {

  }
  {
#line 586
  tmp = snd_emu10k1_ptr20_read(emu, 18U, (unsigned int )channel);
#line 586
  ptr1 = (snd_pcm_uframes_t )tmp;
#line 587
  tmp___0 = bytes_to_frames(runtime, (ssize_t )ptr1);
#line 587
  ptr2 = (snd_pcm_uframes_t )tmp___0;
#line 588
  ptr = ptr2;
  }
#line 589
  if (ptr >= runtime->buffer_size) {
    {
#line 590
    ptr = ptr - runtime->buffer_size;
#line 591
    printk("<4>buffer capture limited!\n");
    }
  } else {

  }
#line 600
  return (ptr);
}
}
#line 604 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static struct snd_pcm_ops snd_p16v_playback_front_ops  = 
#line 604
     {& snd_p16v_pcm_open_playback_front, & snd_p16v_pcm_close_playback, & snd_pcm_lib_ioctl,
    & snd_p16v_pcm_hw_params_playback, & snd_p16v_pcm_hw_free_playback, & snd_p16v_pcm_prepare_playback,
    & snd_p16v_pcm_trigger_playback, & snd_p16v_pcm_pointer_playback, 0, 0, 0, 0,
    0};
#line 615 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static struct snd_pcm_ops snd_p16v_capture_ops  = 
#line 615
     {& snd_p16v_pcm_open_capture, & snd_p16v_pcm_close_capture, & snd_pcm_lib_ioctl,
    & snd_p16v_pcm_hw_params_capture, & snd_p16v_pcm_hw_free_capture, & snd_p16v_pcm_prepare_capture,
    & snd_p16v_pcm_trigger_capture, & snd_p16v_pcm_pointer_capture, 0, 0, 0, 0, 0};
#line 627 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
int snd_p16v_free(struct snd_emu10k1 *chip ) 
{ 


  {
#line 630
  if ((unsigned long )chip->p16v_buffer.area != (unsigned long )((unsigned char *)0U)) {
    {
#line 631
    snd_dma_free_pages(& chip->p16v_buffer);
    }
  } else {

  }
#line 637
  return (0);
}
}
#line 640 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
int snd_p16v_pcm(struct snd_emu10k1 *emu , int device , struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  struct snd_pcm_substream *substream ;
  int err ;
  int capture ;

  {
#line 645
  capture = 1;
#line 648
  emu->p16v_device_offset = device;
#line 649
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 650
    *rpcm = (struct snd_pcm *)0;
  } else {

  }
  {
#line 652
  err = snd_pcm_new(emu->card, "p16v", device, 1, capture, & pcm);
  }
#line 652
  if (err < 0) {
#line 653
    return (err);
  } else {

  }
  {
#line 655
  pcm->private_data = (void *)emu;
#line 658
  snd_pcm_set_ops(pcm, 0, & snd_p16v_playback_front_ops);
#line 659
  snd_pcm_set_ops(pcm, 1, & snd_p16v_capture_ops);
#line 661
  pcm->info_flags = 0U;
#line 662
  pcm->dev_subclass = 0U;
#line 663
  strcpy((char *)(& pcm->name), "p16v");
#line 664
  emu->pcm_p16v = pcm;
#line 666
  substream = pcm->streams[0].substream;
  }
#line 666
  goto ldv_30568;
  ldv_30567: 
  {
#line 669
  err = snd_pcm_lib_preallocate_pages(substream, 2, & (emu->pci)->dev, 523776UL, 523776UL);
  }
#line 669
  if (err < 0) {
#line 673
    return (err);
  } else {

  }
#line 668
  substream = substream->next;
  ldv_30568: ;
#line 666
  if ((unsigned long )substream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 669
    goto ldv_30567;
  } else {

  }
#line 680
  substream = pcm->streams[1].substream;
#line 680
  goto ldv_30571;
  ldv_30570: 
  {
#line 683
  err = snd_pcm_lib_preallocate_pages(substream, 2, & (emu->pci)->dev, 65472UL, 65472UL);
  }
#line 683
  if (err < 0) {
#line 687
    return (err);
  } else {

  }
#line 682
  substream = substream->next;
  ldv_30571: ;
#line 680
  if ((unsigned long )substream != (unsigned long )((struct snd_pcm_substream *)0)) {
#line 683
    goto ldv_30570;
  } else {

  }

#line 694
  if ((unsigned long )rpcm != (unsigned long )((struct snd_pcm **)0)) {
#line 695
    *rpcm = pcm;
  } else {

  }
#line 697
  return (0);
}
}
#line 700 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_volume_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
#line 703
  uinfo->type = 2;
#line 704
  uinfo->count = 2U;
#line 705
  uinfo->value.integer.min = 0L;
#line 706
  uinfo->value.integer.max = 255L;
#line 707
  return (0);
}
}
#line 710 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_volume_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  int high_low ;
  int reg ;
  u32 value ;

  {
  {
#line 713
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 714
  high_low = (int )(kcontrol->private_value >> 8) & 255;
#line 715
  reg = (int )kcontrol->private_value & 255;
#line 718
  value = snd_emu10k1_ptr20_read(emu, (unsigned int )reg, (unsigned int )high_low);
  }
#line 719
  if (high_low != 0) {
#line 720
    ucontrol->value.integer.value[0] = (long )(255U - (value >> 24));
#line 721
    ucontrol->value.integer.value[1] = (long )(~ (value >> 16)) & 255L;
  } else {
#line 723
    ucontrol->value.integer.value[0] = (long )(~ (value >> 8)) & 255L;
#line 724
    ucontrol->value.integer.value[1] = (long )(~ value) & 255L;
  }
#line 726
  return (0);
}
}
#line 729 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_volume_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  int high_low ;
  int reg ;
  u32 value ;
  u32 oval ;

  {
  {
#line 732
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 733
  high_low = (int )(kcontrol->private_value >> 8) & 255;
#line 734
  reg = (int )kcontrol->private_value & 255;
#line 737
  value = snd_emu10k1_ptr20_read(emu, (unsigned int )reg, 0U);
#line 737
  oval = value;
  }
#line 738
  if (high_low == 1) {
#line 739
    value = value & 65535U;
#line 740
    value = (u32 )((int )value | ((int )((255L - ucontrol->value.integer.value[0]) << 24) | (int )((255L - ucontrol->value.integer.value[1]) << 16)));
  } else {
#line 743
    value = value & 4294901760U;
#line 744
    value = (u32 )((int )value | ((int )((255L - ucontrol->value.integer.value[0]) << 8) | (int )(255U - (unsigned int )ucontrol->value.integer.value[1])));
  }
#line 747
  if (value != oval) {
    {
#line 748
    snd_emu10k1_ptr20_write(emu, (unsigned int )reg, 0U, value);
    }
#line 749
    return (1);
  } else {

  }
#line 751
  return (0);
}
}
#line 754 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_capture_source_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  char *texts[8U] ;

  {
#line 757
  texts[0] = (char *)"SPDIF";
#line 757
  texts[1] = (char *)"I2S";
#line 757
  texts[2] = (char *)"SRC48";
#line 757
  texts[3] = (char *)"SRCMulti_SPDIF";
#line 757
  texts[4] = (char *)"SRCMulti_I2S";
#line 757
  texts[5] = (char *)"CDIF";
#line 757
  texts[6] = (char *)"FX";
#line 757
  texts[7] = (char *)"AC97";
#line 762
  uinfo->type = 3;
#line 763
  uinfo->count = 1U;
#line 764
  uinfo->value.enumerated.items = 8U;
#line 765
  if (uinfo->value.enumerated.item > 7U) {
#line 766
    uinfo->value.enumerated.item = 7U;
  } else {

  }
  {
#line 767
  strcpy((char *)(& uinfo->value.enumerated.name), (char const   *)texts[uinfo->value.enumerated.item]);
  }
#line 768
  return (0);
}
}
#line 771 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_capture_source_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 774
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 776
  ucontrol->value.enumerated.item[0] = emu->p16v_capture_source;
#line 777
  return (0);
}
}
#line 780 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_capture_source_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  int change ;
  u32 mask ;
  u32 source ;
  unsigned int tmp ;

  {
#line 783
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 785
  change = 0;
#line 789
  val = ucontrol->value.enumerated.item[0];
#line 790
  if (val > 7U) {
#line 791
    return (-22);
  } else {

  }
#line 792
  change = emu->p16v_capture_source != val;
#line 793
  if (change != 0) {
    {
#line 794
    emu->p16v_capture_source = val;
#line 795
    source = (((val << 28) | (val << 24)) | (val << 20)) | (val << 16);
#line 796
    tmp = snd_emu10k1_ptr20_read(emu, 64U, 0U);
#line 796
    mask = tmp & 65535U;
#line 797
    snd_emu10k1_ptr20_write(emu, 64U, 0U, source | mask);
    }
  } else {

  }
#line 799
  return (change);
}
}
#line 802 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_capture_channel_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  char *texts[4U] ;

  {
#line 805
  texts[0] = (char *)"0";
#line 805
  texts[1] = (char *)"1";
#line 805
  texts[2] = (char *)"2";
#line 805
  texts[3] = (char *)"3";
#line 807
  uinfo->type = 3;
#line 808
  uinfo->count = 1U;
#line 809
  uinfo->value.enumerated.items = 4U;
#line 810
  if (uinfo->value.enumerated.item > 3U) {
#line 811
    uinfo->value.enumerated.item = 3U;
  } else {

  }
  {
#line 812
  strcpy((char *)(& uinfo->value.enumerated.name), (char const   *)texts[uinfo->value.enumerated.item]);
  }
#line 813
  return (0);
}
}
#line 816 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_capture_channel_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;

  {
#line 819
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 821
  ucontrol->value.enumerated.item[0] = emu->p16v_capture_channel;
#line 822
  return (0);
}
}
#line 825 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static int snd_p16v_capture_channel_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct snd_emu10k1 *emu ;
  unsigned int val ;
  int change ;
  u32 tmp ;
  unsigned int tmp___0 ;

  {
#line 828
  emu = (struct snd_emu10k1 *)kcontrol->private_data;
#line 830
  change = 0;
#line 833
  val = ucontrol->value.enumerated.item[0];
#line 834
  if (val > 3U) {
#line 835
    return (-22);
  } else {

  }
#line 836
  change = emu->p16v_capture_channel != val;
#line 837
  if (change != 0) {
    {
#line 838
    emu->p16v_capture_channel = val;
#line 839
    tmp___0 = snd_emu10k1_ptr20_read(emu, 22U, 0U);
#line 839
    tmp = tmp___0 & 65532U;
#line 840
    snd_emu10k1_ptr20_write(emu, 22U, 0U, tmp | val);
    }
  } else {

  }
#line 842
  return (change);
}
}
#line 844 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static unsigned int const   snd_p16v_db_scale1[4U]  = {      1U,      8U,      4294962121U,      65561U};
#line 857 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
static struct snd_kcontrol_new p16v_mixer_controls[10U]  = 
#line 857
  {      {2, 0U, 0U, (unsigned char *)"HD Analog Front Playback Volume", 0U, 19U, 0U,
      & snd_p16v_volume_info, & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      105UL}, 
        {2, 0U, 0U, (unsigned char *)"HD Analog Rear Playback Volume", 0U, 19U, 0U, & snd_p16v_volume_info,
      & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      362UL}, 
        {2, 0U, 0U, (unsigned char *)"HD Analog Center/LFE Playback Volume", 0U, 19U,
      0U, & snd_p16v_volume_info, & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      361UL}, 
        {2, 0U, 0U, (unsigned char *)"HD Analog Side Playback Volume", 0U, 19U, 0U, & snd_p16v_volume_info,
      & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      106UL}, 
        {2, 0U, 0U, (unsigned char *)"HD SPDIF Front Playback Volume", 0U, 19U, 0U, & snd_p16v_volume_info,
      & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      103UL}, 
        {2, 0U, 0U, (unsigned char *)"HD SPDIF Rear Playback Volume", 0U, 19U, 0U, & snd_p16v_volume_info,
      & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      360UL}, 
        {2, 0U, 0U, (unsigned char *)"HD SPDIF Center/LFE Playback Volume", 0U, 19U,
      0U, & snd_p16v_volume_info, & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      359UL}, 
        {2, 0U, 0U, (unsigned char *)"HD SPDIF Side Playback Volume", 0U, 19U, 0U, & snd_p16v_volume_info,
      & snd_p16v_volume_get, & snd_p16v_volume_put, {.p = (unsigned int const   *)(& snd_p16v_db_scale1)},
      104UL}, 
        {2, 0U, 0U, (unsigned char *)"HD source Capture", 0U, 0U, 0U, & snd_p16v_capture_source_info,
      & snd_p16v_capture_source_get, & snd_p16v_capture_source_put, {0}, 0UL}, 
        {2, 0U, 0U, (unsigned char *)"HD channel Capture", 0U, 0U, 0U, & snd_p16v_capture_channel_info,
      & snd_p16v_capture_channel_get, & snd_p16v_capture_channel_put, {0}, 0UL}};
#line 883 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
int snd_p16v_mixer(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  int err ;
  struct snd_card *card ;
  struct snd_kcontrol *tmp ;

  {
#line 886
  card = emu->card;
#line 888
  i = 0;
#line 888
  goto ldv_30642;
  ldv_30641: 
  {
#line 889
  tmp = snd_ctl_new1((struct snd_kcontrol_new  const  *)((struct snd_kcontrol_new *)(& p16v_mixer_controls) + (unsigned long )i),
                     (void *)emu);
#line 889
  err = snd_ctl_add(card, tmp);
  }
#line 889
  if (err < 0) {
#line 891
    return (err);
  } else {

  }
#line 888
  i = i + 1;
  ldv_30642: ;
#line 888
  if ((unsigned int )i <= 9U) {
#line 890
    goto ldv_30641;
  } else {

  }

#line 893
  return (0);
}
}
#line 900 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
int snd_p16v_alloc_pm_buffer(struct snd_emu10k1 *emu ) 
{ 
  void *tmp ;

  {
  {
#line 902
  tmp = vmalloc(512UL);
#line 902
  emu->p16v_saved = (unsigned int *)tmp;
  }
#line 903
  if ((unsigned long )emu->p16v_saved == (unsigned long )((unsigned int *)0U)) {
#line 904
    return (-12);
  } else {

  }
#line 905
  return (0);
}
}
#line 908 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
void snd_p16v_free_pm_buffer(struct snd_emu10k1 *emu ) 
{ 


  {
  {
#line 910
  vfree((void const   *)emu->p16v_saved);
  }
#line 911
  return;
}
}
#line 913 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
void snd_p16v_suspend(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  int ch ;
  unsigned int *val ;

  {
#line 918
  val = emu->p16v_saved;
#line 919
  ch = 0;
#line 919
  goto ldv_30660;
  ldv_30659: 
#line 920
  i = 0;
#line 920
  goto ldv_30657;
  ldv_30656: 
  {
#line 921
  *val = snd_emu10k1_ptr20_read(emu, (unsigned int )i, (unsigned int )ch);
#line 920
  i = i + 1;
#line 920
  val = val + 1;
  }
  ldv_30657: ;
#line 920
  if (i <= 127) {
#line 922
    goto ldv_30656;
  } else {

  }
#line 919
  ch = ch + 1;
  ldv_30660: ;
#line 919
  if (ch <= 0) {
#line 921
    goto ldv_30659;
  } else {

  }

#line 926
  return;
}
}
#line 924 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/lkbce/sound/pci/emu10k1/p16v.c"
void snd_p16v_resume(struct snd_emu10k1 *emu ) 
{ 
  int i ;
  int ch ;
  unsigned int *val ;

  {
#line 929
  val = emu->p16v_saved;
#line 930
  ch = 0;
#line 930
  goto ldv_30672;
  ldv_30671: 
#line 931
  i = 0;
#line 931
  goto ldv_30669;
  ldv_30668: 
  {
#line 932
  snd_emu10k1_ptr20_write(emu, (unsigned int )i, (unsigned int )ch, *val);
#line 931
  i = i + 1;
#line 931
  val = val + 1;
  }
  ldv_30669: ;
#line 931
  if (i <= 127) {
#line 933
    goto ldv_30668;
  } else {

  }
#line 930
  ch = ch + 1;
  ldv_30672: ;
#line 930
  if (ch <= 0) {
#line 932
    goto ldv_30671;
  } else {

  }

#line 937
  return;
}
}
#line 479 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_p16v.c.aux"
static void ldv___ldv_spin_lock_33___9(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 482
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 484
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 485
  return;
}
}
#line 497 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/weaver/.tmp_p16v.c.aux"
static void ldv___ldv_spin_lock_35___6(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 500
  ldv_spin_lock_emu_lock_of_snd_emu10k1();
#line 502
  __ldv_spin_lock(ldv_func_arg1);
  }
#line 503
  return;
}
}
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 27 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 29
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 30
    return ((dev->p)->driver_data);
  } else {

  }
#line 32
  return ((void *)0);
}
}
#line 41 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 43
  tmp = ldv_xzalloc(8UL);
#line 43
  dev->p = (struct device_private *)tmp;
#line 44
  (dev->p)->driver_data = data;
  }
#line 46
  return (0);
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 1432UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)(master + 1UL));
  }
#line 34
  return (master);
}
}
#line 28 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/err.h"
long ldv_is_err_or_null(void const   *ptr ) ;
#line 29
void *ldv_err_ptr(long error ) ;
#line 20 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 50 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.h"
bool ldv_in_interrupt_context(void) ;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
static bool __ldv_in_interrupt_context  =    0;
#line 28 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 30
  __ldv_in_interrupt_context = 1;
#line 31
  return;
}
}
#line 34 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 36
  __ldv_in_interrupt_context = 0;
#line 37
  return;
}
}
#line 39 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 41
  return (__ldv_in_interrupt_context);
}
}
#line 44 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 46
  __VERIFIER_assume(val <= 0);
  }
#line 47
  return (val);
}
}
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 56
  return (tmp);
}
}
#line 60 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 62
  return (tmp);
}
}
#line 66 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 68
  return (tmp);
}
}
#line 26 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/ldv/slab.h"
void *ldv_kmalloc_array(size_t n , size_t size , gfp_t flags ) ;
#line 28
extern void ldv_check_alloc_flags(gfp_t  ) ;
#line 29
extern void ldv_after_alloc(void * ) ;
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 24
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 21 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/mm/slab.c"
void *ldv_kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 25
  ldv_check_alloc_flags(flags);
#line 26
  res = ldv_malloc(size);
#line 27
  ldv_after_alloc(res);
  }
#line 29
  return (res);
}
}
#line 32 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/mm/slab.c"
void *ldv_kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 36
  ldv_check_alloc_flags(flags);
#line 37
  res = ldv_calloc(n, size);
#line 38
  ldv_after_alloc(res);
  }
#line 40
  return (res);
}
}
#line 43 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/mm/slab.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 47
  ldv_check_alloc_flags(flags);
#line 48
  res = ldv_zalloc(size);
#line 49
  ldv_after_alloc(res);
  }
#line 51
  return (res);
}
}
#line 54 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/linux/mm/slab.c"
void *ldv_kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 58
  ldv_check_alloc_flags(flags);
#line 59
  res = ldv_malloc(n * size);
#line 60
  ldv_after_alloc(res);
  }
#line 62
  return (res);
}
}
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/common.h"
extern void __VERIFIER_error(void) ;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/gcc.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 26
  return (exp);
}
}
#line 35 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/gcc.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 37
  __VERIFIER_error();
  }
#line 38
  return;
}
}
#line 31 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.h"
extern void *external_allocated_data(void) ;
#line 33
void *ldv_malloc_unknown_size(void) ;
#line 34
void *ldv_calloc_unknown_size(void) ;
#line 35
void *ldv_zalloc_unknown_size(void) ;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 25
extern void *calloc(size_t  , size_t  ) ;
#line 26
extern void free(void * ) ;
#line 29 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 31
  tmp___1 = ldv_undef_int();
  }
#line 31
  if (tmp___1 != 0) {
    {
#line 32
    tmp = malloc(size);
#line 32
    res = tmp;
#line 34
    __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    __VERIFIER_assume(tmp___0 == 0L);
    }
#line 37
    return (res);
  } else {
#line 40
    return ((void *)0);
  }
}
}
#line 43 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 48
    __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 49
    tmp___0 = ldv_is_err((void const   *)res);
#line 49
    __VERIFIER_assume(tmp___0 == 0L);
    }
#line 51
    return (res);
  } else {
#line 54
    return ((void *)0);
  }
}
}
#line 57 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 59
  tmp = ldv_calloc(1UL, size);
  }
#line 59
  return (tmp);
}
}
#line 62 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 64
  free(s);
  }
#line 65
  return;
}
}
#line 67 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 69
  tmp = malloc(size);
#line 69
  res = tmp;
#line 71
  __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 72
  tmp___0 = ldv_is_err((void const   *)res);
#line 72
  __VERIFIER_assume(tmp___0 == 0L);
  }
#line 74
  return (res);
}
}
#line 77 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 79
  tmp = calloc(1UL, size);
#line 79
  res = tmp;
#line 81
  __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 82
  tmp___0 = ldv_is_err((void const   *)res);
#line 82
  __VERIFIER_assume(tmp___0 == 0L);
  }
#line 84
  return (res);
}
}
#line 87 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 89
  tmp___1 = ldv_undef_int();
  }
#line 89
  if (tmp___1 != 0) {
    {
#line 90
    tmp = external_allocated_data();
#line 90
    res = tmp;
#line 92
    __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 93
    tmp___0 = ldv_is_err((void const   *)res);
#line 93
    __VERIFIER_assume(tmp___0 == 0L);
    }
#line 95
    return (res);
  } else {
#line 98
    return ((void *)0);
  }
}
}
#line 101 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 103
  tmp___1 = ldv_undef_int();
  }
#line 103
  if (tmp___1 != 0) {
    {
#line 104
    tmp = external_allocated_data();
#line 104
    res = tmp;
#line 106
    memset(res, 0, 8UL);
#line 107
    __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 108
    tmp___0 = ldv_is_err((void const   *)res);
#line 108
    __VERIFIER_assume(tmp___0 == 0L);
    }
#line 110
    return (res);
  } else {
#line 113
    return ((void *)0);
  }
}
}
#line 116 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 118
  tmp = ldv_calloc_unknown_size();
  }
#line 118
  return (tmp);
}
}
#line 121 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 123
  tmp = external_allocated_data();
#line 123
  res = tmp;
#line 125
  __VERIFIER_assume((unsigned long )res != (unsigned long )((void *)0));
#line 126
  tmp___0 = ldv_is_err((void const   *)res);
#line 126
  __VERIFIER_assume(tmp___0 == 0L);
  }
#line 128
  return (res);
}
}
#line 23 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.h"
int ldv_undef_long(void) ;
#line 24
unsigned int ldv_undef_uint(void) ;
#line 25
unsigned long ldv_undef_ulong(void) ;
#line 26
unsigned long long ldv_undef_ulonglong(void) ;
#line 27
void *ldv_undef_ptr(void) ;
#line 30
int ldv_undef_int_positive(void) ;
#line 36
int ldv_undef_int_nonpositive(void) ;
#line 39
void *ldv_undef_ptr_non_null(void) ;
#line 24 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 26
extern long __VERIFIER_nondet_long(void) ;
#line 33
extern unsigned int __VERIFIER_nondet_uint(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern unsigned long long __VERIFIER_nondet_ulonglong(void) ;
#line 38
extern void *__VERIFIER_nondet_pointer(void) ;
#line 41 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = __VERIFIER_nondet_int();
  }
#line 43
  return (tmp);
}
}
#line 46 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_long(void) 
{ 
  long tmp ;

  {
  {
#line 48
  tmp = __VERIFIER_nondet_long();
  }
#line 48
  return ((int )tmp);
}
}
#line 51 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
unsigned int ldv_undef_uint(void) 
{ 
  unsigned int tmp ;

  {
  {
#line 53
  tmp = __VERIFIER_nondet_uint();
  }
#line 53
  return (tmp);
}
}
#line 56 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = __VERIFIER_nondet_pointer();
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 63
  tmp = __VERIFIER_nondet_ulong();
  }
#line 63
  return (tmp);
}
}
#line 66 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
unsigned long long ldv_undef_ulonglong(void) 
{ 
  unsigned long long tmp ;

  {
  {
#line 68
  tmp = __VERIFIER_nondet_ulonglong();
  }
#line 68
  return (tmp);
}
}
#line 71 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_positive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 73
  tmp = ldv_undef_int();
#line 73
  ret = tmp;
#line 75
  __VERIFIER_assume(ret > 0);
  }
#line 77
  return (ret);
}
}
#line 80 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 82
  tmp = ldv_undef_int();
#line 82
  ret = tmp;
#line 84
  __VERIFIER_assume(ret < 0);
  }
#line 86
  return (ret);
}
}
#line 89 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 91
  tmp = ldv_undef_int();
#line 91
  ret = tmp;
#line 93
  __VERIFIER_assume(ret <= 0);
  }
#line 95
  return (ret);
}
}
#line 98 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/job/root/verifier/nondet.c"
void *ldv_undef_ptr_non_null(void) 
{ 
  void *ret ;
  int tmp ;

  {
  {
#line 100
  tmp = ldv_undef_int();
#line 100
  ret = (void *)((long )tmp);
#line 102
  __VERIFIER_assume((unsigned long )ret != (unsigned long )((void *)0));
  }
#line 104
  return (ret);
}
}
#line 1 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/rsg/models/spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_alloc_lock_of_task_struct  =    1;
#line 25 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_alloc_lock_of_task_struct == 1);
#line 30
  __VERIFIER_assume(ldv_spin_alloc_lock_of_task_struct == 1);
#line 32
  ldv_spin_alloc_lock_of_task_struct = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_alloc_lock_of_task_struct == 2);
#line 41
  __VERIFIER_assume(ldv_spin_alloc_lock_of_task_struct == 2);
#line 43
  ldv_spin_alloc_lock_of_task_struct = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_alloc_lock_of_task_struct == 1);
#line 54
  __VERIFIER_assume(ldv_spin_alloc_lock_of_task_struct == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_spin_alloc_lock_of_task_struct = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_alloc_lock_of_task_struct == 1);
#line 78
  __VERIFIER_assume(ldv_spin_alloc_lock_of_task_struct == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_alloc_lock_of_task_struct == 1);
#line 134
  __VERIFIER_assume(ldv_spin_alloc_lock_of_task_struct == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_spin_alloc_lock_of_task_struct = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_d_lock_of_dentry  =    1;
#line 153 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_d_lock_of_dentry(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_d_lock_of_dentry == 1);
#line 158
  __VERIFIER_assume(ldv_spin_d_lock_of_dentry == 1);
#line 160
  ldv_spin_d_lock_of_dentry = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_d_lock_of_dentry(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_d_lock_of_dentry == 2);
#line 169
  __VERIFIER_assume(ldv_spin_d_lock_of_dentry == 2);
#line 171
  ldv_spin_d_lock_of_dentry = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_d_lock_of_dentry(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_d_lock_of_dentry == 1);
#line 182
  __VERIFIER_assume(ldv_spin_d_lock_of_dentry == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_spin_d_lock_of_dentry = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_d_lock_of_dentry(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_d_lock_of_dentry == 1);
#line 206
  __VERIFIER_assume(ldv_spin_d_lock_of_dentry == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_d_lock_of_dentry(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_spin_d_lock_of_dentry == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_d_lock_of_dentry(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_spin_is_locked_d_lock_of_dentry();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_d_lock_of_dentry(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_d_lock_of_dentry(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_d_lock_of_dentry == 1);
#line 262
  __VERIFIER_assume(ldv_spin_d_lock_of_dentry == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_spin_d_lock_of_dentry = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_emu_lock_of_snd_emu10k1  =    1;
#line 281 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_emu_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 286
  __VERIFIER_assume(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 288
  ldv_spin_emu_lock_of_snd_emu10k1 = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_emu_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_emu_lock_of_snd_emu10k1 == 2);
#line 297
  __VERIFIER_assume(ldv_spin_emu_lock_of_snd_emu10k1 == 2);
#line 299
  ldv_spin_emu_lock_of_snd_emu10k1 = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_emu_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 310
  __VERIFIER_assume(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_spin_emu_lock_of_snd_emu10k1 = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_emu_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 334
  __VERIFIER_assume(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_emu_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_spin_emu_lock_of_snd_emu10k1 == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_emu_lock_of_snd_emu10k1(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_spin_is_locked_emu_lock_of_snd_emu10k1();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_emu_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_emu_lock_of_snd_emu10k1(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 390
  __VERIFIER_assume(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_spin_emu_lock_of_snd_emu10k1 = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_i2c_lock_of_snd_emu10k1  =    1;
#line 409 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_i2c_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 414
  __VERIFIER_assume(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 416
  ldv_spin_i2c_lock_of_snd_emu10k1 = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_i2c_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_i2c_lock_of_snd_emu10k1 == 2);
#line 425
  __VERIFIER_assume(ldv_spin_i2c_lock_of_snd_emu10k1 == 2);
#line 427
  ldv_spin_i2c_lock_of_snd_emu10k1 = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_i2c_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 438
  __VERIFIER_assume(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_spin_i2c_lock_of_snd_emu10k1 = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_i2c_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 462
  __VERIFIER_assume(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_i2c_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_spin_i2c_lock_of_snd_emu10k1 == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_i2c_lock_of_snd_emu10k1(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_spin_is_locked_i2c_lock_of_snd_emu10k1();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_i2c_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_i2c_lock_of_snd_emu10k1(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 518
  __VERIFIER_assume(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_spin_i2c_lock_of_snd_emu10k1 = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_i_lock_of_inode  =    1;
#line 537 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_i_lock_of_inode == 1);
#line 542
  __VERIFIER_assume(ldv_spin_i_lock_of_inode == 1);
#line 544
  ldv_spin_i_lock_of_inode = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_i_lock_of_inode == 2);
#line 553
  __VERIFIER_assume(ldv_spin_i_lock_of_inode == 2);
#line 555
  ldv_spin_i_lock_of_inode = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_i_lock_of_inode == 1);
#line 566
  __VERIFIER_assume(ldv_spin_i_lock_of_inode == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_spin_i_lock_of_inode = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_i_lock_of_inode == 1);
#line 590
  __VERIFIER_assume(ldv_spin_i_lock_of_inode == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_spin_is_locked_i_lock_of_inode();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_i_lock_of_inode == 1);
#line 646
  __VERIFIER_assume(ldv_spin_i_lock_of_inode == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_spin_i_lock_of_inode = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_input_lock_of_snd_emu10k1_midi  =    1;
#line 665 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_input_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 670
  __VERIFIER_assume(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 672
  ldv_spin_input_lock_of_snd_emu10k1_midi = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_input_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_input_lock_of_snd_emu10k1_midi == 2);
#line 681
  __VERIFIER_assume(ldv_spin_input_lock_of_snd_emu10k1_midi == 2);
#line 683
  ldv_spin_input_lock_of_snd_emu10k1_midi = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_input_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 694
  __VERIFIER_assume(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_spin_input_lock_of_snd_emu10k1_midi = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_input_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 718
  __VERIFIER_assume(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_input_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_spin_input_lock_of_snd_emu10k1_midi == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_input_lock_of_snd_emu10k1_midi(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_spin_is_locked_input_lock_of_snd_emu10k1_midi();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_input_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_input_lock_of_snd_emu10k1_midi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 774
  __VERIFIER_assume(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_spin_input_lock_of_snd_emu10k1_midi = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_irq_lock_of_snd_emu10k1_fx8010  =    1;
#line 793 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 798
  __VERIFIER_assume(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 800
  ldv_spin_irq_lock_of_snd_emu10k1_fx8010 = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 2);
#line 809
  __VERIFIER_assume(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 2);
#line 811
  ldv_spin_irq_lock_of_snd_emu10k1_fx8010 = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 822
  __VERIFIER_assume(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_spin_irq_lock_of_snd_emu10k1_fx8010 = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 846
  __VERIFIER_assume(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_spin_is_locked_irq_lock_of_snd_emu10k1_fx8010();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_irq_lock_of_snd_emu10k1_fx8010(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 902
  __VERIFIER_assume(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_spin_irq_lock_of_snd_emu10k1_fx8010 = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 918 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 921 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 926
  __VERIFIER_assume(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 928
  ldv_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 929
  return;
}
}
#line 932 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 935
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_lock_of_NOT_ARG_SIGN == 2);
#line 937
  __VERIFIER_assume(ldv_spin_lock_of_NOT_ARG_SIGN == 2);
#line 939
  ldv_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 940
  return;
}
}
#line 943 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 950
  __VERIFIER_assume(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 953
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 956
  if (is_spin_held_by_another_thread != 0) {
#line 958
    return (0);
  } else {
#line 962
    ldv_spin_lock_of_NOT_ARG_SIGN = 2;
#line 964
    return (1);
  }
}
}
#line 969 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 974
  __VERIFIER_assume(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 975
  return;
}
}
#line 978 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 983
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 986
  if (ldv_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 988
    return (0);
  } else {
#line 992
    return (1);
  }
}
}
#line 997 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 1000
  tmp = ldv_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 1000
  return (tmp == 0);
}
}
#line 1004 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1009
  is_spin_contended = ldv_undef_int();
  }
#line 1012
  if (is_spin_contended != 0) {
#line 1014
    return (0);
  } else {
#line 1018
    return (1);
  }
}
}
#line 1023 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1028
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1030
  __VERIFIER_assume(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1033
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1036
  if (atomic_value_after_dec == 0) {
#line 1038
    ldv_spin_lock_of_NOT_ARG_SIGN = 2;
#line 1040
    return (1);
  } else {

  }
#line 1044
  return (0);
}
}
#line 1046 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_lock_of_snd_pcm_group  =    1;
#line 1049 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_lock_of_snd_pcm_group(void) 
{ 


  {
  {
#line 1052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1054
  __VERIFIER_assume(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1056
  ldv_spin_lock_of_snd_pcm_group = 2;
  }
#line 1057
  return;
}
}
#line 1060 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_lock_of_snd_pcm_group(void) 
{ 


  {
  {
#line 1063
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_lock_of_snd_pcm_group == 2);
#line 1065
  __VERIFIER_assume(ldv_spin_lock_of_snd_pcm_group == 2);
#line 1067
  ldv_spin_lock_of_snd_pcm_group = 1;
  }
#line 1068
  return;
}
}
#line 1071 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_lock_of_snd_pcm_group(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1078
  __VERIFIER_assume(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1081
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1084
  if (is_spin_held_by_another_thread != 0) {
#line 1086
    return (0);
  } else {
#line 1090
    ldv_spin_lock_of_snd_pcm_group = 2;
#line 1092
    return (1);
  }
}
}
#line 1097 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_lock_of_snd_pcm_group(void) 
{ 


  {
  {
#line 1100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1102
  __VERIFIER_assume(ldv_spin_lock_of_snd_pcm_group == 1);
  }
#line 1103
  return;
}
}
#line 1106 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_lock_of_snd_pcm_group(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1111
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1114
  if (ldv_spin_lock_of_snd_pcm_group == 1 && is_spin_held_by_another_thread == 0) {
#line 1116
    return (0);
  } else {
#line 1120
    return (1);
  }
}
}
#line 1125 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_lock_of_snd_pcm_group(void) 
{ 
  int tmp ;

  {
  {
#line 1128
  tmp = ldv_spin_is_locked_lock_of_snd_pcm_group();
  }
#line 1128
  return (tmp == 0);
}
}
#line 1132 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_lock_of_snd_pcm_group(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1137
  is_spin_contended = ldv_undef_int();
  }
#line 1140
  if (is_spin_contended != 0) {
#line 1142
    return (0);
  } else {
#line 1146
    return (1);
  }
}
}
#line 1151 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_lock_of_snd_pcm_group(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1158
  __VERIFIER_assume(ldv_spin_lock_of_snd_pcm_group == 1);
#line 1161
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1164
  if (atomic_value_after_dec == 0) {
#line 1166
    ldv_spin_lock_of_snd_pcm_group = 2;
#line 1168
    return (1);
  } else {

  }
#line 1172
  return (0);
}
}
#line 1174 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_memblk_lock_of_snd_emu10k1  =    1;
#line 1177 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_memblk_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1182
  __VERIFIER_assume(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1184
  ldv_spin_memblk_lock_of_snd_emu10k1 = 2;
  }
#line 1185
  return;
}
}
#line 1188 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_memblk_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1191
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_memblk_lock_of_snd_emu10k1 == 2);
#line 1193
  __VERIFIER_assume(ldv_spin_memblk_lock_of_snd_emu10k1 == 2);
#line 1195
  ldv_spin_memblk_lock_of_snd_emu10k1 = 1;
  }
#line 1196
  return;
}
}
#line 1199 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_memblk_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1206
  __VERIFIER_assume(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1209
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1212
  if (is_spin_held_by_another_thread != 0) {
#line 1214
    return (0);
  } else {
#line 1218
    ldv_spin_memblk_lock_of_snd_emu10k1 = 2;
#line 1220
    return (1);
  }
}
}
#line 1225 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_memblk_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1228
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1230
  __VERIFIER_assume(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
  }
#line 1231
  return;
}
}
#line 1234 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_memblk_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1239
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1242
  if (ldv_spin_memblk_lock_of_snd_emu10k1 == 1 && is_spin_held_by_another_thread == 0) {
#line 1244
    return (0);
  } else {
#line 1248
    return (1);
  }
}
}
#line 1253 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_memblk_lock_of_snd_emu10k1(void) 
{ 
  int tmp ;

  {
  {
#line 1256
  tmp = ldv_spin_is_locked_memblk_lock_of_snd_emu10k1();
  }
#line 1256
  return (tmp == 0);
}
}
#line 1260 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_memblk_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1265
  is_spin_contended = ldv_undef_int();
  }
#line 1268
  if (is_spin_contended != 0) {
#line 1270
    return (0);
  } else {
#line 1274
    return (1);
  }
}
}
#line 1279 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_memblk_lock_of_snd_emu10k1(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1286
  __VERIFIER_assume(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 1289
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1292
  if (atomic_value_after_dec == 0) {
#line 1294
    ldv_spin_memblk_lock_of_snd_emu10k1 = 2;
#line 1296
    return (1);
  } else {

  }
#line 1300
  return (0);
}
}
#line 1302 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_node_size_lock_of_pglist_data  =    1;
#line 1305 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1310
  __VERIFIER_assume(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1312
  ldv_spin_node_size_lock_of_pglist_data = 2;
  }
#line 1313
  return;
}
}
#line 1316 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1319
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_node_size_lock_of_pglist_data == 2);
#line 1321
  __VERIFIER_assume(ldv_spin_node_size_lock_of_pglist_data == 2);
#line 1323
  ldv_spin_node_size_lock_of_pglist_data = 1;
  }
#line 1324
  return;
}
}
#line 1327 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1334
  __VERIFIER_assume(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1337
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1340
  if (is_spin_held_by_another_thread != 0) {
#line 1342
    return (0);
  } else {
#line 1346
    ldv_spin_node_size_lock_of_pglist_data = 2;
#line 1348
    return (1);
  }
}
}
#line 1353 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1356
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1358
  __VERIFIER_assume(ldv_spin_node_size_lock_of_pglist_data == 1);
  }
#line 1359
  return;
}
}
#line 1362 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1367
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1370
  if (ldv_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 1372
    return (0);
  } else {
#line 1376
    return (1);
  }
}
}
#line 1381 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 1384
  tmp = ldv_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 1384
  return (tmp == 0);
}
}
#line 1388 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1393
  is_spin_contended = ldv_undef_int();
  }
#line 1396
  if (is_spin_contended != 0) {
#line 1398
    return (0);
  } else {
#line 1402
    return (1);
  }
}
}
#line 1407 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1414
  __VERIFIER_assume(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 1417
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1420
  if (atomic_value_after_dec == 0) {
#line 1422
    ldv_spin_node_size_lock_of_pglist_data = 2;
#line 1424
    return (1);
  } else {

  }
#line 1428
  return (0);
}
}
#line 1430 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_open_lock_of_snd_emu10k1_midi  =    1;
#line 1433 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_open_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 1436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1438
  __VERIFIER_assume(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1440
  ldv_spin_open_lock_of_snd_emu10k1_midi = 2;
  }
#line 1441
  return;
}
}
#line 1444 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_open_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 1447
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_open_lock_of_snd_emu10k1_midi == 2);
#line 1449
  __VERIFIER_assume(ldv_spin_open_lock_of_snd_emu10k1_midi == 2);
#line 1451
  ldv_spin_open_lock_of_snd_emu10k1_midi = 1;
  }
#line 1452
  return;
}
}
#line 1455 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_open_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1462
  __VERIFIER_assume(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1465
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1468
  if (is_spin_held_by_another_thread != 0) {
#line 1470
    return (0);
  } else {
#line 1474
    ldv_spin_open_lock_of_snd_emu10k1_midi = 2;
#line 1476
    return (1);
  }
}
}
#line 1481 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_open_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 1484
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1486
  __VERIFIER_assume(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
  }
#line 1487
  return;
}
}
#line 1490 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_open_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1495
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1498
  if (ldv_spin_open_lock_of_snd_emu10k1_midi == 1 && is_spin_held_by_another_thread == 0) {
#line 1500
    return (0);
  } else {
#line 1504
    return (1);
  }
}
}
#line 1509 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_open_lock_of_snd_emu10k1_midi(void) 
{ 
  int tmp ;

  {
  {
#line 1512
  tmp = ldv_spin_is_locked_open_lock_of_snd_emu10k1_midi();
  }
#line 1512
  return (tmp == 0);
}
}
#line 1516 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_open_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1521
  is_spin_contended = ldv_undef_int();
  }
#line 1524
  if (is_spin_contended != 0) {
#line 1526
    return (0);
  } else {
#line 1530
    return (1);
  }
}
}
#line 1535 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_open_lock_of_snd_emu10k1_midi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1542
  __VERIFIER_assume(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 1545
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1548
  if (atomic_value_after_dec == 0) {
#line 1550
    ldv_spin_open_lock_of_snd_emu10k1_midi = 2;
#line 1552
    return (1);
  } else {

  }
#line 1556
  return (0);
}
}
#line 1558 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_output_lock_of_snd_emu10k1_midi  =    1;
#line 1561 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_output_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 1564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1566
  __VERIFIER_assume(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1568
  ldv_spin_output_lock_of_snd_emu10k1_midi = 2;
  }
#line 1569
  return;
}
}
#line 1572 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_output_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 1575
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_output_lock_of_snd_emu10k1_midi == 2);
#line 1577
  __VERIFIER_assume(ldv_spin_output_lock_of_snd_emu10k1_midi == 2);
#line 1579
  ldv_spin_output_lock_of_snd_emu10k1_midi = 1;
  }
#line 1580
  return;
}
}
#line 1583 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_output_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1590
  __VERIFIER_assume(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1593
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1596
  if (is_spin_held_by_another_thread != 0) {
#line 1598
    return (0);
  } else {
#line 1602
    ldv_spin_output_lock_of_snd_emu10k1_midi = 2;
#line 1604
    return (1);
  }
}
}
#line 1609 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_output_lock_of_snd_emu10k1_midi(void) 
{ 


  {
  {
#line 1612
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1614
  __VERIFIER_assume(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
  }
#line 1615
  return;
}
}
#line 1618 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_output_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1623
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1626
  if (ldv_spin_output_lock_of_snd_emu10k1_midi == 1 && is_spin_held_by_another_thread == 0) {
#line 1628
    return (0);
  } else {
#line 1632
    return (1);
  }
}
}
#line 1637 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_output_lock_of_snd_emu10k1_midi(void) 
{ 
  int tmp ;

  {
  {
#line 1640
  tmp = ldv_spin_is_locked_output_lock_of_snd_emu10k1_midi();
  }
#line 1640
  return (tmp == 0);
}
}
#line 1644 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_output_lock_of_snd_emu10k1_midi(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1649
  is_spin_contended = ldv_undef_int();
  }
#line 1652
  if (is_spin_contended != 0) {
#line 1654
    return (0);
  } else {
#line 1658
    return (1);
  }
}
}
#line 1663 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_output_lock_of_snd_emu10k1_midi(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1670
  __VERIFIER_assume(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 1673
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1676
  if (atomic_value_after_dec == 0) {
#line 1678
    ldv_spin_output_lock_of_snd_emu10k1_midi = 2;
#line 1680
    return (1);
  } else {

  }
#line 1684
  return (0);
}
}
#line 1686 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_reg_lock_of_snd_emu10k1  =    1;
#line 1689 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_reg_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1694
  __VERIFIER_assume(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1696
  ldv_spin_reg_lock_of_snd_emu10k1 = 2;
  }
#line 1697
  return;
}
}
#line 1700 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_reg_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1703
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_reg_lock_of_snd_emu10k1 == 2);
#line 1705
  __VERIFIER_assume(ldv_spin_reg_lock_of_snd_emu10k1 == 2);
#line 1707
  ldv_spin_reg_lock_of_snd_emu10k1 = 1;
  }
#line 1708
  return;
}
}
#line 1711 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_reg_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1718
  __VERIFIER_assume(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1721
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1724
  if (is_spin_held_by_another_thread != 0) {
#line 1726
    return (0);
  } else {
#line 1730
    ldv_spin_reg_lock_of_snd_emu10k1 = 2;
#line 1732
    return (1);
  }
}
}
#line 1737 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_reg_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1740
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1742
  __VERIFIER_assume(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
  }
#line 1743
  return;
}
}
#line 1746 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_reg_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1751
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1754
  if (ldv_spin_reg_lock_of_snd_emu10k1 == 1 && is_spin_held_by_another_thread == 0) {
#line 1756
    return (0);
  } else {
#line 1760
    return (1);
  }
}
}
#line 1765 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_reg_lock_of_snd_emu10k1(void) 
{ 
  int tmp ;

  {
  {
#line 1768
  tmp = ldv_spin_is_locked_reg_lock_of_snd_emu10k1();
  }
#line 1768
  return (tmp == 0);
}
}
#line 1772 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_reg_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1777
  is_spin_contended = ldv_undef_int();
  }
#line 1780
  if (is_spin_contended != 0) {
#line 1782
    return (0);
  } else {
#line 1786
    return (1);
  }
}
}
#line 1791 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_reg_lock_of_snd_emu10k1(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1798
  __VERIFIER_assume(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 1801
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1804
  if (atomic_value_after_dec == 0) {
#line 1806
    ldv_spin_reg_lock_of_snd_emu10k1 = 2;
#line 1808
    return (1);
  } else {

  }
#line 1812
  return (0);
}
}
#line 1814 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_siglock_of_sighand_struct  =    1;
#line 1817 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_siglock_of_sighand_struct == 1);
#line 1822
  __VERIFIER_assume(ldv_spin_siglock_of_sighand_struct == 1);
#line 1824
  ldv_spin_siglock_of_sighand_struct = 2;
  }
#line 1825
  return;
}
}
#line 1828 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1831
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_siglock_of_sighand_struct == 2);
#line 1833
  __VERIFIER_assume(ldv_spin_siglock_of_sighand_struct == 2);
#line 1835
  ldv_spin_siglock_of_sighand_struct = 1;
  }
#line 1836
  return;
}
}
#line 1839 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_siglock_of_sighand_struct == 1);
#line 1846
  __VERIFIER_assume(ldv_spin_siglock_of_sighand_struct == 1);
#line 1849
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1852
  if (is_spin_held_by_another_thread != 0) {
#line 1854
    return (0);
  } else {
#line 1858
    ldv_spin_siglock_of_sighand_struct = 2;
#line 1860
    return (1);
  }
}
}
#line 1865 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1868
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_siglock_of_sighand_struct == 1);
#line 1870
  __VERIFIER_assume(ldv_spin_siglock_of_sighand_struct == 1);
  }
#line 1871
  return;
}
}
#line 1874 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1879
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1882
  if (ldv_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 1884
    return (0);
  } else {
#line 1888
    return (1);
  }
}
}
#line 1893 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 1896
  tmp = ldv_spin_is_locked_siglock_of_sighand_struct();
  }
#line 1896
  return (tmp == 0);
}
}
#line 1900 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1905
  is_spin_contended = ldv_undef_int();
  }
#line 1908
  if (is_spin_contended != 0) {
#line 1910
    return (0);
  } else {
#line 1914
    return (1);
  }
}
}
#line 1919 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_siglock_of_sighand_struct == 1);
#line 1926
  __VERIFIER_assume(ldv_spin_siglock_of_sighand_struct == 1);
#line 1929
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1932
  if (atomic_value_after_dec == 0) {
#line 1934
    ldv_spin_siglock_of_sighand_struct = 2;
#line 1936
    return (1);
  } else {

  }
#line 1940
  return (0);
}
}
#line 1942 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_spi_lock_of_snd_emu10k1  =    1;
#line 1945 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_spi_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 1950
  __VERIFIER_assume(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 1952
  ldv_spin_spi_lock_of_snd_emu10k1 = 2;
  }
#line 1953
  return;
}
}
#line 1956 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_spi_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1959
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_spi_lock_of_snd_emu10k1 == 2);
#line 1961
  __VERIFIER_assume(ldv_spin_spi_lock_of_snd_emu10k1 == 2);
#line 1963
  ldv_spin_spi_lock_of_snd_emu10k1 = 1;
  }
#line 1964
  return;
}
}
#line 1967 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_spi_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 1974
  __VERIFIER_assume(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 1977
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1980
  if (is_spin_held_by_another_thread != 0) {
#line 1982
    return (0);
  } else {
#line 1986
    ldv_spin_spi_lock_of_snd_emu10k1 = 2;
#line 1988
    return (1);
  }
}
}
#line 1993 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_spi_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 1996
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 1998
  __VERIFIER_assume(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
  }
#line 1999
  return;
}
}
#line 2002 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_spi_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2007
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2010
  if (ldv_spin_spi_lock_of_snd_emu10k1 == 1 && is_spin_held_by_another_thread == 0) {
#line 2012
    return (0);
  } else {
#line 2016
    return (1);
  }
}
}
#line 2021 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_spi_lock_of_snd_emu10k1(void) 
{ 
  int tmp ;

  {
  {
#line 2024
  tmp = ldv_spin_is_locked_spi_lock_of_snd_emu10k1();
  }
#line 2024
  return (tmp == 0);
}
}
#line 2028 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_spi_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 2033
  is_spin_contended = ldv_undef_int();
  }
#line 2036
  if (is_spin_contended != 0) {
#line 2038
    return (0);
  } else {
#line 2042
    return (1);
  }
}
}
#line 2047 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_spi_lock_of_snd_emu10k1(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 2052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 2054
  __VERIFIER_assume(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 2057
  atomic_value_after_dec = ldv_undef_int();
  }
#line 2060
  if (atomic_value_after_dec == 0) {
#line 2062
    ldv_spin_spi_lock_of_snd_emu10k1 = 2;
#line 2064
    return (1);
  } else {

  }
#line 2068
  return (0);
}
}
#line 2070 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
static int ldv_spin_voice_lock_of_snd_emu10k1  =    1;
#line 2073 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_lock_voice_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 2076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2078
  __VERIFIER_assume(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2080
  ldv_spin_voice_lock_of_snd_emu10k1 = 2;
  }
#line 2081
  return;
}
}
#line 2084 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_voice_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 2087
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_spin_voice_lock_of_snd_emu10k1 == 2);
#line 2089
  __VERIFIER_assume(ldv_spin_voice_lock_of_snd_emu10k1 == 2);
#line 2091
  ldv_spin_voice_lock_of_snd_emu10k1 = 1;
  }
#line 2092
  return;
}
}
#line 2095 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_trylock_voice_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2102
  __VERIFIER_assume(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2105
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2108
  if (is_spin_held_by_another_thread != 0) {
#line 2110
    return (0);
  } else {
#line 2114
    ldv_spin_voice_lock_of_snd_emu10k1 = 2;
#line 2116
    return (1);
  }
}
}
#line 2121 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_spin_unlock_wait_voice_lock_of_snd_emu10k1(void) 
{ 


  {
  {
#line 2124
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2126
  __VERIFIER_assume(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
  }
#line 2127
  return;
}
}
#line 2130 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_locked_voice_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2135
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2138
  if (ldv_spin_voice_lock_of_snd_emu10k1 == 1 && is_spin_held_by_another_thread == 0) {
#line 2140
    return (0);
  } else {
#line 2144
    return (1);
  }
}
}
#line 2149 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_can_lock_voice_lock_of_snd_emu10k1(void) 
{ 
  int tmp ;

  {
  {
#line 2152
  tmp = ldv_spin_is_locked_voice_lock_of_snd_emu10k1();
  }
#line 2152
  return (tmp == 0);
}
}
#line 2156 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_spin_is_contended_voice_lock_of_snd_emu10k1(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 2161
  is_spin_contended = ldv_undef_int();
  }
#line 2164
  if (is_spin_contended != 0) {
#line 2166
    return (0);
  } else {
#line 2170
    return (1);
  }
}
}
#line 2175 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_atomic_dec_and_lock_voice_lock_of_snd_emu10k1(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 2180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2182
  __VERIFIER_assume(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
#line 2185
  atomic_value_after_dec = ldv_undef_int();
  }
#line 2188
  if (atomic_value_after_dec == 0) {
#line 2190
    ldv_spin_voice_lock_of_snd_emu10k1 = 2;
#line 2192
    return (1);
  } else {

  }
#line 2196
  return (0);
}
}
#line 2199 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
void ldv_check_final_state(void) 
{ 


  {
  {
#line 2202
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_alloc_lock_of_task_struct == 1);
#line 2204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_d_lock_of_dentry == 1);
#line 2206
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_emu_lock_of_snd_emu10k1 == 1);
#line 2208
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_i2c_lock_of_snd_emu10k1 == 1);
#line 2210
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_i_lock_of_inode == 1);
#line 2212
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_input_lock_of_snd_emu10k1_midi == 1);
#line 2214
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 1);
#line 2216
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_lock_of_NOT_ARG_SIGN == 1);
#line 2218
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_lock_of_snd_pcm_group == 1);
#line 2220
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_memblk_lock_of_snd_emu10k1 == 1);
#line 2222
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_node_size_lock_of_pglist_data == 1);
#line 2224
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_open_lock_of_snd_emu10k1_midi == 1);
#line 2226
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_output_lock_of_snd_emu10k1_midi == 1);
#line 2228
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_reg_lock_of_snd_emu10k1 == 1);
#line 2230
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_siglock_of_sighand_struct == 1);
#line 2232
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_spi_lock_of_snd_emu10k1 == 1);
#line 2234
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_spin_voice_lock_of_snd_emu10k1 == 1);
  }
#line 2235
  return;
}
}
#line 2238 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 2241
  if (ldv_spin_alloc_lock_of_task_struct == 2) {
#line 2243
    return (1);
  } else {

  }
#line 2246
  if (ldv_spin_d_lock_of_dentry == 2) {
#line 2248
    return (1);
  } else {

  }
#line 2251
  if (ldv_spin_emu_lock_of_snd_emu10k1 == 2) {
#line 2253
    return (1);
  } else {

  }
#line 2256
  if (ldv_spin_i2c_lock_of_snd_emu10k1 == 2) {
#line 2258
    return (1);
  } else {

  }
#line 2261
  if (ldv_spin_i_lock_of_inode == 2) {
#line 2263
    return (1);
  } else {

  }
#line 2266
  if (ldv_spin_input_lock_of_snd_emu10k1_midi == 2) {
#line 2268
    return (1);
  } else {

  }
#line 2271
  if (ldv_spin_irq_lock_of_snd_emu10k1_fx8010 == 2) {
#line 2273
    return (1);
  } else {

  }
#line 2276
  if (ldv_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 2278
    return (1);
  } else {

  }
#line 2281
  if (ldv_spin_lock_of_snd_pcm_group == 2) {
#line 2283
    return (1);
  } else {

  }
#line 2286
  if (ldv_spin_memblk_lock_of_snd_emu10k1 == 2) {
#line 2288
    return (1);
  } else {

  }
#line 2291
  if (ldv_spin_node_size_lock_of_pglist_data == 2) {
#line 2293
    return (1);
  } else {

  }
#line 2296
  if (ldv_spin_open_lock_of_snd_emu10k1_midi == 2) {
#line 2298
    return (1);
  } else {

  }
#line 2301
  if (ldv_spin_output_lock_of_snd_emu10k1_midi == 2) {
#line 2303
    return (1);
  } else {

  }
#line 2306
  if (ldv_spin_reg_lock_of_snd_emu10k1 == 2) {
#line 2308
    return (1);
  } else {

  }
#line 2311
  if (ldv_spin_siglock_of_sighand_struct == 2) {
#line 2313
    return (1);
  } else {

  }
#line 2316
  if (ldv_spin_spi_lock_of_snd_emu10k1 == 2) {
#line 2318
    return (1);
  } else {

  }
#line 2321
  if (ldv_spin_voice_lock_of_snd_emu10k1 == 2) {
#line 2323
    return (1);
  } else {

  }
#line 2326
  return (0);
}
}
#line 3 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/fvtp/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/fvtp/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/fvtp/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15 "/home/debian/klever-inst/klever-work/native-scheduler/scheduler/jobs/0e1bde0fd9f35a6cc77d73de70635c06/klever-core-work-dir/17/vtg/sound/pci/emu10k1/snd-emu10k1-synth.koc507da9a45b7/linux:kernel:locking:spinlock/fvtp/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 16
  if (! expr) {
    {
#line 17
    __VERIFIER_error();
    }
  } else {

  }
#line 18
  return;
}
}
